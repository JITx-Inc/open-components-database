#use-added-syntax(jitx)
defpackage ocdb/modules/solvers/voltage-divider :
  import core
  import collections
  import math
  import jitx with :
    prefix(Resistor) => EModel-
  import jitx/commands
  import ocdb/utils/defaults
  import ocdb/utils/generic-components
  import ocdb/utils/generator-utils
  import ocdb/utils/checks
  import ocdb/utils/design-vars
  import ocdb/utils/db-parts


defstruct Ratio :
  high: Double
  low: Double
  loss: Double

public defstruct VoltageDividerSolution :
  r1: Resistor
  r2: Resistor
  vo: Toleranced ; valid when solving for output target
  vi: Toleranced ; valid when solving for input target

public defn voltage-divider-solver (v-in: Toleranced, v-out: Toleranced,
                                    current: Toleranced) -> VoltageDividerSolution|False:
  fatal("Current specified to the voltage-divider-solver cannot be 0.0A") when typ(current) == 0.0
  val [v-given, v-target] = [v-in, v-out]
  val goal-r-hi = abs(typ-value(v-given) - typ-value(v-target)) /  typ-value(current)
  val goal-r-lo = typ-value(v-target) /  typ-value(current)

  label<VoltageDividerSolution|False> return :
    ; Look for highest acceptable tolerance in EIA standard values: [20% 10% 5% 2% 1% 0.5% 0.25% 0.1%]
    for std-tol in std-tols do :
      val tolerance = std-tol / 100.   ; std-tols are in % in [0, 100.0] so change to be between [0, 1.0]
      val lo-tol = tol(1.0, tolerance) ; calc 1.0 - std-tol/100 -> 0.99 for std-tol of 1% so create Toleranced(1.0, 1.01, 0.99)
      val hi-tol = tol(1.0, tolerance) ; calc 1.0 + std-tol/100 -> 1.01 for std-tol of 1% so create Toleranced(1.0, 1.01, 0.99)
      ; println("v-in=%_, v-out=%_, goal-r-lo=%_, goal-r-hi=%_, lo-tol=%_, hi-tol=%_" % [v-in, v-out, goal-r-lo, goal-r-hi, lo-tol, hi-tol])

      if check-voltage-range(v-given, v-target, goal-r-lo, goal-r-hi, lo-tol, hi-tol, tol(1.0), tol(1.0)) :
        val solution = voltage-divider-solver(v-in, v-out, current, tolerance)
        if solution is VoltageDividerSolution :
          return(solution)

public defn reverse-voltage-divider-solver (v-in: Toleranced, v-out: Toleranced,
                                    current: Toleranced) -> VoltageDividerSolution|False:
  fatal("Current specified to the voltage-divider-solver cannot be 0.0A") when typ(current) == 0.0
  val [v-given, v-target] = [v-out, v-in]
  val goal-r-hi = abs(typ-value(v-target) - typ-value(v-given)) /  typ-value(current)
  val goal-r-lo = typ-value(v-given) /  typ-value(current)

  label<VoltageDividerSolution|False> return :
    ; Look for highest acceptable tolerance in EIA standard values: [20% 10% 5% 2% 1% 0.5% 0.25% 0.1%]
    for std-tol in std-tols do :
      val tolerance = std-tol / 100.   ; std-tols are in % in [0, 100.0] so change to be between [0, 1.0]
      val lo-tol = tol(1.0, tolerance) ; calc 1.0 - std-tol/100 -> 0.99 for std-tol of 1% so create Toleranced(1.0, 1.01, 0.99)
      val hi-tol = tol(1.0, tolerance) ; calc 1.0 + std-tol/100 -> 1.01 for std-tol of 1% so create Toleranced(1.0, 1.01, 0.99)
      ; println("v-in=%_, v-out=%_, goal-r-lo=%_, goal-r-hi=%_, lo-tol=%_, hi-tol=%_" % [v-in, v-out, goal-r-lo, goal-r-hi, lo-tol, hi-tol])

      if check-reverse-voltage-range(v-given, v-target, goal-r-lo, goal-r-hi, lo-tol, hi-tol, tol(1.0), tol(1.0)) :
        val solution = reverse-voltage-divider-solver(v-in, v-out, current, tolerance)
        if solution is VoltageDividerSolution :
          return(solution)

public defn voltage-divider-solver (v-in: Toleranced, v-out: Toleranced,
                                    current: Toleranced, tolerance: Double) -> VoltageDividerSolution|False :
  fatal("Current specified to the voltage-divider-solver cannot be 0.0A") when typ(current) == 0.0
  val [v-given, v-target] = [v-in, v-out]
  val goal-r-hi = abs(typ-value(v-given) - typ-value(v-target)) /  typ-value(current)
  val goal-r-lo = typ-value(v-target) /  typ-value(current)
  ; Find best resistors matching output requirement
  val current-tol = (tol+%(current) + tol-%(current) / 2.0) / 100.0
  val hi-res = get-resistance-values(goal-r-hi, tolerance, current-tol)
  val lo-res = get-resistance-values(goal-r-lo, tolerance, current-tol)

  ; println("    inside voltage-divider-solver(5): v-given=%_ v-target=%_ goal-r-hi=%_ goal-r-lo=%_ current-tol=%_ hi-res=%_ lo-res=%_" % [v-given v-target goal-r-hi goal-r-lo current-tol hi-res lo-res])

  label<VoltageDividerSolution|False> return :
    for ratio in calc-sort-r-pairs(v-given, v-target, tolerance, hi-res, lo-res) do :
      println("    - Querying resistors for R1=%_立 R2=%_立 tol=%_" % [high(ratio), low(ratio), tolerance])
      val r-his = query-resistors(high(ratio), tolerance)
      val r-los = query-resistors( low(ratio), tolerance)

      if length(r-his) >= 3 and length(r-los) >= 3 :
        val r-hi-cmp = r-his[0]
        val r-lo-cmp = r-los[0]
        val v-calc = study-solution(v-given, r-hi-cmp, r-lo-cmp)

        if in-range?(v-target, v-calc) :
          println("      Solved: mpn1=%_, mpn2=%_, v-calc=(%_V), current=%_A"
                  % [mpn(r-hi-cmp), mpn(r-lo-cmp), v-calc, typ-value(v-calc) / low(ratio)])
          return(VoltageDividerSolution(r-hi-cmp, r-lo-cmp, v-calc, v-given))
        else :
          println("      Ignoring: not a solution when taking into account TCRs.")
      else :
        println("      Ignoring: there must at least 3 resistors of each type, only found %_ & %_" % [length(r-his) length(r-los)])
    println("   No solution.")

public defn reverse-voltage-divider-solver (v-in: Toleranced, v-out: Toleranced,
                                            current: Toleranced, 
                                            tolerance: Double) -> VoltageDividerSolution|False :
  fatal("Current specified to the voltage-divider-solver cannot be 0.0A") when typ(current) == 0.0
  val [v-given, v-target] = [v-out, v-in]
  val goal-r-hi = abs(typ-value(v-target) - typ-value(v-given)) /  typ-value(current)
  val goal-r-lo = typ-value(v-given) /  typ-value(current)
  ; Find best resistors matching output requirement
  val current-tol = (tol+%(current) + tol-%(current) / 2.0) / 100.0
  val hi-res = get-resistance-values(goal-r-hi, tolerance, current-tol)
  val lo-res = get-resistance-values(goal-r-lo, tolerance, current-tol)

  ; println("    inside reverse-voltage-divider-solver: v-given=%_ v-target=%_ goal-r-hi=%_ goal-r-lo=%_ current-tol=%_ hi-res=%_ lo-res=%_" % [v-given v-target goal-r-hi goal-r-lo current-tol hi-res lo-res])

  label<VoltageDividerSolution|False> return :
    for ratio in calc-sort-reverse-r-pairs(v-given, v-target, tolerance, hi-res, lo-res) do :
      println("    - Querying resistors for R1=%_立 R2=%_立 tol=%_" % [high(ratio), low(ratio), tolerance])
      val r-his = query-resistors(high(ratio), tolerance)
      val r-los = query-resistors( low(ratio), tolerance)

      if length(r-his) >= 3 and length(r-los) >= 3 :
        val r-hi-cmp = r-his[0]
        val r-lo-cmp = r-los[0]
        val v-calc = study-reverse-solution(v-given, r-hi-cmp, r-lo-cmp)

        if in-range?(v-target, v-calc) :
          println("      Solved: mpn1=%_, mpn2=%_, v-calc=(%_V), current=%_A"
                  % [mpn(r-hi-cmp), mpn(r-lo-cmp), v-calc, typ-value(v-calc) / low(ratio)])
          return(VoltageDividerSolution(r-hi-cmp, r-lo-cmp, v-given, v-calc))
        else :
          println("      Ignoring: not a solution when taking into account TCRs.")
      else :
        println("      Ignoring: there must at least 3 resistors of each type, only found %_ & %_" % [length(r-his) length(r-los)])
    println("   No solution.")


defn get-resistance-values (goal-r: Double, r-tol: Double, current-tol: Double) -> Tuple<Double> :
  query-available-resistance-values(["min-resistance" => (1. - current-tol) * goal-r,
                                     "max-resistance" => (1. + current-tol) * goal-r,
                                     "tolerance.min" => -1. * r-tol,
                                     "tolerance.max" => r-tol,
                                     "minimum_quantity" => 1,
                                     "mounting" => PREFERRED-MOUNTING,
                                     "case" => get-valid-pkg-list(),
                                     "min-stock" => 5 * DESIGN-QUANTITY], ["tcr"])

defn calc-sort-r-pairs (v-given: Toleranced, v-target: Toleranced,
                                                  tolerance: Double,
                                                  hi-res: Tuple<Double>, lo-res: Tuple<Double>) :
  val default-tol = tol(1.0, tolerance)
  val no-delta = tol(1.0)
  qsort{loss, _} $
    for rh in hi-res seq-cat :
      for rl in lo-res seq? :
        val v-res = compute-voltage-range(v-given, rl, rh, default-tol, default-tol, no-delta, no-delta)
        if in-range?(v-target, v-res) :
          val loss = abs(typ-value(v-target) - typ-value(v-res))
          One(Ratio(rh, rl, loss))
        else :
          None()

defn calc-sort-reverse-r-pairs (v-given: Toleranced, v-target: Toleranced,
                                tolerance: Double,
                                hi-res: Tuple<Double>, lo-res: Tuple<Double>) :
  val default-tol = tol(1.0, tolerance)
  val no-delta = tol(1.0)
  qsort{loss, _} $
    for rh in hi-res seq-cat :
      for rl in lo-res seq? :
        val v-res = compute-reverse-voltage-range(v-given, rl, rh, default-tol, default-tol, no-delta, no-delta)
        if in-range?(v-target, v-res) :
          val loss = abs(typ-value(v-target) - typ-value(v-res))
          One(Ratio(rh, rl, loss))
        else :
          None()

; lo-tol, hi-tol, lo-dr, are Tolerances of positive percentages.
; A value of 1.0 is equivalent to 100%.
public defn compute-voltage-range ( v-given:  Toleranced,
                                    r-lo-val: Double,     r-hi-val: Double,
                                    lo-tol:   Toleranced, hi-tol:   Toleranced,
                                    lo-dr:    Toleranced, hi-dr:    Toleranced) -> Toleranced :
  val r-lo = r-lo-val * lo-dr * lo-tol
  val r-hi = r-hi-val * hi-dr * hi-tol
  val r-hi-min = min-value(r-hi)
  val r-hi-typ = typ-value(r-hi)
  val r-hi-max = max-value(r-hi)
  val r-lo-max = max-value(r-lo)
  val r-lo-typ = typ-value(r-lo)
  val r-lo-min = min-value(r-lo)
  val v-given-min = min-value(v-given)
  val v-given-typ = typ-value(v-given)
  val v-given-max = max-value(v-given)

  val [v-min, v-nom, v-max] = 
       [(v-given-min * r-lo-min / (r-lo-min + r-hi-max)),
       (v-given-typ * r-lo-typ / (r-lo-typ + r-hi-typ))
       (v-given-max * r-lo-max / (r-lo-max + r-hi-min))]
  min-typ-max(v-min, v-nom, v-max)

public defn compute-reverse-voltage-range ( v-given:  Toleranced,
                                    r-lo-val: Double,     r-hi-val: Double,
                                    lo-tol:   Toleranced, hi-tol:   Toleranced,
                                    lo-dr:    Toleranced, hi-dr:    Toleranced) -> Toleranced :
  val r-lo = r-lo-val * lo-dr * lo-tol
  val r-hi = r-hi-val * hi-dr * hi-tol
  val r-hi-min = min-value(r-hi)
  val r-hi-typ = typ-value(r-hi)
  val r-hi-max = max-value(r-hi)
  val r-lo-max = max-value(r-lo)
  val r-lo-typ = typ-value(r-lo)
  val r-lo-min = min-value(r-lo)
  val v-given-min = min-value(v-given)
  val v-given-typ = typ-value(v-given)
  val v-given-max = max-value(v-given)

  val [v-min, v-nom, v-max] = 
      [(v-given-min * (1.0 + r-hi-min / r-lo-max)), 
       (v-given-typ * (1.0 + r-hi-typ / r-lo-typ)), 
       (v-given-max * (1.0 + r-hi-max / r-lo-min ))]
  min-typ-max(v-min, v-nom, v-max)

public defn check-voltage-range ( v-given:  Toleranced, v-target: Toleranced,
                                  r-lo-val: Double,     r-hi-val: Double,
                                  lo-tol:   Toleranced, hi-tol:   Toleranced,
                                  lo-dr:    Toleranced, hi-dr:    Toleranced) -> True|False :
  val v-calc = compute-voltage-range( v-given,
                                      r-lo-val, r-hi-val,
                                      lo-tol, hi-tol,
                                      lo-dr, hi-dr)
  in-range?(v-target, v-calc)

public defn check-reverse-voltage-range ( v-given:  Toleranced, v-target: Toleranced,
                                  r-lo-val: Double,     r-hi-val: Double,
                                  lo-tol:   Toleranced, hi-tol:   Toleranced,
                                  lo-dr:    Toleranced, hi-dr:    Toleranced) -> True|False :
  val v-calc = compute-reverse-voltage-range( v-given,
                                      r-lo-val, r-hi-val,
                                      lo-tol, hi-tol,
                                      lo-dr, hi-dr)
  in-range?(v-target, v-calc)

defn query-resistors (resistance:Double, tol:Double) -> Tuple<Resistor> :
  Resistors(["resistance" => resistance,
             "tolerance.min" => -1. * tol,
             "tolerance.max" => tol,
             "minimum_quantity" => 1,
             "mounting" => PREFERRED-MOUNTING,
             "case" => get-valid-pkg-list(),
             "min-stock" => 5 * DESIGN-QUANTITY,
             "_exist" => ["tcr"]],
            25)

defn study-solution (v-given:Toleranced, r-hi:Resistor, r-lo:Resistor) -> Toleranced :
  val lo-drs = [delta-resistance(r-lo, min-value(OPERATING-TEMPERATURE)), 0., delta-resistance(r-lo, max-value(OPERATING-TEMPERATURE))]
  val hi-drs = [delta-resistance(r-hi, min-value(OPERATING-TEMPERATURE)), 0., delta-resistance(r-hi, max-value(OPERATING-TEMPERATURE))]

  ; Calculate worst case.
  ; TCR can be + or - here. It's a tolerance, not an absolute change in resistance
  val rlo-tolerance = tolerance(r-lo) as MinMaxRange
  val rhi-tolerance = tolerance(r-hi) as MinMaxRange
  println("      Checking solution for existing components with: hi-tol=%_, lo-tol=%_" % [rhi-tolerance, rlo-tolerance])

  compute-voltage-range(v-given,
                        resistance(r-lo),
                        resistance(r-hi),
                        min-max(1.0 + min(rlo-tolerance), 1.0 + max(rlo-tolerance)),
                        min-max(1.0 + min(rhi-tolerance), 1.0 + max(rhi-tolerance)),
                        min-max(1.0 + minimum(lo-drs), 1.0 + maximum(lo-drs)),
                        min-max(1.0 + minimum(hi-drs), 1.0 + maximum(hi-drs)))

defn study-reverse-solution (v-given:Toleranced, r-hi:Resistor, r-lo:Resistor) -> Toleranced :
  val lo-drs = [delta-resistance(r-lo, min-value(OPERATING-TEMPERATURE)), 0., delta-resistance(r-lo, max-value(OPERATING-TEMPERATURE))]
  val hi-drs = [delta-resistance(r-hi, min-value(OPERATING-TEMPERATURE)), 0., delta-resistance(r-hi, max-value(OPERATING-TEMPERATURE))]

  ; Calculate worst case.
  ; TCR can be + or - here. It's a tolerance, not an absolute change in resistance
  val rlo-tolerance = tolerance(r-lo) as MinMaxRange
  val rhi-tolerance = tolerance(r-hi) as MinMaxRange
  println("      Checking solution for existing components with: hi-tol=%_, lo-tol=%_" % [rhi-tolerance, rlo-tolerance])

  compute-reverse-voltage-range(v-given,
                        resistance(r-lo),
                        resistance(r-hi),
                        min-max(1.0 + min(rlo-tolerance), 1.0 + max(rlo-tolerance)),
                        min-max(1.0 + min(rhi-tolerance), 1.0 + max(rhi-tolerance)),
                        min-max(1.0 + minimum(lo-drs), 1.0 + maximum(lo-drs)),
                        min-max(1.0 + minimum(hi-drs), 1.0 + maximum(hi-drs)))
