#use-added-syntax(jitx)
defpackage ocdb/scripts/cubemx-importer:
  import core
  import collections
  import jitx
  import jitx/commands
  import jitx/xml
  import lang-utils
  import ocdb/bundles

;==============================================================================
;================================== IR ========================================
;==============================================================================

; A pin defined by CubeMX XML
public defstruct Stm32Pin:
  pin-name:Ref,     ; name of the pin
  pad-name:String,  ; name of the corresponding pad
  pin-type:String,  ; the type of pin
  signals:Tuple<String>, ; supported signals

; An IP block defined by CubeMX XML
public defstruct Stm32Ip:
  name:String,
  instance-name:String,

; A microcontroller defined by CubeMX XML
public defstruct Stm32MCU:
  family:String,  ; mcu family
  package:String, ; package for this mcu
  ref:String,     ; reference designator
  pins:Tuple<Stm32Pin> ; pins of the mcu
  ip: Tuple<Stm32Ip>   ; ip blocks of the mcu

;==============================================================================
;=============================== Parsing ======================================
;==============================================================================
public defn Stm32Pin (elt:Elt):
  Stm32Pin(
    ref-ify(get-String(elt, `Name))
    get-String(elt, `Position)
    get-String(elt, `Type)
    to-tuple(seq(get-String{_, `Name}, get-children(elt, `Signal)))
  )

public defn Stm32Ip (elt:Elt):
  Stm32Ip(
    get-String(elt, `Name)
    get-String(elt, `InstanceName)
  )

public defn Stm32MCU (elt:Elt):
  Stm32MCU(
    get-String(elt, `Family)
    get-String(elt, `Package)
    get-String(elt, `RefName)
    to-tuple(seq(Stm32Pin, get-children(elt, `Pin)))
    to-tuple(seq(Stm32Ip, get-children(elt, `IP)))
  )

public defn Stm32MCU (xml-path:String):
  Stm32MCU(read-xml-file(xml-path))

;==============================================================================
;============================== Printers ======================================
;==============================================================================
defmethod print (o:OutputStream, p:Stm32Pin):
  println(o, "pin:")
  val os = IndentedStream(o)
  println(os, "pin-name: %_" % [pin-name(p)])
  println(os, "pad-name: %_" % [pad-name(p)])
  println(os, "pad-type: %_" % [pin-type(p)])
  if not empty?(signals(p)):
    println(os, "signals:")
    do(println{IndentedStream(os), _}, signals(p))

defmethod print (o:OutputStream, i:Stm32Ip):
  println(o, "ip:")
  val os = IndentedStream(o)
  println(os, "name: %_" % [name(i)])
  println(os, "instance-name: %_" % [instance-name(i)])

defmethod print (o:OutputStream, s:Stm32MCU):
  println(o, "mcu:")
  val os = IndentedStream(o)
  println(os, "family: %_" % [family(s)])
  println(os, "package: %_" % [package(s)])
  println(os, "ref: %_" % [ref(s)])
  println(os, "pins:")
  do(print{IndentedStream(os), _}, pins(s))
  println(os, "ip:")
  do(print{IndentedStream(os), _}, ip(s))

;==============================================================================
;=============================== Helpers ======================================
;==============================================================================
; Convert a string representation of a pin name into a ref
defn ref-ify (s:String) -> Ref:
  ; we assume names begin with a letter, or else we have problems
  if not letter?(s[0]):
    fatal("pin name %_ does not begin with a letter" % [s])
  ; internal helper. Returns the baseref and integer if the value ends in a number, 
  ; false otherwise
  defn ends-in-number? (s) -> False|[String, Int]:
    var ref-end = length(s) - 1
    while digit?(s[ref-end]) and ref-end > 0:
      ref-end = ref-end - 1
    val [start, end] = [s[0 through ref-end], s[(ref-end + 1) to false]]
    if empty?(end):
      false
    else:
      [start, to-int(end)]
  ; extract the ref from a string
  match(ends-in-number?(s)):
    (_:False): Ref(s)
    (p:[String, Int]):
      val [prefix, postfix] = p
      IndexRef(Ref(prefix), postfix)

;==============================================================================
;============================== Importer ======================================
;==============================================================================
; defn single-pin-bundle (o:OutputStream, bundle-name:String):
;   println(o, "pcb-bundle %_:" % [bundle-name])
;   println(IndentedStream(o), "pin p")

defn split-at-first (s:String, c:Char) -> False|[String, String]:
  match(index-of-char(s, c)):
    (i:Int):
      [s[0 to i], s[min(i + 1, length(s) - 1) to false]]
    (_:False): false

public defstruct Stm32Supports?:
  bundle:JITXDef,
  pins:Tuple<KeyValue<Ref, String>>

public defn print-supports (mcu:Stm32MCU):
  ; bundles we care about are:
  ; - i2c
  ; - spi
  ; - uart
  ; - gpio

  ; instance-name -> ip-name
  val bundles = [
    adc, 
    uart,
    spi,
    i2c,
    gpio,
  ]
  val bundle-names = to-tuple(seq(to-string{name(_)}, bundles))
  val ip-instance-table = to-hashtable<String, JITXDef> $ 
    for ip-block in ip(mcu) seq?:
      match(find(fn (b:JITXDef): name(b) == lower-case(name(ip-block)), bundles)):
        (_:False): None()
        (b:JITXDef):
          One(instance-name(ip-block) => b)
  
  for instance in ip-instance-table do:
    val related-pins = to-tuple $ 
      for pin in pins(mcu) seq?:
        label<Maybe<KeyValue<Ref, String>>> break:
          for signal in signals(pin) do:
            val ss = split-at-first(signal, '_')
            match(ss:[String, String]):
              val [inst, sig] = ss
              if inst == key(instance):
                break(One(pin-name(pin) => sig))
          None()
    println("%_: [%,]" % [key(instance), related-pins])
  do(println{"%_ => %_" % [key(_0), name(value(_0))]}, ip-instance-table)