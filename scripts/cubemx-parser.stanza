#use-added-syntax(jitx)
defpackage ocdb/scripts/cubemx-importer:
  import core
  import collections
  import lang-utils

defstruct CSV:
  data: Tuple<Tuple<False|String>>

defn lookup (csv, row:Int, col:Int) -> False|String:
  data(csv)[row][col]

defn num-rows (csv:CSV) -> Int:
  length(data(csv))

defn num-cols (csv:CSV) -> Int:
  length(data(csv)[0])

defn by-column (csv:CSV) -> HashTable<String, Tuple<False|String>>:
  to-hashtable<String, Tuple<False|String>> $
    for c in 0 to num-cols(csv) seq:
      lookup(csv, 0, c) as String => to-tuple $
        for r in 1 to num-rows(csv) seq:
          lookup(csv, r, c)

defn parse-csv (doc:String) -> CSV:
  val lines = split(doc, "\r\n")
  CSV{to-tuple(_)} $
    for line in lines seq:
      to-tuple(seq({false when empty?(_0) else _0}, split(line, ",")))

deftype CubeMXData
defmulti names (data:CubeMXData) -> Seqable<String>
defmulti data (data:CubeMXData, name:String) -> HashTable<String, False|String>
defmulti position-of (data:CubeMXData, name:String) -> String
defmulti type-of (data:CubeMXData, name:String) -> String
defmulti signal-of? (data:CubeMXData, name:String) -> False|String
defmulti label-of? (data:CubeMXData, name:String) -> False|String
defmulti alternate-functions-of (data:CubeMXData, name:String) -> Seqable<String>

defmethod print (o:OutputStream, c:CubeMXData):
  for n in names(c) do: 
    println(o, "pin %_" % [n])
    for kv in filter({value(_) is-not False}, data(c, n)) do:
      println(IndentedStream(o), "%_: %_" % [key(kv), value(kv)])

defn parse-cubemx-csv (csv-path:String):
  val tables = by-column(parse-csv(slurp(csv-path)))
  val name-indices = to-hashtable<String, Int> $
    for (entry in tables["Name"], index in 0 to false) seq:
      entry as String => index
  
  new CubeMXData:
    defmethod names (this):
      seq({_ as String}, tables["Name"])
    defmethod data (this, name:String):
      to-hashtable<String, False|String> $
        for table in filter({key(_) != "Name"}, tables) seq:
          key(table) => value(table)[name-indices[name]]

    defmethod position-of (this, name:String):
      data(this, name)["Position"] as String
    defmethod type-of (this, name:String):
      data(this, name)["Type"] as String
    defmethod signal-of? (this, name:String):
      data(this, name)["Signal"]
    defmethod label-of? (this, name:String):
      data(this, name)["Label"]
    defmethod alternate-functions-of (this, name:String):
      for field in data(this, name) seq?:
        match(value(field)):
          (_:False): None()
          (s:String):
            One(s) when prefix?(key(field), "AF") else None()

val cube-data = parse-cubemx-csv("STM32MP157FAAx.csv")
