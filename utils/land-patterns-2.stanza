#use-added-syntax(jitx)
defpackage ocdb/land-patterns-2:
  import core
  import collections
  import math
  import jitx
  import jitx/fonts
  import jitx/commands
  import lang-utils
  import error-buffer

;==================================================================================================
; Pad utilities
;==================================================================================================
; A scale factor, either as a ratio or fixed size in mm.
pcb-struct ocdb/land-patterns-2/ScaleFactor:  
  ratio?:True|False
  value:Double

; Create a scale factor. Defaults to a fixed size. 
public defn ScaleFactor (scale:Double):
  ScaleFactor(false, scale)

; Apply a scale factor to a pad shape
public defn scale (s:PadShape, factor:ScaleFactor) -> PadShape:
  if ratio?(factor):
    scale(s, value(factor), value(factor))
  else:
    val x-scale = (width(s) + factor) / width(s)
    val y-scale = (height(s) + factor) / height(s)
    scale(s, x-scale, y-scale)

; A valid shape for a pad
public deftype PadShape:
  Rectangle <: PadShape
  Capsule   <: PadShape
  Circle    <: PadShape
  RoundedRectangle <: PadShape

; A valid shape for a hole in a pad
public deftype HoleShape:
  Capsule <: HoleShape
  Circle  <: HoleShape

; A helper struct to contain the arguments used for a single pad
pcb-struct ocdb/land-patterns-2/PadArgs :
  copper:      PadShape,
  solder-mask: PadShape,
  paste:       False|PadShape,
  hole:        False|HoleShape,

; Helpers to substitute shapes on a pad
public defn sub-copper (p:PadArgs, s:PadShape):      PadArgs(s, solder-mask(p), paste(p), hole(p))
public defn sub-solder-mask (p:PadArgs, s:PadShape): PadArgs(copper(p), s, paste(p), hole(p))
public defn sub-paste (p:PadArgs, s:False|PadShape): PadArgs(copper(p), solder-mask(p), s, hole(p))
public defn sub-hole (p:PadArgs, s:False|PadShape):  PadArgs(copper(p), solder-mask(p), paste(p), s)

; Helpers to scale shapes on a pad
public defn scale-copper (p:PadArgs, s:ScaleFactor):      sub-copper(p, scale(copper(p), s))
public defn scale-solder-mask (p:PadArgs, s:ScaleFactor): sub-solder-mask(p, scale(solder-mask(p), s))
public defn scale-paste (p:PadArgs, s:ScaleFactor):       sub-paste(p, call?(scale{_, s}, paste(p)))
public defn scale-hole (p:PadArgs, s:ScaleFactor):        sub-hole(p, call?(scale{_, s},  hole(p)))

; Create a pad from its soldermask shape and scale factor
public defn pad-args-from-soldermask (shape:PadShape, pad-scale:ScaleFactor) -> PadArgs:
  val copper-shape = scale(shape, pad-scale)
  PadArgs(copper-shape, shape, copper-shape, false)

; Create a pad from its copper shape and a scale factor 
public defn pad-args-from-copper (shape:PadShape, solder-mask-scale:ScaleFactor) -> PadArgs:
  PadArgs(shape, solder-mask-scale, false, shape)

; Create PadArgs from a pad shape
public defn PadArgs (shape:PadShape):
  PadArgs(shape, shape, shape, false)

; Create PadArgs from a shape, and mask scale factor, and paste-scale
public defn PadArgs (shape:PadShape, mask-scale:ScaleFactor, paste-scale:False|ScaleFactor):
  PadArgs(shape, scale(shape, mask-scale), call?(scale{shape, _}, paste-scale))

; Create PadArgs from a shape and mask scale factor
public defn PadArgs (shape:PadShape, mask-scale:ScaleFactor):
  PadArgs(shape, scale(shape, mask-scale), shape, false)

; Extract PadArgs from a PcbPad
public defn PadArgs (pad:JITXObject):
  fatal("unimplemented")
  PadArgs(Rectangle(0.0, 0.0)) ; please the type checker

; Convert PadArgs to a pcb-pad
public pcb-pad to-pad (args:PadArgs):
  type  = TH when hole(args) is-not False else SMD
  shape = copper(args)
  layer(SolderMask(Top)) = solder-mask(args)

  if paste(args) is Shape:
    layer(Paste(Top)) = paste(args) as Shape
  
  if hole(args)is Shape:
    layer(Cutout(Top)) = hole(args) as Shape

; Create a pad from its soldermask shape
public defn pad-from-solder-mask (shape:Shape, pad-scale:Double):
  pad-from-solder-mask(shape, ScaleFactor(pad-scale))

; Create a pad from its soldermask shape
public pcb-pad pad-from-solder-mask (shape:Shape, pad-scale:ScaleFactor):
  if shape is-not PadShape:
    fatal("%_ is not a valid pad shape. Must be Circle, Capsule, or Rectangle." % [shape])
  to-pad(pad-args-from-soldermask(shape as PadShape, pad-scale))

; Create a pad from its copper shapae
public defn pad-from-copper (shape:Shape, mask-scale:Double):
  pad-from-copper(shape, ScaleFactor(mask-scale))

; Create a pad from its copper shape
public pcb-pad pad-from-copper (shape:Shape, mask-scale:ScaleFactor):
  if shape is-not PadShape:
    fatal("%_ is not a valid pad shape. Must be Circle, Capsule, or Rectangle." % [shape])
  to-pad(pad-args-from-copper(shape as PadShape, mask-scale))

;==================================================================================================
; Checks 
;==================================================================================================
; blocked on pcb-enum support
public defenum IPCCourtyardSize:
  Small, 
  Medium, 
  Large

; blocked on pcb-enum support
public defenum PadShapeKind:
  Rigid,
  Flex,
  Printed

; A helper struct to contain the contraints of landpatterns
pcb-struct ocdb/land-patterns-2/LandpatternConstraints:
  min-width:Double,             ; minimum width of the copper, cutout, and soldermask layers
  min-space:Double,             ; minimum spacing of the copper, cutout, and soldermask layers
  min-drill:Double,             ; minimum drill size 
  min-silk-copper-space:Double, ; minimum spacing between silk screen and copper
  min-silk-mask-space:Double,   ; minimum spacing between silk screen and soldermask
  min-silk-cutout-space:Double, ; minimum spacing between silk screen and cutout
  min-silk-width:Double,        ; minimum width of a line on the silk screen
  min-silk-text-height:Double,  ; minimum height of the silkscreen text
  ; courtyard-size: IPCCourtyardSize blocked on pcb-enum support
  ; pad-shape-kind: PadShapeKind blocke don pcb-enum support
  
public defn sub-min-silk-text-height (self:LandPatternConstraints, value:Double) -> LandPatternConstraints:
  LandPatternConstraints(
    min-width(self)
    min-space(self) 
    min-drill(self)
    min-silk-copper-spaec(self) 
    min-silk-mask-space(self) 
    min-silk-cutout-space(self) 
    min-silk-width(self)
    value
  )

public defn sub-min-width (self:LandPatternConstraints, value:Double) -> LandPatternConstraints:
  LandPatternConstraints(
    value
    min-space(self) 
    min-drill(self)
    min-silk-copper-spaec(self) 
    min-silk-mask-space(self) 
    min-silk-cutout-space(self) 
    min-silk-width(self)
    min-silk-text-height(self)
  )

public defn sub-min-space (self:LandPatternConstraints, value:Double) -> LandPatternConstraints:
  LandPatternConstraints(
    min-width(self)
    value
    min-drill(self)
    min-silk-copper-space(self) 
    min-silk-mask-space(self) 
    min-silk-cutout-space(self) 
    min-silk-width(self)
    min-silk-text-height(self)
  )

public defn sub-min-drill (self:LandPatternConstraints, value:Double) -> LandPatternConstraints:
  LandPatternConstraints(
    min-width(self)
    min-space(self) 
    value
    min-silk-copper-space(self) 
    min-silk-mask-space(self) 
    min-silk-cutout-space(self) 
    min-silk-width(self)
    min-silk-text-height(self)
  )

public defn sub-min-silk-copper-space (self:LandPatternConstraints, value:Double) -> LandPatternConstraints:
  LandPatternConstraints(
    min-width(self)
    min-space(self) 
    min-drill(self)
    value
    min-silk-mask-space(self) 
    min-silk-cutout-space(self) 
    min-silk-width(self)
    min-silk-text-height(self)
  )

public defn sub-min-silk-mask-space (self:LandPatternConstraints, value:Double) -> LandPatternConstraints:
  LandPatternConstraints(
    min-width(self)
    min-space(self) 
    min-drill(self)
    min-silk-copper-space(self) 
    value
    min-silk-cutout-space(self) 
    min-silk-width(self)
    min-silk-text-height(self)
  )

public defn sub-min-silk-cutout-space (self:LandPatternConstraints, value:Double) -> LandPatternConstraints:
  LandPatternConstraints(
    min-width(self)
    min-space(self) 
    min-drill(self)
    min-silk-copper-space(self) 
    min-silk-mask-space(self) 
    value
    min-silk-width(self)
    min-silk-text-height(self)
  )

public defn sub- (self:LandPatternConstraints, value:Double) -> LandPatternConstraints:
  LandPatternConstraints(
    min-width(self)
    min-space(self) 
    min-drill(self)
    min-silk-copper-space(self) 
    min-silk-mask-space(self) 
    min-silk-cutout-space(self) 
    min-silk-width(self)
    min-silk-text-height(self)
  )

public defn sub-min-silk-text-height (self:LandPatternConstraints, value:Double) -> LandPatternConstraints:
  LandPatternConstraints(
    min-width(self)
    min-space(self) 
    min-drill(self)
    min-silk-copper-space(self) 
    min-silk-mask-space(self) 
    min-silk-cutout-space(self) 
    value
    min-silk-text-height(self)
  )

defn LandPatternConstraints ():
  ; [TODO] reasonable defaults
  LandPatternConstraints(
    0.0, 
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
  )

; public defn initiliaze-contraints ():
;   inside pcb-landpattern:
;     if not has-property?(self.constraints):
;       property(self.constraints) = LandPatternConstraints()

; #for FIELD in [
;   min-width
;   min-height
;   min-drill
;   min-silk-copper-space
;   min-silk-mask-space
;   min-cutout-space
;   min-silk-width
;   min-silk-text-height
; ]:
;   public defn set-FIELD (value:Double):
;     initialize-contraints()
;     inside pcb-landpattern:
;       val constraints = property(self.constraints)
;       property(self.contraints) = sub-FIELD(self.contraints)

; Validate if a set of pad arguments violates the contraints
defn check-pads! (constraints: LandpatternConstraints, p:Seqable<PadArgs>, info:String):
  val copper-layer = seq(copper, p)
  val mask-layer   = seq(solder-mask, p)
  val cutout-layer = seq?({One(hole(_0) as Shape) when hole(_0) is-not False else None()}, p)
  
  val copper_ = min-space-min-trace(copper-layer)
  val mask_   = min-space-min-trace(mask-layer)
  val cutout_ = min-space-min-trace(cutout-layer)

  within collect-errors():
    val ops = [ 
      [copper_, min-width, "Copper"]
      [mask_,   min-width, "Soldermask"]
      [cutout_, min-drill, "Cutout/Hole"]
    ]
    for op in ops do: 
      val [layer-data, width-check, layer-name] = op
      val [spacing, width] = layer-data
      if spacing < min-space(constraints):
        issue-error(Exception("%_: %_ layer violates minimum spacing constraint" % [info, layer-name]))
      if width < width-check(constraints):
        issue-error(Exception("%_: %_ layer violates minimum size contraint" % [info, layer-name]))
    end-if-errors(error-buffer())

; Validate that the silkscreen does not violate contraints  
defn check-silkscreen! (constraints:LandpatternConstraints, shapes:Seqable<Shape>):
  val [_, min-width] = min-space-min-trace(shapes)
  within collect-errors():
    if min-width < min-silk-width(constraints):
      issue-error(Exception("Silkscreen layers violate minimum width constraints"))
    for text in filter({_ is Text}, shapes) do:
      if size(text as Text) < min-silk-text-height(constraints):
        issue-error(Exception("Text on silkscreen violates minimum text height contraint"))
    end-if-errors(error-buffer())

defn check-pads-against-silkscreen! (
  constraints:LandpatternConstraints,
  silk-shapes:Seqable<Shape>,
  pad-args:PadArgs
  info:String
):
  val silk = to-tuple(silk-shapes)
  val pads = to-tuple(pad-args)
  
  within collect-errors():
    val ops = [
      [copper, min-silk-copper-space, "Copper"]
      [solder-mask, min-silk-mask-space, "Solder mask"]
      [seq?{{One(_0), when _0 is-not False else None()}, seq(hole,_0)}, min-silk-cutout-space "Cutout"]
    ]
    for op in ops do: 
      val [method, min, name] = op
      val shapes = cat-all([silk-shapes, method(pad-args)])
      val [space, width] = min-space-min-trace(shapes)
      if space < min(constraints):
        issue-error(Exception("%_: %_ violates minimum silkscreen spacing" % [info, name] ))
    end-if-errors(error-buffer())

; TODO implement in terms of check-pads!
public pcb-check check-pads (landpattern:JITXObject):
  false

; TODO implement in terms of check-silkscreen!
public pcb-check check-silkscreen (landpattern:JITXObject):
  false

; TODO implement in terms of check-pads-against-silkscreen
public pcb-check check-pads-against-silkscreen (landpattern:JITXObject):
  false

;==================================================================================================
; Land Patterns
;==================================================================================================
defn draw-pin-1-marker (constraints:LandpatternConstraints, pin-1-position: Pose):
  inside pcb-landpattern:
    ; TODO
    fatal("unimplemented")

defn draw-reference-designator ():
  inside pcb-landpattern:
    layer(Silkscreen("values", Top)) = Text(">Ref", 0.7056, C, loc(0.0, 0.0))


pcb-landpattern generate-landpattern (
  constraints:LandPatternConstraints,
  pads:Seqable<[PadArg, Pose]>,
  silkscreen:Seqable<[Shape, String]>,
  cutouts:Seqable<Shape>
): 
  for (pad-data in pads, idx in 0 to false) do:
    val [args, pose] = pad-data
    pad p[idx]: to-pad(args) at pose
  
  for silk-data in silkscreen do:
    val [shape, name] = silk-data
    layer(Silkscreen(Top, name)) = shape
  
  for cutout in cutouts do:
    layer(Cutout(Top)) = shape

; 
; from IPC-SM-782 spec
; Z - width between outer pad edges
; G - width between inner pad edges
; X - pad height
; w, h - width and height of courtyard in mm
; public defn make-two-pin-landpattern (Z:Double, G:Double, X:Double, w:Double, h:Double, courtyard?:True|False, polarized?:True|False) :
;   inside pcb-landpattern :
;     val Y = (Z - G) / 2.0 ; width of pad
;     val C2 = (G + Y) / 2.0 ; distance between pad center and package centerline
;     if polarized? :
;       pad c : smd-pad(Y,X) at loc((- C2), 0.0)
;       pad a : smd-pad(Y,X) at loc(C2, 0.0)
;       val he = h / 2.0 + 0.25
;       val we = w / 2.0 + 0.3
;       layer(Silkscreen("pol", Top)) = Line(0.12, [Point(w / 2.0, (- he)) Point((- we), (- he))])
;       layer(Silkscreen("pol", Top)) = Line(0.12, [Point((- we), he) Point(w / 2.0, he) ])
;       layer(Silkscreen("pol", Top)) = Line(0.30, [Point((- we), (- he)) Point((- we), he)])
;     else:
;       pad p[1] : smd-pad(Y,X) at loc((- C2), 0.0)
;       pad p[2] : smd-pad(Y,X) at loc(C2, 0.0)
;     if courtyard? : 
;       layer(Courtyard(Top)) = Rectangle(w, h)
; example 
; pcb-landpattern two-pin-landpattern (
;   outer-width: Double
;   inner-width: Double
;   pad-height:  Double
;   polarized?:  True|False
; ):
;   val pad-width = 0.5 * (outer-width - inner-width)
;   val pad-shape = Rectangle(pad-width, pad-height)
;   val x = (inner-width + pad-width) * 0.5
  
;   ; Create a pad from a shape, the second argument is the scale of the
;   ; solder mask (in this case, 90% of the size of the copper pad)
;   val pad_ = pad-from-copper(pad-shape, ScaleFactor(0.9, true))
;   if polarized?:
;     pad anode:   pad_ at loc(- x, 0.0)
;     pad cathode: pad_ at loc(x, 0.0)
;   else: 
;     pad p[1]: pad_ at loc(- x, 0.0)
;     pad p[2]: pad_ at loc(x, 0.0)
  
;   ; Create the courtyard by scaling a rectangle, in this case by 0.1mm.
;   layer(Courtyard(Top)) = scale(Rectangle(outer-width, pad-height), ScaleFactor(0.1))
