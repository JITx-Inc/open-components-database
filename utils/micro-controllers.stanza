#use-added-syntax(jitx)
defpackage ocdb/micro-controllers :
  import core
  import collections
  import json
  import lang-utils

  import jitx
  import jitx/commands
  import jitx/param-sets
  import jitx/params
  import jitx/param-manager
  import jitx/errors
  import ocdb/land-patterns
  import ocdb/design-vars
  import ocdb/property-structs
  import ocdb/box-symbol
  import ocdb/db-parts

  import ocdb/stm
  import ocdb/stm-to-jitx
  import ocdb/st-microelectronics/landpatterns


;============================================================
;======================== Accessor ==========================
;============================================================

public defn micro-controller (params:Tuple<KeyValue>) -> (Tuple<KeyValue<Symbol,?>> -> Instantiable) :
  val mcu = MicroController(params)
  val component = to-jitx(mcu)
  mcu-module(component)

;============================================================
;===================== Micro Controller =====================
;============================================================

public defstruct MicroController <: Component :
  ; Generic properties
  manufacturer: String
  mpn: String
  trust: String
  x: Double with: (as-method => true)
  y: Double with: (as-method => true)
  z: Double|False
  mounting: String
  rated-temperature: MinMaxRange|False
  ; Specific properties
  core: String
  core-architecture: String
  data-width: Int
  flash: Double
  frequency: Double
  io: Int
  line: String
  mfg-package: String
  ram: Double
  series: String
  supply-voltage: MinMaxRange
  price: Double|False
  sellers: Tuple<Tuple<KeyValue<String, ?>>>|False
  pin-properties: STMPinProperties
  bundles: Tuple<STMBundle>
  supports: Tuple<STMSupports>


public defn MicroController (json: JObject) -> MicroController :
  val [x, y, z] = parse-dimensions(json["dimensions"] as JObject)

  MicroController(json["manufacturer"] as String,
                  json["mpn"] as String,
                  json["trust"] as String,
                  x,
                  y,
                  z,
                  json["mounting"] as String,
                  parse-rated-temperature(json),
                  json["core"] as String,
                  json["core-architecture"] as String,
                  to-int(json["data-width"] as Double),
                  json["flash"] as Double,
                  json["frequency"] as Double,
                  to-int(json["io"] as Double),
                  json["line"] as String,
                  json["mfg-package"] as String,
                  json["ram"] as Double,
                  json["series"] as String
                  parse-supply-voltage(json),
                  optional-double(json, "resolved_price"),
                  parse-sellers(json),
                  create-pin-properties(json),
                  create-bundles(json),
                  create-supports(json))

public defn MicroController (user-properties:Tuple<KeyValue>) -> MicroController :
  MicroController(user-properties, [])

public defn MicroController (user-properties:Tuple<KeyValue>, exist:Tuple<String>) -> MicroController :
  MicroController(user-properties, exist, OPTIMIZE-FOR, OPERATING-TEMPERATURE)

public defn MicroController (user-properties:Tuple<KeyValue>, exist:Tuple<String>, sort:Tuple<String>, operating-temperature:[Double, Double]|False) -> MicroController :
  val params = jitx-params()
  val vendors = bom-vendors(params)

  val optional-properties =
    generate<KeyValue<String, ?>> :
      ; Octopart parameters: if they exist, octopart will be queried
      yield("_stock" => DESIGN-QUANTITY) when DESIGN-QUANTITY > 0
      yield("_sellers" => vendors) when call?<Tuple>({not empty?(_)}, vendors)
      ; Other design parameters
      yield("_sort" => sort) when not empty?(sort)
      yield("_exist" => exist) when not empty?(exist)
      match(operating-temperature:[Double, Double]):
        yield("max-rated-temperature.min" => operating-temperature[0])
        yield("min-rated-temperature.max" => operating-temperature[1])

  ; `user-properties` override default properties
  val query-properties = to-tuple $ hashtable-union<String, ?> $ [["category" => "microcontroller"],
                                                                  optional-properties,
                                                                  user-properties]
  ; - If _stock or _sellers key exist, then we use limit 1000 so that all STM mcus are queried from the mongo database,
  ; then we query the sourcing data for each, filter on stock / sellers constraints and
  ; finally we sort again if OPTIMIZE_FOR[0] is "price" or "cost".
  ; - If we don't need to filter on sourcing data, we can just query 1 mcu from the mongo database and return it
  ; (will not optimize on price if asked for in this case)
  val limit =
    if contains?(query-properties, "_stock") or contains?(query-properties, "_sellers") : 1000
    else : 1
  val jobjects = dbquery(query-properties, limit) as Tuple<JObject>
  ; We only keep the first mcu amongst the list returned by the jitx server.
  throw(NoComponentMeetingRequirements(query-properties)) when empty?(jobjects)
  MicroController(jobjects[0])

; FIXME: add to collections.stanza with hashset-union used in query.stanza ?
; Behaviour: to-tuple $ hashtable-union $ [["category" => "microcontroller"], ["c" => 2], ["category" => "qwerty"]] -> ["c" => 2 "category" => "qwerty"]
public defn hashtable-union<K, V> (hs:Seqable<Seqable<KeyValue<K&Equalable&Hashable, V>>>) -> HashTable<K, V> :
  to-hashtable<K, V>(cat-all(hs))

;============================================================
;======================= MCU to JITX ========================
;============================================================
pcb-component mcu-component (manufacturer:String, mpn:String, pp:STMPinProperties, supports:Tuple<STMSupports>, bundles:Tuple<STMBundle>, pkg:String) :
  manufacturer = manufacturer
  mpn = mpn
  val mappings = to-jitx-pin-properties(pp)
  val bundle-table = to-jitx-bundles(bundles)
  to-jitx-supports(supports, bundle-table, mappings)
  val lp = find({name(_) == pkg}, STM32-LAND-PATTERNS)
  throw(Exception("%_ is not a supported package." % [pkg])) when lp is False
  assign-landpattern(lp as LandPattern)
  make-box-symbol()

public defmethod to-jitx (m:MicroController) : 
  mcu-component(manufacturer(m), mpn(m), pin-properties(m), supports(m), bundles(m), mfg-package(m))

;============================================================
;====================== Printer =============================
;============================================================

defmethod print (o:OutputStream, r:MicroController) :
  val items = [
    "mpn = %_" % [mpn(r)]
    "trust = %_" % [trust(r)]
    "(x, y, z) = (%,)" % [[x(r), y(r), z(r)]]
    "mounting = %_" % [mounting(r)]
    "rated-temperature = %_" % [rated-temperature(r)]
    "core = %_" % [core(r)]
    "core-architecture = %_" % [core-architecture(r)]
    "data-width = %_" % [data-width(r)]
    "flash = %_" % [flash(r)]
    "frequency = %_" % [frequency(r)]
    "io = %_" % [io(r)]
    "line = %_" % [line(r)]
    "mfg-package = %_" % [mfg-package(r)]
    "ram = %_" % [ram(r)]
    "series = %_" % [series(r)]
    "supply-voltage = %_" % [supply-voltage(r)]
    "price = %_" % [price(r)]
    "sellers = %_" % [sellers(r)]
    "pin-properties = %_" % [pin-properties(r)]
    "bundles = %_" % [bundles(r)]
    "supports = %_" % [supports(r)]]
  print(o, "MicroController(%_)" % [indented-list(items)])

;============================================================
;=================== Parsing utils ==========================
;============================================================

defn parse-supply-voltage (json: JObject) -> MinMaxRange :
  val supply-voltage-json = json["rated-temperature"] as JObject
  MinMaxRange(supply-voltage-json["min"] as Double, supply-voltage-json["max"] as Double)

defn parse-sellers (json: JObject) -> Tuple<Tuple<KeyValue<String, ?>>>|False:
  val sellers = get?(json, "sellers")
  if not sellers is False :
    val cast-sellers = sellers as Tuple<JObject>
    map(entries, cast-sellers)
