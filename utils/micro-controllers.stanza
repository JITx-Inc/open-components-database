#use-added-syntax(jitx)
defpackage ocdb/micro-controllers :
  import core
  import collections
  import json
  import jitx
  import jitx/commands
  import jitx/param-sets
  import jitx/params
  import jitx/param-manager
  import jitx/errors
  import ocdb/land-patterns
  import ocdb/design-vars
  import ocdb/property-structs
  import ocdb/box-symbol
  import ocdb/db-parts

  import ocdb/stm
  import ocdb/stm-to-jitx
  import ocdb/st-microelectronics/landpatterns


;============================================================
;======================== Accessor ==========================
;============================================================

public defn micro-controller (params:Tuple<KeyValue>) -> (Tuple<KeyValue<Symbol,?>> -> Instantiable) :
  val mcu = MicroController(params)
  val component = to-jitx(mcu)
  mcu-module(component)

;============================================================
;===================== Micro Controller =====================
;============================================================

public defstruct MicroController <: Component :
  ; Generic properties
  manufacturer: String
  mpn: String
  trust: String
  x: Double with: (as-method => true)
  y: Double with: (as-method => true)
  z: Double|False
  mounting: String
  rated-temperature: MinMaxRange|False
  ; Specific properties
  core: String
  core-architecture: String
  data-width: Int
  flash: Double
  frequency: Double
  io: Int
  line: String
  mfg-package: String
  ram: Double
  series: String
  supply-voltage: MinMaxRange
  price: Double|False
  sellers: Tuple<Tuple<KeyValue<String, ?>>>|False
  pin-properties: STMPinProperties
  bundles: Tuple<STMBundle>
  supports: Tuple<STMSupports>


public defn MicroController (json: JObject) -> MicroController :
  val [x, y, z] = parse-dimensions(json["dimensions"] as JObject)

  MicroController(json["manufacturer"] as String,
                  json["mpn"] as String,
                  json["trust"] as String,
                  x,
                  y,
                  z,
                  json["mounting"] as String,
                  parse-rated-temperature(json),
                  json["core"] as String,
                  json["core-architecture"] as String,
                  to-int(json["data-width"] as Double),
                  json["flash"] as Double,
                  json["frequency"] as Double,
                  to-int(json["io"] as Double),
                  json["line"] as String,
                  json["mfg-package"] as String,
                  json["ram"] as Double,
                  json["series"] as String
                  parse-supply-voltage(json),
                  optional-double(json, "resolved_price"),
                  parse-sellers(json),
                  create-pin-properties(json),
                  create-bundles(json),
                  create-supports(json))

public defn MicroController (properties:Tuple<KeyValue>) -> MicroController :
  MicroController(properties, [])

public defn MicroController (properties:Tuple<KeyValue>, exist:Tuple<String>) -> MicroController :
  MicroController(properties, exist, OPTIMIZE-FOR, ["max-rated-temperature.min" => OPERATING-TEMPERATURE[0],
                                                    "min-rated-temperature.max" => OPERATING-TEMPERATURE[1]])

public defn MicroController (properties:Tuple<KeyValue>, exist:Tuple<String>, sort:Tuple<String>, temperature-properties:Tuple<KeyValue>) -> MicroController :
  val params = jitx-params()
  val vendors = bom-vendors(params)

  var query-properties = []
  if DESIGN-QUANTITY == 0:
    query-properties = to-tuple $ cat-all([["category" => "microcontroller",
                                                "_sort" => sort,
                                                "_exist" => exist],
                                              temperature-properties,
                                              properties])
  else :
    query-properties = to-tuple $ cat-all([["category" => "microcontroller",
                                            "_sort" => sort,
                                            "_exist" => exist,
                                            ],
                                          temperature-properties,
                                          properties])
  val jsons = dbquery-all(query-properties) as Tuple<JObject>
  if length(jsons) == 0 :
    throw(NoComponentMeetingRequirements(query-properties))
  else :
    MicroController(jsons[0])

;============================================================
;======================= MCU to JITX ========================
;============================================================
pcb-component mcu-component (manufacturer:String, mpn:String, pp:STMPinProperties, supports:Tuple<STMSupports>, bundles:Tuple<STMBundle>, pkg:String) :
  manufacturer = manufacturer
  mpn = mpn
  val mappings = to-jitx-pin-properties(pp)
  val bundle-table = to-jitx-bundles(bundles)
  to-jitx-supports(supports, bundle-table, mappings)
  val lp = find({name(_) == pkg}, STM32-LAND-PATTERNS)
  throw(Exception("%_ is not a supported package." % [pkg])) when lp is False
  assign-landpattern(lp as LandPattern)
  make-box-symbol()

public defmethod to-jitx (m:MicroController) : 
  mcu-component(manufacturer(m), mpn(m), pin-properties(m), supports(m), bundles(m), mfg-package(m))

;============================================================
;====================== Printer =============================
;============================================================

defmethod print (o:OutputStream, r:MicroController) :
  val items = [
    "mpn = %_" % [mpn(r)]
    "trust = %_" % [trust(r)]
    "(x, y, z) = (%,)" % [[x(r), y(r), z(r)]]
    "mounting = %_" % [mounting(r)]
    "rated-temperature = %_" % [rated-temperature(r)]
    "core = %_" % [core(r)]
    "core-architecture = %_" % [core-architecture(r)]
    "data-width = %_" % [data-width(r)]
    "flash = %_" % [flash(r)]
    "frequency = %_" % [frequency(r)]
    "io = %_" % [io(r)]
    "line = %_" % [line(r)]
    "mfg-package = %_" % [mfg-package(r)]
    "ram = %_" % [ram(r)]
    "series = %_" % [series(r)]
    "supply-voltage = %_" % [supply-voltage(r)]
    "price = %_" % [price(r)]
    "sellers = %_" % [sellers(r)]
    "pin-properties = %_" % [pin-properties(r)]
    "bundles = %_" % [bundles(r)]
    "supports = %_" % [supports(r)]]
  print(o, "MicroController(%_)" % [indented-list(items)])

;============================================================
;=================== Parsing utils ==========================
;============================================================

defn parse-supply-voltage (json: JObject) -> MinMaxRange :
  val supply-voltage-json = json["rated-temperature"] as JObject
  MinMaxRange(supply-voltage-json["min"] as Double, supply-voltage-json["max"] as Double)

defn parse-sellers (json: JObject) -> Tuple<Tuple<KeyValue<String, ?>>>|False:
  val sellers = get?(json, "sellers")
  if not sellers is False :
    val cast-sellers = sellers as Tuple<JObject>
    map(entries, cast-sellers)
