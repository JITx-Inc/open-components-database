#use-added-syntax(jitx)
defpackage ocdb/micro-controllers :
  import core
  import collections
  import json
  import jitx
  import jitx/commands
  import jitx/param-sets
  import jitx/params
  import jitx/param-manager
  import jitx/errors

  import ocdb/land-patterns
  import ocdb/design-vars
  import ocdb/property-structs
  import ocdb/box-symbol
  import ocdb/db-parts

  import ocdb/stm
  import ocdb/stm-to-jitx
  import ocdb/st-microelectronics/landpatterns


;============================================================
;======================== Accessor ==========================
;============================================================

public defn micro-controller (params:Tuple<KeyValue>) -> (Tuple<KeyValue<Symbol,?>> -> Instantiable) :
  val mcu = MicroController(params)
  val component = to-jitx(mcu)
  mcu-module(component)

;============================================================
;===================== Micro Controller =====================
;============================================================

public defstruct MicroController <: Component :
  ; Generic properties
  manufacturer: String
  mpn: String
  trust: String
  x: Double with: (as-method => true)
  y: Double with: (as-method => true)
  z: Double|False
  mounting: String
  rated-temperature: MinMaxRange|False
  ; Specific properties
  core: String
  core-architecture: String
  data-width: Int
  flash: Double
  frequency: Double
  io: Int
  line: String
  mfg-package: String
  ram: Double
  series: String
  supply-voltage: MinMaxRange
  price: Double|False
  sellers: Tuple<Tuple<KeyValue<String, ?>>>|False
  pin-properties: STMPinProperties
  bundles: Tuple<STMBundle>
  supports: Tuple<STMSupports>

defn int (json: JSON) -> Int:
  to-int(json as Double)

public defn MicroController (json: JObject) -> MicroController :
  val [x, y, z] = parse-dimensions(json["dimensions"] as JObject)

  MicroController(json["manufacturer"] as String,
                  json["mpn"] as String,
                  json["trust"] as String,
                  x,
                  y,
                  z,
                  json["mounting"] as String,
                  parse-rated-temperature(json),
                  json["core"] as String,
                  json["core-architecture"] as String,
                  int(json["data-width"]),
                  json["flash"] as Double,
                  json["frequency"] as Double,
                  int(json["io"]),
                  json["line"] as String,
                  json["mfg-package"] as String,
                  json["ram"] as Double,
                  json["series"] as String
                  parse-supply-voltage(json),
                  optional-double(json, "resolved_price"),
                  parse-sellers(json),
                  create-pin-properties(json),
                  create-bundles(json),
                  create-supports(json))

public defn MicroController (properties:Tuple<KeyValue>) -> MicroController :
  MicroController(properties, [])

public defn MicroController (properties:Tuple<KeyValue>, exist:Tuple<String>) -> MicroController :
  MicroController(properties, exist, OPTIMIZE-FOR, OPERATING-TEMPERATURE)

public defn MicroController (properties:Tuple<KeyValue>, exist:Tuple<String>, sort:Tuple<String>, operating-temperature:[Double, Double]|False) -> MicroController :
  val params = jitx-params()
  val vendors = bom-vendors(params)

  val octopart-parameters = Vector<KeyValue<String, ?>>()
  if DESIGN-QUANTITY > 0 :
    add(octopart-parameters, "_stock" => DESIGN-QUANTITY)
  match(vendors: Tuple<String>) :
    if length(vendors) != 0 :
      add(octopart-parameters, "_sellers" => vendors)

  val design-parameters = Vector<KeyValue<String, ?>>()
  if not empty?(sort) :
    add(design-parameters, "_sort" => sort)
  if not empty?(exist) :
    add(design-parameters, "_exist" => exist)
  match(operating-temperature: [Double, Double]) :
    add-all(design-parameters, ["max-rated-temperature.min" => operating-temperature[0],
                                "min-rated-temperature.max" => operating-temperature[1]])


  val query-properties = to-tuple $ cat-all([["category" => "microcontroller"],
                                             octopart-parameters,
                                             design-parameters,
                                             properties])

  val jsons = dbquery-all(query-properties) as Tuple<JObject>
  if length(jsons) == 0 :
    throw(NoComponentMeetingRequirements(query-properties))
  else :
    MicroController(jsons[0])

;============================================================
;======================= MCU to JITX ========================
;============================================================

defmethod to-jitx (mcu: MicroController) -> Instantiable :
  pcb-component my-microcontroller :
    manufacturer = manufacturer(mcu)
    mpn = mpn(mcu)

    to-jitx-pin-properties(pin-properties(mcu))
    val bundle-table = to-jitx-bundles(bundles(mcu))
    to-jitx-supports(supports(mcu), bundle-table)

    assign-landpattern $
      switch(mfg-package(mcu)) :
        ; "SO8N" : SO8N
        ; "TSSOP14" : TSSOP14
        ; "TSSOP20" : TSSOP20
        "LQFP100" : LQFP100
        "LQFP128" : LQFP128
        "LQFP144" : LQFP144
        "LQFP176" : LQFP176
        "LQFP208" : LQFP208
        ; "LQFP32" : LQFP32
        "LQFP48" : LQFP48
        ; "LQFP64" : LQFP64
        ; "LQFP80" : LQFP80
        ; "UFQFPN20" : UFQFPN20
        "UFQFPN28" : UFQFPN28
        "UFQFPN32" : UFQFPN32
        "UFQFPN48" : UFQFPN48
        ; "VFQFPN36" : VFQFPN36
        ; "VFQFPN68" : VFQFPN68
        "LFBGA100" : LFBGA100
        "LFBGA144" : LFBGA144
        "LFBGA354" : LFBGA354
        ; "LFBGA448" : LFBGA448
        ; "LGA86" : LGA86
        "TFBGA100" : TFBGA100
        "TFBGA216" : TFBGA216
        "TFBGA225" : TFBGA225
        ; "TFBGA240" : TFBGA240
        ; "TFBGA257" : TFBGA257
        ; "TFBGA361" : TFBGA361
        "TFBGA64" : TFBGA64
        "UFBGA100" : UFBGA100
        "UFBGA121" : UFBGA121
        "UFBGA129" : UFBGA129
        "UFBGA132" : UFBGA132
        "UFBGA144" : UFBGA144
        "UFBGA169" : UFBGA169
        ; "UFBGA176" : UFBGA176
        "UFBGA64" : UFBGA64
        "UFBGA73" : UFBGA73
        ; "EWLCSP49" : EWLCSP49
        ; "EWLCSP66" : EWLCSP66
        "WLCSP100" : WLCSP100
        "WLCSP104" : WLCSP104
        "WLCSP115" : WLCSP115
        "WLCSP132" : WLCSP132
        "WLCSP143" : WLCSP143
        "WLCSP144" : WLCSP144
        "WLCSP156" : WLCSP156
        "WLCSP168" : WLCSP168
        "WLCSP18" : WLCSP18
        "WLCSP180" : WLCSP180
        "WLCSP20" : WLCSP20
        "WLCSP25" : WLCSP25
        "WLCSP36" : WLCSP36
        "WLCSP49" : WLCSP49
        "WLCSP52" : WLCSP52
        ; "WLCSP59" : WLCSP59
        "WLCSP63" : WLCSP63
        "WLCSP64" : WLCSP64
        "WLCSP66" : WLCSP66
        "WLCSP72" : WLCSP72
        "WLCSP81" : WLCSP81
        "WLCSP90" : WLCSP90
        else :
          fatal("MCU package %_ is not supported." % [mfg-package(mcu)])
    make-box-symbol()

  my-microcontroller


;============================================================
;====================== Printer =============================
;============================================================

defmethod print (o:OutputStream, r:MicroController) :
  val items = [
    "mpn = %_" % [mpn(r)]
    "trust = %_" % [trust(r)]
    "(x, y, z) = (%,)" % [[x(r), y(r), z(r)]]
    "mounting = %_" % [mounting(r)]
    "rated-temperature = %_" % [rated-temperature(r)]
    "core = %_" % [core(r)]
    "core-architecture = %_" % [core-architecture(r)]
    "data-width = %_" % [data-width(r)]
    "flash = %_" % [flash(r)]
    "frequency = %_" % [frequency(r)]
    "io = %_" % [io(r)]
    "line = %_" % [line(r)]
    "mfg-package = %_" % [mfg-package(r)]
    "ram = %_" % [ram(r)]
    "series = %_" % [series(r)]
    "supply-voltage = %_" % [supply-voltage(r)]
    "price = %_" % [price(r)]
    "sellers = %_" % [sellers(r)]
    "pin-properties = %_" % [pin-properties(r)]
    "bundles = %_" % [bundles(r)]
    "supports = %_" % [supports(r)]]
  print(o, "MicroController(%_)" % [indented-list(items)])

;============================================================
;=================== Parsing utils ==========================
;============================================================

defn parse-supply-voltage (json: JObject) -> MinMaxRange :
  val supply-voltage-json = json["rated-temperature"] as JObject
  MinMaxRange(supply-voltage-json["min"] as Double, supply-voltage-json["max"] as Double)

defn parse-sellers (json: JObject) -> Tuple<Tuple<KeyValue<String, ?>>>|False:
  val sellers = get?(json, "sellers")
  if not sellers is False :
    val cast-sellers = sellers as Tuple<JObject>
    map(entries, cast-sellers)
