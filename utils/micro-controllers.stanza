#use-added-syntax(jitx)
defpackage ocdb/micro-controllers :
  import core
  import collections
  import json
  import lang-utils

  import jitx
  import jitx/commands
  import jitx/param-sets
  import jitx/params
  import jitx/param-manager
  import jitx/errors
  import ocdb/land-patterns
  import ocdb/design-vars
  import ocdb/property-structs
  import ocdb/box-symbol
  import ocdb/db-parts

  import ocdb/stm
  import ocdb/stm-to-jitx
  import ocdb/stm-to-jitx-code
  import ocdb/st-microelectronics/landpatterns

  import ocdb/code-generator


;============================================================
;======================== Accessor ==========================
;============================================================

public defn micro-controller (params:Tuple<KeyValue>) -> (Tuple<KeyValue<Symbol,?>> -> Instantiable) :
  ;Build the microcontroller struct from query parameters.
  val mcu = MicroController(params)

  ;Generate the microcontroller component and evaluate.
  val component = to-jitx(mcu)

  ;Enclose the component in a module to connect various pins such as
  ; reset, power, and boot.
  val module = mcu-module(component)

  ;Use a CodeGenerator to write the part's JITX representation.
  val cg = CodeGenerator()
  to-jitx-code(mcu, cg)
  write-mcu-module(cg)

  ;Save the generated part to the design directory.
  val part-file = to-string("%_.stanza" % [mpn?(component)])
  save-generated-file(part-file, generated-code(cg))

  ;Return the module, which can be parameterized by user options.
  module

;============================================================
;===================== Micro Controller =====================
;============================================================

public defstruct MicroController <: Component :
  ; Generic properties
  manufacturer: String
  mpn: String
  trust: String
  x: Double with: (as-method => true)
  y: Double with: (as-method => true)
  z: Double|False
  mounting: String
  rated-temperature: MinMaxRange|False
  ; Specific properties
  core: String
  core-architecture: String
  data-width: Int
  flash: Double
  frequency: Double
  io: Int
  line: String
  mfg-package: String
  ram: Double
  series: String
  supply-voltage: MinMaxRange
  price: Double|False
  sellers: Tuple<Tuple<KeyValue<String, ?>>>|False
  pin-properties: STMPinProperties
  bundles: Tuple<STMBundle>
  supports: Tuple<STMSupports>


public defn MicroController (json: JObject) -> MicroController :
  val [x, y, z] = parse-dimensions(json["dimensions"] as JObject)

  MicroController(json["manufacturer"] as String,
                  json["mpn"] as String,
                  json["trust"] as String,
                  x,
                  y,
                  z,
                  json["mounting"] as String,
                  parse-rated-temperature(json),
                  json["core"] as String,
                  json["core-architecture"] as String,
                  to-int(json["data-width"] as Double),
                  json["flash"] as Double,
                  json["frequency"] as Double,
                  to-int(json["io"] as Double),
                  json["line"] as String,
                  json["mfg-package"] as String,
                  json["ram"] as Double,
                  json["series"] as String
                  parse-supply-voltage(json),
                  optional-double(json, "resolved_price"),
                  parse-sellers(json),
                  create-pin-properties(json),
                  create-bundles(json),
                  create-supports(json))

public defn MicroController (user-properties:Tuple<KeyValue>) -> MicroController :
  MicroController(user-properties, [])

public defn MicroController (user-properties:Tuple<KeyValue>, exist:Tuple<String>) -> MicroController :
  MicroController(user-properties, exist, OPTIMIZE-FOR, OPERATING-TEMPERATURE)

public defn MicroController (user-properties:Tuple<KeyValue>, exist:Tuple<String>, sort:Tuple<String>, operating-temperature:[Double, Double]|False) -> MicroController :
  val params = jitx-params()
  val vendors = bom-vendors(params)

  val optional-properties =
    generate<KeyValue<String, ?>> :
      ; Octopart parameters: if they exist, octopart will be queried
      ;[FIXME]: uncomment when octopart quota issue is resolved
      ;yield("_stock" => DESIGN-QUANTITY) when DESIGN-QUANTITY > 0
      ;yield("_sellers" => vendors) when call?<Tuple>({not empty?(_)}, vendors)
      ; Other design parameters
      yield("_sort" => sort) when not empty?(sort)
      yield("_exist" => exist) when not empty?(exist)
      match(operating-temperature:[Double, Double]):
        yield("max-rated-temperature.min" => operating-temperature[0])
        yield("min-rated-temperature.max" => operating-temperature[1])

  ; `user-properties` override default properties
  val query-properties = to-tuple $ hashtable-union<String, ?> $ [["category" => "microcontroller"],
                                                                  optional-properties,
                                                                  user-properties]

  val jobjects = dbquery-all(query-properties) as Tuple<JObject>
  throw(NoComponentMeetingRequirements(query-properties)) when empty?(jobjects)
  MicroController(jobjects[0])

; FIXME: add to collections.stanza with hashset-union used in query.stanza ?
; Behaviour: to-tuple $ hashtable-union $ [["category" => "microcontroller"], ["c" => 2], ["category" => "qwerty"]] -> ["c" => 2 "category" => "qwerty"]
public defn hashtable-union<K, V> (hs:Seqable<Seqable<KeyValue<K&Equalable&Hashable, V>>>) -> HashTable<K, V> :
  to-hashtable<K, V>(cat-all(hs))

;============================================================
;======================= MCU to JITX ========================
;============================================================
pcb-component mcu-component (manufacturer:String,
                             mpn:String,
                             pp:STMPinProperties,
                             supports:Tuple<STMSupports>,
                             bundles:Tuple<STMBundle>,
                             pkg:String) :
  ;Manufacturer and MPN statements.
  manufacturer = manufacturer
  mpn = mpn

  ;Pin properties, bundles, and support statements.
  val mappings = to-jitx-pin-properties(pp)
  val bundle-table = to-jitx-bundles(bundles)
  to-jitx-supports(supports, bundle-table, mappings)

  ;Find STM Land Pattern with the given name.
  val lp = find({name(_) == pkg}, STM32-LAND-PATTERNS)
  throw(Exception("%_ is not a supported package." % [pkg])) when lp is False

  ;Connect a Land Pattern and Symbol to this MCU component.
  assign-landpattern(lp as LandPattern)
  make-box-symbol()

public defmethod to-jitx (m:MicroController) : 
  mcu-component(manufacturer(m), mpn(m), pin-properties(m), supports(m), bundles(m), mfg-package(m))

;============================================================
;===================== MCU to JITX Code =====================
;============================================================

defn mcu-component-code (manufacturer:String,
                         mpn:String,
                         pp:STMPinProperties,
                         supports:Tuple<STMSupports>,
                         bundles:Tuple<STMBundle>,
                         pkg:String,
                         cg:CodeGenerator) :
  ;Generate code for the generated microcontroller.
  write-added-syntaxes(cg, [JITX])
  write-package(cg, string-join([manufacturer mpn], "/"))
  write-package-imports(cg, STM)
  write-component(cg, "component")
  write-manufacturer(cg, manufacturer)
  write-mpn(cg, mpn)
  val mappings = to-jitx-pin-properties(pp, cg)
  val bundle-table = to-jitx-bundles(bundles, cg)
  to-jitx-supports(supports, bundle-table, mappings, cg)
  write-assign-landpattern(cg, pkg)
  write-make-box-symbol(cg)

public defn to-jitx-code (m:MicroController, cg:CodeGenerator) :
  mcu-component-code(manufacturer(m), mpn(m), pin-properties(m), supports(m), bundles(m), mfg-package(m), cg)

;============================================================
;====================== Printer =============================
;============================================================

defmethod print (o:OutputStream, r:MicroController) :
  val items = [
    "mpn = %_" % [mpn(r)]
    "trust = %_" % [trust(r)]
    "(x, y, z) = (%,)" % [[x(r), y(r), z(r)]]
    "mounting = %_" % [mounting(r)]
    "rated-temperature = %_" % [rated-temperature(r)]
    "core = %_" % [core(r)]
    "core-architecture = %_" % [core-architecture(r)]
    "data-width = %_" % [data-width(r)]
    "flash = %_" % [flash(r)]
    "frequency = %_" % [frequency(r)]
    "io = %_" % [io(r)]
    "line = %_" % [line(r)]
    "mfg-package = %_" % [mfg-package(r)]
    "ram = %_" % [ram(r)]
    "series = %_" % [series(r)]
    "supply-voltage = %_" % [supply-voltage(r)]
    "price = %_" % [price(r)]
    "sellers = %_" % [sellers(r)]
    "pin-properties = %_" % [pin-properties(r)]
    "bundles = %_" % [bundles(r)]
    "supports = %_" % [supports(r)]]
  print(o, "MicroController(%_)" % [indented-list(items)])

;============================================================
;=================== Parsing utils ==========================
;============================================================

defn parse-supply-voltage (json: JObject) -> MinMaxRange :
  val supply-voltage-json = json["rated-temperature"] as JObject
  MinMaxRange(supply-voltage-json["min"] as Double, supply-voltage-json["max"] as Double)

defn parse-sellers (json: JObject) -> Tuple<Tuple<KeyValue<String, ?>>>|False:
  val sellers = get?(json, "sellers")
  if not sellers is False :
    val cast-sellers = sellers as Tuple<JObject>
    map(entries, cast-sellers)
