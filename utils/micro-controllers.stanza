#use-added-syntax(jitx)
defpackage ocdb/micro-controllers :
  import core
  import collections
  import json

  import jitx
  import jitx/commands
  import jitx/errors
  import ocdb/land-patterns
  import ocdb/design-vars
  import ocdb/property-structs
  import ocdb/box-symbol
  import ocdb/db-parts

  import ocdb/stm
  import ocdb/stm-to-jitx
  import ocdb/st-microelectronics/landpatterns


;============================================================
;======================== Accessor ==========================
;============================================================

public defn micro-controller (params:Tuple<KeyValue>) -> (Tuple<KeyValue<Symbol,?>> -> Instantiable) :
  val mcu = MicroController(params)
  val component = to-jitx(mcu)
  mcu-module(component)

public defn look-up-micro-controllers (attribute: String) -> Tuple :
  look-up-micro-controllers(attribute, [])

public defn look-up-micro-controllers (attribute: String, filter-properties:Tuple<KeyValue>) -> Tuple :
  look-up-micro-controllers(attribute, filter-properties, [])

public defn look-up-micro-controllers (attribute: String, filter-properties:Tuple<KeyValue>, exist:Tuple<String>) -> Tuple :
  look-up-micro-controllers(attribute, filter-properties, exist, OPTIMIZE-FOR, OPERATING-TEMPERATURE)

public defn look-up-micro-controllers (attribute: String, filter-properties:Tuple<KeyValue>, exist:Tuple<String>, sort:Tuple<String>, operating-temperature:[Double, Double]|False) -> Tuple :
  val user-properties = to-tuple $ cat(filter-properties, ["_distinct" => attribute])
  val query-properties = micro-controller-query-properties(user-properties, exist, sort, operating-temperature)

  ; 1000 is the maximum number of values that the JITX server is allowed to return at once
  val values = dbquery(query-properties, 1000) as Tuple

  if length(values) == 1000 :
    print("[WARNING] `look-up-micro-controllers` returned the maximum allowed of 1000 values. ")
    println("The result does not contain all available values for:")
    println(query-properties)

  values

;============================================================
;===================== Micro Controller =====================
;============================================================

public defstruct MicroController <: Component :
  ; Generic properties
  manufacturer: String
  mpn: String
  trust: String
  x: Double with: (as-method => true)
  y: Double with: (as-method => true)
  z: Double|False
  mounting: String
  rated-temperature: MinMaxRange|False
  ; Specific properties
  core: String
  core-architecture: String
  data-width: Int
  flash: Double
  frequency: Double
  io: Int
  line: String
  mfg-package: String
  ram: Double
  series: String
  supply-voltage: MinMaxRange
  sellers: Tuple<Seller>|False with: (as-method => true)
  resolved-price: Double|False with: (as-method => true)
  pin-properties: STMPinProperties
  bundles: Tuple<STMBundle>
  supports: Tuple<STMSupports>

public defn MicroController (json: JObject) -> MicroController :
  val [x, y, z] = parse-dimensions(json["dimensions"] as JObject)

  MicroController(json["manufacturer"] as String,
                  json["mpn"] as String,
                  json["trust"] as String,
                  x,
                  y,
                  z,
                  json["mounting"] as String,
                  parse-rated-temperature(json),
                  json["core"] as String,
                  json["core-architecture"] as String,
                  to-int(json["data-width"] as Double),
                  json["flash"] as Double,
                  json["frequency"] as Double,
                  to-int(json["io"] as Double),
                  json["line"] as String,
                  json["mfg-package"] as String,
                  json["ram"] as Double,
                  json["series"] as String
                  parse-supply-voltage(json),
                  parse-sellers(json),
                  optional-double(json, "resolved_price"),
                  create-pin-properties(json),
                  create-bundles(json),
                  create-supports(json))

public defn MicroController (user-properties:Tuple<KeyValue>) -> MicroController :
  MicroController(user-properties, [])

public defn MicroController (user-properties:Tuple<KeyValue>, exist:Tuple<String>) -> MicroController :
  MicroController(user-properties, exist, OPTIMIZE-FOR, OPERATING-TEMPERATURE)

public defn MicroController (user-properties:Tuple<KeyValue>, exist:Tuple<String>, sort:Tuple<String>, operating-temperature:[Double, Double]|False) -> MicroController :
  val query-properties = micro-controller-query-properties(user-properties, exist, OPTIMIZE-FOR, OPERATING-TEMPERATURE)
  ; - If _stock or _sellers key exist, all STM mcus are queried from the mongo database in the limit of maximum 1000,
  ; then we query the sourcing data for each, filter on stock / sellers constraints and
  ; finally we sort again if OPTIMIZE_FOR[0] is "price" or "cost".
  ; - If we don't need to filter on sourcing data (includes sorting on price), we can just query 1 mcu from the mongo database and return it
  val jobject = dbquery-first(query-properties) as JObject
  MicroController(jobject)

defn micro-controller-query-properties (user-properties:Tuple<KeyValue>,
                                        exist:Tuple<String>,
                                        sort:Tuple<String>,
                                        operating-temperature:[Double, Double]|False) -> Tuple<KeyValue> :
  query-properties(user-properties,
                   exist,
                   sort,
                   operating-temperature,
                   "microcontroller",
                   true)



;============================================================
;======================= MCU to JITX ========================
;============================================================

pcb-component mcu-component (manufacturer:String,
                             mpn:String,
                             pp:STMPinProperties,
                             supports:Tuple<STMSupports>,
                             bundles:Tuple<STMBundle>,
                             pkg:String) :
  manufacturer = manufacturer
  mpn = mpn
  val mappings = to-jitx-pin-properties(pp)
  val bundle-table = to-jitx-bundles(bundles)
  to-jitx-supports(supports, bundle-table, mappings)
  val lp = find({name(_) == pkg}, STM32-LAND-PATTERNS)
  throw(Exception("%_ is not a supported package." % [pkg])) when lp is False
  assign-landpattern(lp as LandPattern)
  make-box-symbol()

public defmethod to-jitx (m:MicroController) : 
  mcu-component(manufacturer(m), mpn(m), pin-properties(m), supports(m), bundles(m), mfg-package(m))

;============================================================
;====================== Printer =============================
;============================================================

defmethod print (o:OutputStream, m:MicroController) :
    print(o, "MicroController(%_)" % [indented-list $ short-print-items(m)])

defn print-full (m:MicroController) :
  val items = cat(short-print-items(m),
                  ["pin-properties = %_" % [pin-properties(m)]
                   "bundles = %_" % [bundles(m)]
                   "supports = %_" % [supports(m)]])
  print("MicroController(%_)" % [indented-list(items)])

defn short-print-items (m: MicroController) -> Tuple<Printable> :
  val items = [
    "mpn = %_" % [mpn(m)]
    "trust = %_" % [trust(m)]
    "(x, y, z) = (%,)" % [[x(m), y(m), z(m)]]
    "mounting = %_" % [mounting(m)]
    "rated-temperature = %_" % [rated-temperature(m)]
    "core = %_" % [core(m)]
    "core-architecture = %_" % [core-architecture(m)]
    "data-width = %_" % [data-width(m)]
    "flash = %_" % [flash(m)]
    "frequency = %_" % [frequency(m)]
    "io = %_" % [io(m)]
    "line = %_" % [line(m)]
    "mfg-package = %_" % [mfg-package(m)]
    "ram = %_" % [ram(m)]
    "series = %_" % [series(m)]
    "supply-voltage = %_" % [supply-voltage(m)]]

  match(sellers(m), resolved-price(m)) :
    (s: Tuple<Seller>, p: Double) :
      to-tuple $ cat(items, ["sellers = %_" % [indented-list(s)]
                             "resolved-price = %_" % [p]])
    (s: False, p: False): items

;============================================================
;=================== Parsing utils ==========================
;============================================================

defn parse-supply-voltage (json: JObject) -> MinMaxRange :
  val supply-voltage-json = json["rated-temperature"] as JObject
  MinMaxRange(supply-voltage-json["min"] as Double, supply-voltage-json["max"] as Double)
