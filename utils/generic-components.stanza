#use-added-syntax(jitx)
defpackage ocdb/utils/generic-components:
  import core
  import collections
  import math

  import jitx
  import jitx/commands
  import jitx/errors

  import lang-utils with :
    prefix(min-max) => lang-

  import ocdb/utils/bundles
  import ocdb/utils/landpatterns
  import ocdb/utils/generator-utils
  import ocdb/utils/db-parts
  import ocdb/utils/design-vars
  import ocdb/utils/symbols
  import ocdb/utils/box-symbol
  import ocdb/utils/property-structs
  import ocdb/utils/symbol-utils
  import ocdb/utils/checks
  import ocdb/utils/parts
  import ocdb/utils/placeholder-components
  import ocdb/artwork/board-text

; ========================================================
; ====== Standard packages for the passive solver ========
; ========================================================
val PKGS = ["009005", "0301m", "01005", "0402m", "0201", "0603m", "0202", "0606m", "0204", "0510m", "Wide 0402", "0306",
           "0816m", "Wide 0603", "0402", "1005m", "0505", "1414m", "0508", "1220m", "Wide 0805", "0603", "1608m", "0612",
           "1632m", "Wide 1206", "0805", "2012m", "1111", "2828m", "1206", "3216m", "1210", "3225m", "1218", "3246m",
           "Wide 1812", "1225", "3263m", "Wide 2512", "1530", "3876m", "Wide 3015", "1808", "4520m", "1812", "4532m", "1825",
           "4564m", "1835", "4589", "Wide 3518", "5020m", "2010", "5025m", "2043", "Wide 4320", "2220", "5750m", "2225",
           "5763m", "2312", "6032m", "2512", "6331m", "2725", "7142m", "2728", "7142m", "Wide 2827", "2816", "2817", 
           "7142m", "2953", "Wide 5929", "3920", "1052m"]

public defn is-valid-pkg (pkg:String) -> True|False :
  contains?(PKGS, pkg)
  
public defn get-valid-pkg-list () :
  get-valid-pkg-list(MIN-PKG)

public defn get-valid-pkg-list (min-pkg: String) :
  val min-pkg-idx = find({PKGS[_] == min-pkg}, 0 to length(PKGS))
  match(min-pkg-idx: Int) :
    PKGS[min-pkg-idx to false]
  else :
    throw(Exception("Invalid min-pkg."))

public defn select-pkg (pkg:String|False) -> String :
  match(pkg) :
    (x:String) : reduce({ if _1 == x : _1 else : _0}, MIN-PKG, PKGS)
    (y) : MIN-PKG

; ========================================================
; ==== EIA Standard Tolerances and Logarithmic Values ====
; ========================================================
public val std-tols = to-list([20.0, 10.0, 5.0, 2.0, 1.0, 0.5, 0.25, 0.1])
public val std-vals = HashTable<Double, List<Double>>()

std-vals[20.0] = to-list([
  1.00, 1.50, 2.20, 3.30, 4.70, 6.80
])

std-vals[10.0] = to-list([
  1.20, 1.80, 2.70, 3.90, 5.60, 8.20
])

std-vals[5.0] = to-list([
  1.10, 1.30, 1.60, 2.00, 2.40, 3.00,
  3.60, 4.30, 5.10, 6.20, 7.50, 9.10
])

std-vals[2.0] = to-list([
  1.05, 1.15, 1.21, 1.27, 1.33, 1.40, 1.47, 1.54, 1.62,
  1.69, 1.78, 1.87, 1.96, 2.05, 2.15, 2.26, 2.37, 2.49,
  2.61, 2.74, 2.87, 3.01, 3.16, 3.32, 3.48, 3.65, 3.83,
  4.02, 4.22, 4.42, 4.64, 4.87, 5.11, 5.36, 5.62, 5.90,
  6.19, 6.49, 6.81, 7.15, 7.87, 8.25, 8.66, 9.09, 9.53
])

std-vals[1.0] = to-list([
  1.02, 1.07, 1.13, 1.18, 1.24, 1.37, 1.43, 1.58, 1.65,
  1.74, 1.82, 1.91, 2.10, 2.21, 2.32, 2.43, 2.55, 2.67,
  2.80, 2.94, 3.09, 3.24, 3.40, 3.57, 3.74, 3.92, 4.12,
  4.32, 4.53, 4.75, 4.99, 5.23, 5.49, 5.76, 6.04, 6.34,
  6.65, 6.98, 7.32, 7.68, 8.06, 8.45, 8.87, 9.31, 9.76
])

;E192 tolerance series of resistors contains 0.5, 0.25, 0.1
val e192-list = to-list([
  1.00 1.01 1.02 1.04 1.05 1.06 1.07 1.09 1.10 1.11 1.13 1.14
  1.15 1.17 1.18 1.20 1.21 1.23 1.24 1.26 1.27 1.29 1.30 1.32
  1.33 1.35 1.37 1.38 1.40 1.42 1.43 1.45 1.47 1.49 1.50 1.52
  1.54 1.56 1.58 1.60 1.62 1.64 1.65 1.67 1.69 1.72 1.74 1.76
  1.78 1.80 1.82 1.84 1.87 1.89 1.91 1.93 1.96 1.98 2.00 2.03
  2.05 2.08 2.10 2.13 2.15 2.18 2.21 2.23 2.26 2.29 2.32 2.34
  2.37 2.40 2.43 2.46 2.49 2.52 2.55 2.58 2.61 2.64 2.67 2.71
  2.74 2.77 2.80 2.84 2.87 2.91 2.94 2.98 3.01 3.05 3.09 3.12
  3.16 3.20 3.24 3.28 3.32 3.36 3.40 3.44 3.48 3.52 3.57 3.61
  3.65 3.70 3.74 3.79 3.83 3.88 3.92 3.97 4.02 4.07 4.12 4.17
  4.22 4.27 4.32 4.37 4.42 4.48 4.53 4.59 4.64 4.70 4.75 4.81
  4.87 4.93 4.99 5.05 5.11 5.17 5.23 5.30 5.36 5.42 5.49 5.56
  5.62 5.69 5.76 5.83 5.90 5.97 6.04 6.12 6.19 6.26 6.34 6.42
  6.49 6.57 6.65 6.73 6.81 6.90 6.98 7.06 7.15 7.23 7.32 7.41
  7.50 7.59 7.68 7.77 7.87 7.96 8.06 8.16 8.25 8.35 8.45 8.56
  8.66 8.76 8.87 8.98 9.09 9.20 9.31 9.42 9.53 9.65 9.76 9.88
])
std-vals[0.5]  = e192-list
std-vals[0.25] = e192-list
std-vals[0.1]  = e192-list

; Read more http://www.resistorguide.com/resistor-values/
public defn union-std-vals (tol:Double) :
  val union = Vector<Double>()
  for std-tol in std-tols do :
    if std-tol >= tol :
      add-all(union, std-vals[std-tol])
  to-list(qsort(union))

val cumulative-std-vals = HashTable<Double, List<Double>>()

for tol in std-tols do :
  cumulative-std-vals[tol] = union-std-vals(tol)


; Returns the closest value to v in the tolerance range specified by tol
public defn closest-std-val (v:Double, tol:Double) :
  val expon = floor(log10(v))
  val signif = v / (pow(10.0, expon))
  
  var match-diff = 100.0
  var match-val = -1.0

  if key?(cumulative-std-vals, tol) :
    for std-val in cumulative-std-vals[tol] do :
      val diff = abs(signif - std-val)
      if diff < match-diff :
        match-diff = diff
        match-val = std-val
  else :
    fatal("Tolerance %_ not found in standard tolerances." % [tol])

  match-val * pow(10.0, expon)

; ========================================================
; ==================== PartsDB ===========================
; ========================================================

public defn database-part (mpn: String) -> Instantiable :
  to-jitx $ PartsDBComponent(["mpn" => mpn])

public defn database-part (mpn: String, manufacturer: String) -> Instantiable :
  to-jitx $ PartsDBComponent(["mpn" => mpn, "manufacturer" => manufacturer])

public defn database-part (user-params:Tuple<KeyValue>) -> Instantiable :
  to-jitx $ PartsDBComponent(user-params)

public defn database-parts (user-params:Tuple<KeyValue>) -> Tuple<Instantiable> :
  map(to-jitx, PartsDBComponents(user-params, 10))

public defn database-parts (user-params:Tuple<KeyValue>, limit: Int) -> Tuple<Instantiable> :
  map(to-jitx, PartsDBComponents(user-params, limit))


; ========================================================
; ========== Generic passive components ==================
; ========================================================

public defn smd-query-properties () -> Tuple<KeyValue<String, ?>> :
  ["mounting" => "smd"
   "case" => get-valid-pkg-list()
   "min-stock" => 5 * DESIGN-QUANTITY]

; ========================================================
; ========== Handle min/max value searching ==============
; ========================================================

public defn replaceable-key (mykey:String) -> True|False :
  switch(mykey) :
    "resistance" : true
    "capacitance" : true
    "inductance" : true
    else : false

defn replace-params (params:Tuple<KeyValue>) -> Tuple<KeyValue> : 
  ; need to check if resistance/capacitance/inductance is passed a Toleranced() value and if 
  ; so, transform it appropriately 
  to-tuple $ for [myk, myv] in kvs(params) seq-cat : 
    match(myv:Toleranced) : 
      if replaceable-key(myk):
        [append("min-", myk) => min-value(myv), 
         append("max-", myk) => max-value(myv)]
      else : [myk => myv]
    else : [myk => myv]

defn lookup-val (params:Tuple<KeyValue>, key:String) -> Double|Toleranced|False :
  val my-val = 
    label<Double|Toleranced> return :
      for [myk, myv] in kvs(params) do :
        if myk == key :
          return(myv)
      fatal("Key (%_) not found in (%_)" % [key params])
  my-val

defn find-subs-comp (params:Tuple<KeyValue>, param-name:String) :
  val my-val = lookup-val(params, param-name)
  println("Warning: dummy substitution for %_ value (%_)" % [param-name, my-val])
  match(my-val:Double|Toleranced) :
    switch(param-name) :
      "capacitance" : dummy-capacitor(my-val)
      "resistance"  : dummy-resistor(my-val)
      "inductance"  : dummy-inductor(my-val)
      else :
        fatal("Can't find substitution for a value of %_" % [param-name])
  else :
    fatal("Did not find acceptable component value type (%_)" % [my-val])

; ========================================================
; ==================== ceramic-cap =======================
; ========================================================

; Generic ceramic capacitor from database (of 600k options)
public defn ceramic-cap (user-params:Tuple<KeyValue>) -> Instantiable :
  val params = normalize-params $ [["type" => "ceramic" "min-rated-voltage" => MIN-CAP-VOLTAGE]
                                        smd-query-properties()
                                        user-params]
  val my-params = replace-params(params)
  try :
    to-jitx $ Capacitor(my-params)
  catch (e:jitx/errors/NoComponentMeetingRequirements) :
    println("No capacitor found that satisfies requirements.")
    find-subs-comp(params, "capacitance")
  catch (e:QueryInternetConnectionError) :
    println("Internet connection error while connecting to parts database.")
    find-subs-comp(params, "capacitance")
  ; we are not catching the following errors so that the normal error handlers can provide 
  ; more detailed feedback. However the design will stop compiling and will require the user
  ; to correct the lookup parameters.
  ; jitx/errors/InvalidPartDatabaseQueryAttributeType
  ; jitx/errors/InvalidPartDatabaseQuerySpecialKey
  ; jitx/errors/InvalidPartDatabaseQueryProperty


public defn ceramic-cap (cap:Double|Toleranced) -> Instantiable :
  ceramic-cap(["capacitance" => cap])

public defn ceramic-cap (cap:Double|Toleranced, tolerance:Double) -> Instantiable :
  ceramic-cap(["capacitance" => cap "tolerance" => tolerance])

public defn ceramic-caps (user-params:Tuple<KeyValue>, limit: Int) -> Tuple<Instantiable> :
  val params = normalize-params $ [["type" => "ceramic" "min-rated-voltage" => MIN-CAP-VOLTAGE]
                                        smd-query-properties()
                                        user-params]
  map(to-jitx, Capacitors(replace-params(params), limit))

; ========================================================
; =============== look-up-ceramic-caps ===================
; ========================================================

public defn look-up-ceramic-caps (attribute: String) -> Tuple :
  look-up-ceramic-caps(attribute, [])

public defn look-up-ceramic-caps (attribute: String, filter-properties:Tuple<KeyValue>) -> Tuple :
  val params = normalize-params $ [["type" => "ceramic" "min-rated-voltage" => MIN-CAP-VOLTAGE]
                                        smd-query-properties()
                                        filter-properties]
  look-up-capacitors(attribute, replace-params(params))

; ========================================================
; ==================== tantalum-cap =======================
; ========================================================
; Use for adding an instance of a tantalum cap from the JITX database to your design.
public defn tantalum-cap (user-params:Tuple<KeyValue>) -> Instantiable :
  val params = normalize-params $ [["anode" => "tantalum" "min-rated-voltage" => MIN-CAP-VOLTAGE]
                                        smd-query-properties()
                                        user-params]
  val my-params = replace-params(params)
  try :
    to-jitx $ Capacitor(my-params)
  catch (e:jitx/errors/NoComponentMeetingRequirements) :
    println("No capacitor found that satisfies requirements.")
    find-subs-comp(params, "capacitance")
  catch (e:QueryInternetConnectionError) :
    println("Internet connection error while connecting to parts database.")
    find-subs-comp(params, "capacitance")

public defn tantalum-cap (cap:Double|Toleranced) -> Instantiable :
  tantalum-cap(["capacitance" => cap])

public defn tantalum-cap (cap:Double|Toleranced, tolerance:Double) -> Instantiable :
  tantalum-cap(["capacitance" => cap "tolerance" => tolerance])

public defn tantalum-caps (user-params:Tuple<KeyValue>, limit: Int) -> Tuple<Instantiable> :
  val params = normalize-params $ [["anode" => "tantalum" "min-rated-voltage" => MIN-CAP-VOLTAGE]
                                        smd-query-properties()
                                        user-params]
  map(to-jitx, Capacitors(replace-params(params), limit))

; ========================================================
; =============== look-up-tantalum-caps ===================
; ========================================================
; Looks up the list of available values for attribute amongst tantalum capacitors in the JITX database.
public defn look-up-tantalum-caps (attribute: String) -> Tuple :
  look-up-tantalum-caps(attribute, [])

public defn look-up-tantalum-caps (attribute: String, filter-properties:Tuple<KeyValue>) -> Tuple :
  val params = normalize-params $ [["anode" => "tantalum" "min-rated-voltage" => MIN-CAP-VOLTAGE]
                                        smd-query-properties()
                                        filter-properties]
  look-up-capacitors(attribute, replace-params(params))

; ========================================================
; ==================== chip-resistor =====================
; ========================================================

doc: \<DOC>
  Generic chip resistor from database (of 600k options)
  ## Args:
  `user-params:Tuple<KeyValue>` - a collection of filtering parmeters to select an SMD thin or thick film resistor
  ## Returns:
  `Instantiable` - an instantiable of a real resistor matching the provided parameters.
  ## Example use:
  ```
    inst r : chip-resistor(["resistance" => 0.01 "tolerance" => 0.005 "min-rated-power" => 0.5])

  ## More info:
  https://docs.jitx.com/reference/components/resistors.html#chip-resistor
  
<DOC>
public defn chip-resistor (user-params:Tuple<KeyValue>) -> Instantiable :
  val params = normalize-params([smd-query-properties() user-params])
  val my-params = replace-params(params)
  try :
    to-jitx $ Resistor(my-params)
  catch (e:jitx/errors/NoComponentMeetingRequirements) :
    println("No resistor found that satisfies requirements.")
    find-subs-comp(params, "resistance")
  catch (e:QueryInternetConnectionError) :
    println("Internet connection error while connecting to parts database.")
    find-subs-comp(params, "resistance")

public defn chip-resistor (resistance:Double|Toleranced) -> Instantiable :
  chip-resistor(["resistance" => resistance])

public defn chip-resistor (resistance:Double|Toleranced, tolerance:Double) -> Instantiable :
  chip-resistor(["resistance" => resistance "tolerance" => tolerance])

public defn chip-resistors (user-params:Tuple<KeyValue>, limit: Int) -> Tuple<Instantiable> :
  val params = normalize-params([smd-query-properties() user-params])
  map(to-jitx, Resistors(replace-params(params), limit))

; ========================================================
; ================ look-up-chip-resistors ================
; ========================================================

public defn look-up-chip-resistors (attribute: String) -> Tuple :
  look-up-resistors(attribute, [])

public defn look-up-chip-resistors (attribute: String, filter-properties:Tuple<KeyValue>) -> Tuple :
  val params = normalize-params([smd-query-properties() filter-properties])
  look-up-resistors(attribute, replace-params(params))

;============================================================
;==================== smd-inductor ==========================
;============================================================

; Generic inductors from database of standard packages (0402, 0603... 10k options)
public defn smd-inductor (user-params:Tuple<KeyValue>) -> Instantiable :
  val params = normalize-params([smd-query-properties() user-params])
  val my-params = replace-params(params)
  try :
    to-jitx $ Inductor(my-params)
  catch (e:jitx/errors/NoComponentMeetingRequirements) :
    println("No inductor found that satisfies requirements.")
    find-subs-comp(params, "inductance")
  catch (e:QueryInternetConnectionError) :
    println("Internet connection error while connecting to parts database.")
    find-subs-comp(params, "inductance")

public defn smd-inductor (ind:Double|Toleranced) -> Instantiable :
  smd-inductor(["inductance" => ind])

public defn smd-inductor (ind:Double|Toleranced, tolerance:Double) -> Instantiable :
  smd-inductor(["inductance" => ind "tolerance" => tolerance])

public defn smd-inductors (user-params:Tuple<KeyValue>, limit: Int) -> Tuple<Instantiable> :
  val params = normalize-params([smd-query-properties() user-params])
  map(to-jitx, Inductors(replace-params(params), limit))

; ========================================================
; ================ look-up-smd-inductors =================
; ========================================================

public defn look-up-smd-inductors (attribute: String) -> Tuple :
  look-up-smd-inductors(attribute, [])

public defn look-up-smd-inductors (attribute: String, filter-properties:Tuple<KeyValue>) -> Tuple :
  val params = normalize-params([smd-query-properties() filter-properties])
  look-up-inductors(attribute, replace-params(params))

; ========================================================
; ===================== gen-cap-cmp ======================
; ========================================================
public pcb-component gen-cap-cmp (cap:Double, tol:Double, max-v:Double, pkg-name:String) :
  port p : pin[1 through 2]
  val sym = capacitor-sym()
  val pkg = ipc-two-pin-landpattern(pkg-name)
  symbol = sym(p[1] => sym.p[1], p[2] => sym.p[2])
  landpattern = pkg(p[1] => pkg.p[1], p[2] => pkg.p[2])
  emodel = Capacitor(cap, tol, max-v)
  reference-prefix = "C"
  ; spice :
  ;   "[C] {p[1]} tmp {cap}"
  ;   "[R] tmp {p[2]} 0.01"
  property(self.capacitor) = true
  property(self.type) = "ceramic"
  property(self.capacitance) = cap
  property(self.tolerance) = tol
  property(self.rated-voltage) = max-v
  property(self.rated-temperature) = min-max(-55.0, 125.0)

public defn gen-cap-cmp (cap:Double, tol:Double, max-v:Double) :
  gen-cap-cmp(cap, tol, max-v, "0402")

public defn gen-cap-cmp (cap:Double, max-v:Double) :
  gen-cap-cmp(cap, 0.2, max-v, "0402")

public defn gen-cap-cmp (cap:Double, pkg:String) :
  gen-cap-cmp(cap, 0.2, 10.0, pkg)

public defn gen-cap-cmp (cap:Double) :
  gen-cap-cmp(cap, 10.0)

; ========================================================
; ===================== gen-tant-cap-cmp ======================
; ========================================================
;Generic Tantalum surface mount capacitors
public pcb-component gen-tant-cap-cmp (cap:Double, tol:Double, max-v:Double, pkg:String) :
  pin a 
  pin c
  val sym = capacitor-sym(CapacitorPolarized)
  symbol = sym(a => sym.p[1], c => sym.p[2])
  emodel = Capacitor(cap, tol, max-v)
  switch(pkg) :
    "0402" : landpattern = CAPT1005X55(a => CAPT1005X55.p[1] c => CAPT1005X55.p[2])
    "0603" : landpattern = CAPT1608X80(a => CAPT1608X80.p[1] c => CAPT1608X80.p[2])
    "0805" : landpattern = CAPT2012X125(a => CAPT2012X125.p[1] c => CAPT2012X125.p[2])
    "1206" : landpattern = CAPT3216X160(a => CAPT3216X160.p[1] c => CAPT3216X160.p[2])
    else : fatal("Incorrect capacitor package %_." % [pkg])
  reference-prefix = "C"
  ; spice :
  ;   "[C] {a} tmp {cap}"
  ;   "[R] tmp {c} 2.0"
  property(self.capacitor) = true
  property(self.type) = "electrolytic"
  property(self.anode) = "tantalum"
  property(self.electrolyte) = "polymer"
  property(self.capacitance) = cap
  property(self.rated-voltage) = max-v
  property(self.tolerance) = (tol * 0.01)
  property(self.rated-current-pk) = 3.7
  property(self.rated-current-rms) = [[25.0 0.298] [85.0 0.268] [125.0 0.119]]
  property(self.rated-temperature) = min-max(-55.0, 125.0)

public defn gen-tant-cap-cmp (cap:Double, tol:Double, max-v:Double) :
  gen-tant-cap-cmp(cap, tol, max-v, "0402")

public defn gen-tant-cap-cmp (cap:Double, pkg:String) :
  gen-tant-cap-cmp(cap, 20.0, 10.0, pkg)

public defn gen-tant-cap-cmp (cap:Double, max-v:Double) :
  gen-tant-cap-cmp(cap, 10.0, max-v)

public defn gen-tant-cap-cmp (cap:Double) :
  gen-tant-cap-cmp(cap, 20.0)

; ========================================================
; ===================== gen-res-cmp ======================
; ========================================================
public pcb-component gen-res-cmp (r-type:ResistorSymbolType, res:Double, tol:Double, pwr:Double, pkg-name:String) :
  ; if r-type is Symbol and (r-type as Symbol) == `pot :
  ;   port p : pin[1 2 3]
  ; else :
  port p : pin[1 through 2]
  val sym = resistor-sym(r-type)
  val pkg = ipc-two-pin-landpattern(pkg-name)
  symbol = sym(p[1] => sym.p[1], p[2] => sym.p[2])
  landpattern = pkg(p[1] => pkg.p[1], p[2] => pkg.p[2])
  emodel = Resistor(res, tol, pwr)
  reference-prefix = "R"
  property(self.type) = "thick-film"
  property(self.rated-voltage) = 50.0
  property(self.rated-power) = pwr
  property(self.derating) = [[-60.0 1.0] [70.0 1.0] [155.0 0.0]]
  property(self.TCR) = 100.0e-6
  property(self.rated-temperature) = min-max(-55.0, 125.0)
  property(self.tolerance) = (tol * 0.01)
  property(self.resistance) = res
  property(self.resistor) = true
  ; spice :
  ;   "[R] {p[1]} {p[2]} {res}"

public defn gen-res-cmp (res:Double, tol:Double, pkg:String) :
  gen-res-cmp(ResistorStd, res, tol, 0.0625, pkg)

public defn gen-res-cmp (res:Double, tol:Double, pwr:Double) :
  gen-res-cmp(ResistorStd, res, tol, 0.0625, "0402")

public defn gen-res-cmp (res:Double, tol:Double) :
  gen-res-cmp(res, tol, 0.0625)

public defn gen-res-cmp (res:Double, pkg:String) :
  gen-res-cmp(ResistorStd, res, 2.0, 0.0625, pkg)

public defn gen-res-cmp (res:Double) :
  gen-res-cmp(res, 2.0)

; ========================================================
; ===================== gen-ind-cmp ======================
; ========================================================
public pcb-component gen-ind-cmp (l-type:InductorSymbolType, ind:Double, tol:Double, max-i:Double) :
  port p : pin[1 through 2]
  emodel = Inductor(ind, tol, max-i)

  val sym = inductor-sym(l-type)
  symbol = sym(p[1] => sym.p[1], p[2] => sym.p[2])
  landpattern = INDC1005X55(p[1] => INDC1005X55.p[1], p[2] => INDC1005X55.p[2]) ;TODO: all inductors 0402
  reference-prefix = "L"
  property(self.inductor) = true
  property(self.inductance) = ind
  property(self.tolerance) = (tol * 0.01)
  property(self.max-current) = max-i

public defn gen-ind-cmp (ind:Double, tol:Double) :
  gen-ind-cmp(InductorStd, ind, tol, 0.1) ; 100mA default

public defn gen-ind-cmp (ind:Double) :
  gen-ind-cmp(ind, 10.0)
; ========================================================
; ===================== gen-led-cmp ======================
; ========================================================
public pcb-component gen-led-cmp (vf:Toleranced, itest:Double, color:String, pkg-name:String, density:DensityLevel) :
  pin a
  pin c
  description = to-string("LED, GENERIC, %_, Vf %_V, If %_ mA, %_" % [color, center-value(vf), to-int(itest * 1000.0), pkg-name])
  mpn = to-string("%_, Vf %_, If %_ mA" % [color, to-string(center-value(vf)), to-string(to-int(itest * 1000.0))])
  name = to-string("Generic %_ LED %_" % [color, pkg-name])
  val sym = diode-sym(DiodeLED)
  symbol = sym(a => sym.a, c => sym.c)
  val land = ipc-two-pin-pol-landpattern(pkg-name, density)
  landpattern = land(a => land.a, c => land.c)
  var vf-center = 0.0
  vf-center = center-value(vf)
  reference-prefix = "D"
  property(self.diode) = true
  property(self.forward-voltage) = vf-center ; Vf
  property(self.test-current) = itest ; If or Itest
  property(self.NamedColor) = color

public defn gen-led-cmp (vf:Toleranced, itest:Double, color:String, pkg-name:String) :
  gen-led-cmp(vf, itest, color, pkg-name, DENSITY-LEVEL)

public defn gen-led-cmp (vf:Double, itest:Double, color:String, pkg-name:String) :
  gen-led-cmp(tol(vf, 0.1), itest, color, pkg-name)

public defn gen-led-cmp (vf:Toleranced, color:String, pkg-name:String) :
  gen-led-cmp(vf, 20.0e-3, color, pkg-name)

public defn gen-led-cmp (vf:Double, color:String, pkg-name:String) :
  gen-led-cmp(tol(vf, 0.1), 20.0e-3, color, pkg-name)

public defn gen-led-cmp (vf:Toleranced, pkg-name:String) :
  gen-led-cmp(vf, 20.0e-3, "ANY COLOR", pkg-name)

public defn gen-led-cmp (vf:Double, pkg-name:String) :
  gen-led-cmp(tol(vf, 0.1), 20.0e-3, "ANY COLOR", pkg-name)

public defn gen-led-cmp (vf:Toleranced, itest:Double) :
  gen-led-cmp(vf, itest, "ANY COLOR", MIN-PKG)

public defn gen-led-cmp (vf:Double, itest:Double) :
  gen-led-cmp(tol(vf, 0.1), itest, "ANY COLOR", MIN-PKG)

public defn gen-led-cmp (vf:Toleranced, itest:Double, pkg-name:String) :
  gen-led-cmp(vf, itest, "ANY COLOR", pkg-name)

public defn gen-led-cmp (vf:Double, itest:Double, pkg-name:String) :
  gen-led-cmp(tol(vf, 0.1), itest, "ANY COLOR", pkg-name)

public defn gen-led-cmp (vf:Toleranced) :
  gen-led-cmp(vf, 0.02, "ANY COLOR", MIN-PKG)

public defn gen-led-cmp (vf:Double) :
  gen-led-cmp(tol(vf, 0.1), 0.02, "ANY COLOR", MIN-PKG)

public defn gen-led-cmp (color:String, pkg-name:String) :
  gen-led-cmp(tol(2.0, 0.2), 0.02, color, pkg-name)

public defn gen-led-cmp (pkg-name:String) :
  gen-led-cmp(tol(2.0, 0.2), 0.02, "ANY COLOR", pkg-name)

; ========================================================
; ============ Component strapping functions =============
; ========================================================
; These functions attach a passive component between two pins. e.g. strap a pull up resistor between an IO and VDD

public defn bypass-cap-strap (power-pin:JITXObject, gnd-pin:JITXObject, params:Tuple<KeyValue>):
  inside pcb-module:
    val cap = cap-strap(gnd-pin, power-pin, params)
    short-trace(cap.p[2], power-pin)
    cap

public defn bypass-cap-strap (power-pin:JITXObject, gnd-pin:JITXObject, capacitance:Double|Toleranced, tol:Double):
  bypass-cap-strap(power-pin, gnd-pin, ["capacitance" => capacitance, "tolerance" => tol])

public defn bypass-cap-strap (power-pin:JITXObject, gnd-pin:JITXObject, capacitance:Double|Toleranced):
  bypass-cap-strap(power-pin, gnd-pin, ["capacitance" => capacitance])

public defn bypass-caps (power-pin:JITXObject|Symbol, gnd-pin:JITXObject|Symbol, voltage:Double, caps:Tuple<Double|Toleranced>, name:Symbol) :
  inside pcb-module:
    val n-caps = length(caps)
    for i in 0 to n-caps do :
      inst c : ceramic-cap(["capacitance" => caps[i], "min-rated-voltage" => voltage])
      match(power-pin) :
        (r:JITXObject) :
          net (r, c.p[1])
          short-trace(r, c.p[1])
        (s:Symbol) :
          make-net(s, false, [c.p[1]], false)
      match(gnd-pin) :
        (r:JITXObject) :
          net (r, c.p[2])
        (s:Symbol) :
          make-net(s, false, [c.p[2]], false)

; ========================================================
; ======================= res-strap ======================
; ========================================================
public defn res-strap (first-pin:JITXObject, second-pin:JITXObject, params:Tuple<KeyValue>) -> JITXObject :
  inside pcb-module:
    inst rid : chip-resistor(params)
    net (first-pin, rid.p[1])
    net (second-pin, rid.p[2])
    rid

public defn res-strap (first-pin:JITXObject, second-pin:JITXObject, resistance:Double|Toleranced, tol:Double) :
  res-strap(first-pin, second-pin, ["resistance" => resistance "tolerance" => tol])

public defn res-strap (first-pin:JITXObject, second-pin:JITXObject, resistance:Double|Toleranced) :
  res-strap(first-pin, second-pin, ["resistance" => resistance])

; ========================================================
; ====================== cap-strap =======================
; ========================================================
public defn cap-strap (first-pin:JITXObject, second-pin:JITXObject, params:Tuple<KeyValue>) -> JITXObject :
  inside pcb-module:
    inst cap : ceramic-cap(params)
    net (first-pin, cap.p[1])
    net (second-pin, cap.p[2])
    cap

public defn cap-strap (first-pin:JITXObject, second-pin:JITXObject, capacitance:Double|Toleranced, tol:Double) :
  cap-strap(first-pin, second-pin, ["capacitance" => capacitance "tolerance" => tol])

public defn cap-strap (first-pin:JITXObject, second-pin:JITXObject, capacitance:Double|Toleranced) :
  cap-strap(first-pin, second-pin, ["capacitance" => capacitance])

; ========================================================
; ====================== ind-strap =======================
; ========================================================
public defn ind-strap (first-pin:JITXObject, second-pin:JITXObject, params:Tuple<KeyValue>) -> JITXObject :
  inside pcb-module:
    inst ind : smd-inductor(params)
    net (first-pin, ind.p[1])
    net (second-pin, ind.p[2])
    ind

public defn ind-strap (first-pin:JITXObject, second-pin:JITXObject, inductance:Double|Toleranced, tol:Double) :
  ind-strap(first-pin, second-pin, ["inductance" => inductance "tolerance" => tol])

public defn ind-strap (first-pin:JITXObject, second-pin:JITXObject, inductance:Double|Toleranced) :
  ind-strap(first-pin, second-pin, ["inductance" => inductance])

public defn default-bypass (cmp:JITXObject) :
  inside pcb-module:
    for p in ports(cmp) do :
      if has-property?(p.power-pin) or has-property?(p.power-supply-pin):
        inst cap : ceramic-cap(0.1e-6)
        property(cap.bypass) = true
        net (cap.p[1], p)
        short-trace(cap.p[1], p)
        net (cap.p[2], cmp.gnd)

public defn block-cap (in:JITXObject, out:JITXObject, cap:Double|Toleranced) -> JITXObject :
  inside pcb-module :
    inst block : ceramic-cap(cap)
    net (in, block.p[1])
    net (out, block.p[2])
    block

public defn block-cap (in:JITXObject, out:JITXObject) :
  block-cap(in, out, 100.0e-6)


; ========================================================
; =================== Generic connectors =================
; ========================================================

public defn banana-plug (color:String) :
  ocdb/components/pomona/1581/component(color)

public pcb-module banana-plug-module ():
  port power : power
  inst vdd-plug : ocdb/components/pomona/1581/component("red")
  inst gnd-plug : ocdb/components/pomona/1581/component("black")
  net (power.vdd vdd-plug.p)
  net (power.gnd gnd-plug.p)
  val pitch = 0.75 / 2.0 * 25.4
  place(vdd-plug) at loc(pitch * -1.0, 0.0) on Top
  place(gnd-plug) at loc(pitch, 0.0) on Top

  inst vin-label : text("VIN", 1.2, 0.0)
  inst gnd-label : text("GND", 1.2, 0.0)
  place(vin-label) at loc(pitch * -1.0, -7.5) on Top
  place(gnd-label) at loc(pitch, -7.5) on Top

public pcb-component pin-header (n-pin:Int, n-row:Int, pin-pitch:Double, row-pitch:Double) :
  description = "Generic pin-header"
  mpn = to-string("%_X%_-pin-header" % [n-pin n-row])
  if n-row == 1 :
    pin-properties :
      [pin:Ref     | pads:Int ...   | side:Dir]
      for i in 1 through n-pin do :
        [p[i] | i | Left]
  else :
    pin-properties :
      [pin:Ref     | pads:Int ...   | side:Dir]
      for i in 1 through n-pin by 2 do :
        [p[i] | i | Left]
        [p[i + 1] | (i + 1) | Right]

  assign-landpattern(pin-header-pkg(n-pin, n-row, pin-pitch, row-pitch))
  make-box-symbol()

  reference-prefix = "J"

public defn pin-header (n-pin:Int) :
  pin-header(n-pin, 1, 2.54)

public defn pin-header (n-pin:Int, n-row:Int) :
  pin-header(n-pin, n-row, 2.54)

public defn pin-header (n-pin: Int, pin-pitch:Double) :
  pin-header(n-pin, 1, pin-pitch)

public defn pin-header (n-pin: Int, n-row: Int, pin-pitch:Double) :
  pin-header(n-pin, n-row, pin-pitch, pin-pitch)

public defn sma-connector ():
  ocdb/components/johnson/142-0761-881/component

public defn bnc-connector () :
  ocdb/components/amphenol/112640/component

public defn ethernet-jack ():
  ocdb/components/pulse-electronics/J0G-0009NL/component

; USB2 device connection via USBA MicroB
public pcb-module micro-usb-connector :
  port usb-2 : usb-2
  public inst con : ocdb/components/amphenol/10103594-0001LF/component
  net VBUS (usb-2.vbus.vdd con.VCC)
  net (usb-2.vbus.gnd con.GND)
  ; RC filter connection for chassis gnd
  res-strap(con.SHIELD, con.GND, 100.0e3)
  cap-strap(con.SHIELD, con.GND, 0.1e-6)
  net SHIELD (con.SHIELD)
  net D+ (usb-2.data.P con.D+)
  net D- (usb-2.data.N con.D-)
  net ID (usb-2.id con.ID)
  property(con.VCC.power-supply-pin) = PowerSupplyPin(typ(5.0), 0.5)

  schematic-group(self) = micro-usb

public defn  usb2-on-a-usb-c-connector ():
  usb2-on-a-usb-c-connector(ocdb/components/belfuse/SS-52400-003/module(SinkDefault))

public pcb-module usb2-on-a-usb-c-connector (conref:Instantiable):
  port usb-2 : usb-2
  port usb-c : usb-c
  public inst con : conref
  place(con) at loc(0.0, 0.0) on Top
  net (usb-c con.usb-c)
  net (usb-2.data.N con.usb-c.data[1].N con.usb-c.data[2].N)
  net (usb-2.data.P con.usb-c.data[1].P con.usb-c.data[2].P)
  net (usb-2.vbus con.usb-c.vbus)
  property(usb-2.vbus.vdd) = PowerSupplyPin(typ(5.0), 0.5)
  res-strap(con.SHIELD, usb-2.vbus.gnd, 100.0e3)
  cap-strap(con.SHIELD, usb-2.vbus.gnd, 0.1e-6)
  
; Add a tag-connect landing pattern to a processor
public defn attach-programming-connector (proc:JITXObject, vio:JITXObject, intf:String):
  inside pcb-module:
    public inst tag : ocdb/components/tag-connect/TC2050-IDC-NL/module
    net (vio, tag.pwr)
    if intf == "swd" :
      require swd:swd() from proc
      net (swd tag.swd)
    else if intf == "jtag" :
      require jtag:jtag() from proc
      net (jtag tag.jtag)

; ========================================================
; ================== Testpoint functions =================
; ========================================================

public pcb-enum ocdb/utils/generic-components/Testpoint :
  Testpoint-SMDLoop
  Testpoint-SMDPad
  Testpoint-PTHLoop

pcb-module test-points (count:Int, method:ocdb/utils/generic-components/Testpoint|Instantiable) :
  port tp : pin[count]
  val points = match(method) :
    (method:Testpoint-PTHLoop) :
      var color = "yellow"
      ; if r == #R(gnd):
      ;   color = "black"
      inst point : ocdb/components/keystone/500xx/component(color)[count]
      point
    (method:Testpoint-SMDLoop) :
      inst point : ocdb/components/te-connectivity/RC/component[count]
      point
    (method:Testpoint-SMDPad) :
      inst point : gen-testpad(1.0)[count]
      point
    (method:Instantiable) :
      inst point : method[count]
      point
  for i in 0 to count do :
    net (tp[i] points[i].p)

public defn add-testpoint (rs:Tuple<JITXObject>, method:ocdb/utils/generic-components/Testpoint|Instantiable) :
  inside pcb-module :
    inst test-points:test-points(length(rs), method)
    for (r in rs, i in 0 to false) do :
      net (test-points.tp[i] r)
    test-points

public defn add-testpoint (rs:Tuple<JITXObject>) :
  add-testpoint(rs, Testpoint-SMDPad)

public pcb-component gen-testpad (d:Double) :
  pin p
  symbol = test-point-sym(p => test-point-sym.p)
  val pkg = testpad(d)
  landpattern = pkg(p => pkg.tp)
  property(self.rated-temperature) = false


public defn add-testpad (rs:Tuple<JITXObject>, d:Double) :
  inside pcb-module :
    for r in rs do :
      public inst tp : gen-testpad(d)
      net (tp.p, r)

; Adds a testpoint with a user provided name
; Parameters
; ------------
; tp : the JITXObject to connect the testpoint to
; tp-name : the name of the testpoint to place as the value and print on the silkscreen
; diameter : the diameter of the testpoint pad
public defn testpoint-strap (tp:JITXObject, tp-name:String, diameter:Double) -> JITXObject:
  inside pcb-module :
    public inst tp-pad : gen-testpad(diameter)
    net (tp-pad.p tp)
    ; name the test point
    value-label(tp-pad) = Text(tp-name, 1.0, W, loc(1.5, 0.0))
    tp-pad

public pcb-component smd-testpoint-cmp (d:Double) :
  pin p
  symbol = test-point-sym(p => test-point-sym.p)
  val lp = smd-testpoint-pkg(d)
  landpattern = lp(p => lp.p)
  reference-prefix = "TP"

public defn smd-testpoint-cmp () :
  smd-testpoint-cmp(2.0)

public defn dip-pull (pins:Tuple<JITXObject>, power-pin:JITXObject, gnd-pin:JITXObject) :
  inside pcb-module :
    val n = length(pins)
    public inst dip : ocdb/components/cts/219/component(n)
    require sws:SPST[n] from dip
    for i in 0 to n do :
      net (pins[i], sws[i].p)
      net (power-pin, sws[i].t)
      res-strap(pins[i], gnd-pin, 10.0e3)

; A mounting hole component with drill and mask radius. Pad radius is unused.
public pcb-component mounting-hole (drill-r:Double, pad-r:Double, mask-r:Double) :
  name             = "Generic Mounting Hole"
  description      = to-string("%~mm mounting hole" % [2. * drill-r])
  landpattern      = (non-plated-hole-landpattern(drill-r, mask-r))()
  symbol           = unplated-hole-sym()
  property(self.rated-temperature) = false


; A mounting hole component with drill and pad radius. 
public defn mounting-hole (drill-r:Double, pad-r:Double) :
  mounting-hole(drill-r, pad-r, pad-r + 0.35)

; A mounting hole component with a fixed drill radius
public defn mounting-hole (drill-r:Double) :
  mounting-hole(drill-r, drill-r + 0.35)

; A non-standard hole with arbitrary shape
public pcb-component hole-component (hole-shape:Shape):
  name              = "Generic hole"
  description       = to-string("%_ shaped hole" % [hole-shape])
  landpattern       = (non-plated-hole-landpattern(hole-shape))()
  symbol            = unplated-hole-sym()
  reference-prefix = "H"

; Add mounting holes to the board given its shape, a screw size, and hole indices to exclude.
public defn add-mounting-holes (board-shape:Shape, screw-size:String|Double, no-hole:Tuple<Int>) :
  val d = dims(board-shape)
  val board = Rectangle(x(d), y(d))
  inside pcb-module :
    val w =  width(board)
    val h =  height(board)
    val r = match(screw-size) :
      (screw:String) :
        switch(screw) :
          ;Loose Fit https://blogs.mentor.com/tom-hausherr/blog/tag/pcb-mounting-holes/
          "M2"   : 2.3 / 2.0
          "M2p5" : 2.85 / 2.0
          "M3"   : 3.5 / 2.0
          "M3p5" : 3.9 / 2.0
          else : fatal("Unsupported screw-size %_ for mounting hole" % [screw])
      (diameter:Double) : diameter / 2.0
      (f) : fatal("Unsupported call to mounting hole")
    val offs = r * 6.0 ;1.5X bolt diameter * 2
    for (l in grid-locs(2, 2, w - offs, h - offs), i in 1 through 4) do :
      if not contains?(no-hole, i) :
        inst hole : mounting-hole(r)
        place(hole) at l on Top

; Add mounting holes to the board given its shape and a screw size.
public defn add-mounting-holes (board:Shape, screw-size:String|Double):
  add-mounting-holes(board, screw-size, [])

;  Add mounting holes to the board given its shape. Defaults to M3 size holes.
public defn add-mounting-holes (board:Shape) :
  add-mounting-holes(board, "M3", [])

; Add mounting holes to the board given its shape, excluding holes given
; by the indices in no-holes. Defaults to M3 size mounting holes.
public defn add-mounting-holes (board:Shape, no-hole:Tuple<Int>) :
  add-mounting-holes(board, "M3", no-hole)

; ========================================================
; ===================== Antennas =========================
; ========================================================

pcb-landpattern ant-2GHz4-inverted-f-geom :

  pad launch : smd-pad(0.5, 0.5) at loc(0.0, 0.25)
  pad gnd : smd-pad(0.9, 0.5) at loc(-2.1, 0.25)

  copper(LayerIndex(0)) = Line(0.5, [Point(-2.1, 5.15), Point(2.2, 5.15), Point(2.2, 2.51), 
                                Point(4.7, 2.51),  Point(4.7, 5.15), Point(6.9, 5.15), 
                                Point(6.9, 2.51),  Point(9.4, 2.51), Point(9.4, 5.15), 
                                Point(11.6, 5.15), Point(11.6, 0.96)])
  copper(LayerIndex(0)) = Line(0.5, [Point(0.0, 0.0),   Point(0.0, 5.15)])
  copper(LayerIndex(0)) = Rectangle(0.9, 5.4, loc(-2.1, 2.7))
  layer(ForbidCopper(LayerIndex(0), LayerIndex(0, Bottom))) = Rectangle(30.0, 5.5, loc(5.0, 3.25))
  layer(SolderMask(Top)) = Rectangle(30.0, 5.5, loc(5.0, 3.25))
  layer(Courtyard(Top)) = Rectangle(30.0, 5.5, loc(5.0, 3.25))
  layer(Courtyard(Bottom)) = Rectangle(30.0, 5.5, loc(5.0, 3.25))
  layer(BoardEdge()) = Line(0.0, [Point(17.0, 6.0), Point(-7.0, 6.0)])
  ref-label()

public pcb-component inverted-f-antenna-cmp :
  pin launch
  pin gnd
  description = "2.4 GHz Inverted F trace antenna"
  val pkg = ant-2GHz4-inverted-f-geom
  val sym = antenna-symbol(1, 1)
  landpattern = pkg(launch => pkg.launch, gnd => pkg.gnd)
  symbol = sym(launch => sym.p[1], gnd => sym.p[2])
  reference-prefix = "ANT"
  property(self.rated-temperature) = false

public pcb-module inverted-f-antenna :
  pin rf-in
  pin gnd
  public inst ant : inverted-f-antenna-cmp
  place(ant) at loc(0.0, 0.0) on Top
  ; PI filter
  public inst c0 : ceramic-cap(["capacitance" => 5.6e-12 "temperature-coefficient.code" => "C0G"])
  public inst c1 : ceramic-cap(["capacitance" => 2.4e-12 "temperature-coefficient.code" => "C0G"])
  public inst l : smd-inductor(["inductance" => 2.7e-9 "min-self-resonant-frequency" => 7.0e6 "min-quality-factor" => 8.0])
  net (gnd, ant.gnd c1.p[1] l.p[1])
  net (ant.launch c0.p[2] c1.p[2])
  net (rf-in c0.p[1] l.p[2])
  place(c1) at loc(-0.5, -0.3) on Top
  place(c0) at loc(-0.05, -1.45, 90.0) on Top
  place(l) at loc(-0.5, -2.6) on Top

  schematic-group(self) = inverted-f-antenna

; ========================================================
; =================== Indicators =========================
; ========================================================

; 50 - 200 mcd for daylight
; 4 - 10 mcd for indoor

; Adds an RGB led to a processor using PWM pins
public defn add-rgb-indicator (brightness:Double, proc:JITXObject, vin:JITXObject):
  inside pcb-module:
    pcb-module rgb-indicator :
      port control-pins : timer[3]
      val vio = 3.3 ; TODO: get this from the vin pin property
      ; Calculate resistance to get appropriate brightness
      defn calc-r (l:JITXObject, brightness:Double, vio:Double):
        val i = PWL(property(l.mcd-current))[brightness]
        closest-std-val((vio - property(l.forward-voltage)) / i, 5.0)
      public inst led : ocdb/components/foshan-optoelectronics/FM-B2020RGBA-HG/component ; TODO: make generic
      
      res-strap(control-pins[0].timer, led.l.r, calc-r(led.l.r, brightness, vio))
      res-strap(control-pins[1].timer, led.l.g, calc-r(led.l.g, brightness, vio))
      res-strap(control-pins[2].timer, led.l.b, calc-r(led.l.b, brightness, vio))

    inst rgb:rgb-indicator
    require control-pins:timer[3] from proc
    net (vin, rgb.led.l.a)
    net (control-pins rgb.control-pins)
    rgb
