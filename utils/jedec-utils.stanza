#use-added-syntax(esir)
defpackage ocdb/jedec-utils :
  import core
  import collections
  import math
  import esir
  import esir/utils
  import esir/gen
  import esir/fonts
  import esir/repl-lib
  import ocdb/generator-utils
  import ocdb/land-patterns
  
;public defn make-pads (start-pos:String, start-side:Dir, 
;                       direction:String, n:Int, pad-x:Double, pad-y:Double,
;                       pad-pitch:Double, rows:Int, sides:Int, 
;                       vert-row-pitch:Double, hor-row-pitch:Double) :
;  inside pcb-package :
;    val row-size = 
;      ;if sides == 0 and n % rows == 0 :
;      ;  n / rows
;      if sides != 0 and n % sides % rows == 0 :
;        n / sides / rows
;      else :
;        fatal("make-pads only supports symmetric pad layouts")
;    val row-span = to-double(row-size - 1) * pitch
;    val x0 = switch(start-pos) :
;      "Left" : (- (row-span / 2.0)) 
;      "Right" : row-span / 2.0
;      "Center" : to-double(row-size % 2) * pitch / 2.0
;    if sides == 0 :

public defn make-two-pads (pad-x:Double, pad-y:Double, pitch:Double, 
                           court-w:Double, court-h:Double, f-silk:Shape,
                           pol-silk:Shape) :
  inside pcb-package :
    layer(Silkscreen("pol", Top)) = pol-silk 
    make-two-pads(pad-x, pad-y, pitch, court-w, court-h, f-silk)
    
public defn make-two-pads (pad-x:Double, pad-y:Double, pitch:Double,
                           court-w:Double, court-h:Double, f-silk:Shape) :
  inside pcb-package :
    layer(Silkscreen("f-silk", Top)) = f-silk
    make-two-pads(pad-x, pad-y, pitch, court-w, court-h)

public defn make-two-pads (pad-x:Double, pad-y:Double, pitch:Double,
                           court-w:Double, court-h:Double) :
  inside pcb-package :
    layer(Courtyard(Top)) = Rectangle(court-w, court-h)
    make-two-pads(pad-x, pad-y, pitch)

public defn make-two-pads (pad-x:Double, pad-y:Double, pitch:Double) :
  inside pcb-package :
    pad p[1] : {smd-pad(pad-y, pad-x)} at loc((- pitch) / 2.0, 0.0)
    pad p[2] : {smd-pad(pad-y, pad-x)} at loc(pitch / 2.0, 0.0)

public defn make-two-pads-offset (pad-x:Double, pad-y:Double, pitch:Double,
                                  offset:Double, court-w:Double, 
                                  court-h:Double, f-silk:Shape, 
                                  pol-silk:Shape) :
  inside pcb-package :
    layer(Silkscreen("pol", Top)) = pol-silk 
    make-two-pads-offset(pad-x, pad-y, pitch, offset, court-w, court-h, 
                         f-silk)
    
public defn make-two-pads-offset (pad-x:Double, pad-y:Double, pitch:Double,
                                  offset:Double, court-w:Double, 
                                  court-h:Double, f-silk:Shape) :
  inside pcb-package :
    layer(Silkscreen("f-silk", Top)) = f-silk
    make-two-pads-offset(pad-x, pad-y, pitch, offset, court-w, court-h)

public defn make-two-pads-offset (pad-x:Double, pad-y:Double, pitch:Double,
                                  offset:Double, court-w:Double, 
                                  court-h:Double) :
  inside pcb-package :
    layer(Courtyard(Top)) = Rectangle(court-w, court-h)
    make-two-pads-offset(pad-x, pad-y, pitch, offset)

public defn make-two-pads-offset (pad-x:Double, pad-y:Double, pitch:Double,
                                  offset:Double) :
  inside pcb-package :
    pad p[1] : {smd-pad(pad-y, pad-x)} at loc((offset - pitch), 0.0)
    pad p[2] : {smd-pad(pad-y, pad-x)} at loc(offset, 0.0)

public defn make-three-pads-offset (pad-x1:Double, pad-x2:Double, 
                                    pad-y1:Double, pad-y2:Double,
                                    hor-pitch:Double,
                                    hor-pitch-offset:Double, 
                                    vert-pitch:Double, court-w:Double, 
                                    court-h:Double, f-silk:Shape, 
                                    pol-silk:Shape) :
  inside pcb-package :
    layer(Silkscreen("pol", Top)) = pol-silk 
    make-three-pads-offset(pad-x1, pad-x2, pad-y1, pad-y2, hor-pitch, 
                           hor-pitch-offset, vert-pitch, court-w, court-h, 
                           f-silk)
    
public defn make-three-pads-offset (pad-x1:Double, pad-x2:Double, 
                                    pad-y1:Double, pad-y2:Double,
                                    hor-pitch:Double,
                                    hor-pitch-offset:Double, 
                                    vert-pitch:Double, court-w:Double, 
                                    court-h:Double, f-silk:Shape) :
  inside pcb-package :
    layer(Silkscreen("f-silk", Top)) = f-silk
    make-three-pads-offset(pad-x1, pad-x2, pad-y1, pad-y2, hor-pitch, 
                           hor-pitch-offset, vert-pitch, court-w, court-h)

public defn make-three-pads-offset (pad-x1:Double, pad-x2:Double, 
                                    pad-y1:Double, pad-y2:Double,
                                    hor-pitch:Double,
                                    hor-pitch-offset:Double, 
                                    vert-pitch:Double, court-w:Double, 
                                    court-h:Double) :
  inside pcb-package :
    layer(Courtyard(Top)) = Rectangle(court-w, court-h)
    make-three-pads-offset(pad-x1, pad-x2, pad-y1, pad-y2, hor-pitch, 
                           hor-pitch-offset, vert-pitch)

public defn make-three-pads-offset (pad-x1:Double, pad-x2:Double, 
                                    pad-y1:Double, pad-y2:Double,
                                    hor-pitch:Double, 
                                    hor-pitch-offset:Double,
                                    vert-pitch:Double) :
  inside pcb-package :
    pad p[1] : {smd-pad(pad-y1, pad-x1)} at loc((hor-pitch-offset - 
                                                 hor-pitch),
                                                vert-pitch / 2.0)
    pad p[2] : {smd-pad(pad-y1, pad-x1)} at loc((hor-pitch-offset - 
                                                 hor-pitch),
                                                (- (vert-pitch / 2.0)))
    pad p[3] : {smd-pad(pad-y2, pad-x2)} at loc(hor-pitch-offset, 0.0)

defn get-pin-order (start:Tuple<String>, direction:String) -> Tuple<Int> :
  switch([start[0], start[1], direction]) :
    ["Top", "Left", "clock"] : [1 2 4 3]
    ["Top", "Right", "clock"] : [4 1 3 2]
    ["Bottom", "Left", "clock"] : [2 3 1 4]
    ["Bottom", "Right", "clock"] : [3 4 2 1]
    ["Top", "Left", "a-clock"] : [1 4 2 3]
    ["Top", "Right", "a-clock"] : [2 1 3 4]
    ["Bottom", "Left", "a-clock"] : [4 3 1 2]
    ["Bottom", "Right", "a-clock"] : [3 2 4 1]
    ["Top", "Left", "wrap"] : [1 2 3 4]
    ["Top", "Right", "wrap"] : [2 1 4 3]
    ["Bottom", "Left", "wrap"] : [3 4 1 2]
    ["Bottom", "Right", "wrap"] : [4 3 2 1]
    else :
      fatal("Orientation of pins not supported")

public defn make-four-pads-offset (start:Tuple<String>, direction:String, 
                                   pad-x1:Double, pad-y1:Double, 
                                   hor-pitch:Double,
                                   hor-pitch-offset:Double, 
                                   vert-pitch:Double, court-w:Double, 
                                   court-h:Double, f-silk:Shape, 
                                   pol-silk:Shape) :
  inside pcb-package :
    layer(Silkscreen("pol", Top)) = pol-silk 
    make-four-pads-offset(start, direction, pad-x1, pad-y1, hor-pitch, 
                          hor-pitch-offset, vert-pitch, court-w, court-h, 
                          f-silk)
    
public defn make-four-pads-offset (start:Tuple<String>, direction:String, 
                                   pad-x1:Double, pad-y1:Double, 
                                   hor-pitch:Double,
                                   hor-pitch-offset:Double, 
                                   vert-pitch:Double, court-w:Double, 
                                   court-h:Double, f-silk:Shape) :
  inside pcb-package :
    layer(Silkscreen("f-silk", Top)) = f-silk
    make-four-pads-offset(start, direction, pad-x1, pad-y1, hor-pitch, 
                          hor-pitch-offset, vert-pitch, court-w, court-h)

public defn make-four-pads-offset (start:Tuple<String>, direction:String, 
                                   pad-x1:Double, pad-y1:Double, 
                                   hor-pitch:Double,
                                   hor-pitch-offset:Double, 
                                   vert-pitch:Double, court-w:Double, 
                                   court-h:Double) :
  inside pcb-package :
    layer(Courtyard(Top)) = Rectangle(court-w, court-h)
    make-four-pads-offset(start, direction, pad-x1, pad-y1, hor-pitch, 
                          hor-pitch-offset, vert-pitch)

public defn make-four-pads-offset (start:Tuple<String>, direction:String, 
                                   pad-x1:Double, pad-y1:Double, 
                                   hor-pitch:Double,
                                   hor-pitch-offset:Double, 
                                   vert-pitch:Double) :
  val pin-order = get-pin-order(start, direction)
  make-four-pads-offset(pin-order, pad-x1, pad-y1, hor-pitch, 
                        hor-pitch-offset, vert-pitch)

public defn make-four-pads-offset (pin-order:Tuple<Int>, pad-x1:Double, 
                                   pad-y1:Double, hor-pitch:Double,
                                   hor-pitch-offset:Double, 
                                   vert-pitch:Double, court-w:Double, 
                                   court-h:Double, f-silk:Shape, 
                                   pol-silk:Shape) :
  inside pcb-package :
    layer(Silkscreen("pol", Top)) = pol-silk 
    make-four-pads-offset(pin-order, pad-x1, pad-y1, hor-pitch, 
                          hor-pitch-offset, vert-pitch, court-w, court-h, 
                          f-silk)
    
public defn make-four-pads-offset (pin-order:Tuple<Int>, pad-x1:Double, 
                                   pad-y1:Double, hor-pitch:Double,
                                   hor-pitch-offset:Double, 
                                   vert-pitch:Double, court-w:Double, 
                                   court-h:Double, f-silk:Shape) :
  inside pcb-package :
    layer(Silkscreen("f-silk", Top)) = f-silk
    make-four-pads-offset(pin-order, pad-x1, pad-y1, hor-pitch, 
                          hor-pitch-offset, vert-pitch, court-w, court-h)

public defn make-four-pads-offset (pin-order:Tuple<Int>, pad-x1:Double, 
                                   pad-y1:Double, hor-pitch:Double,
                                   hor-pitch-offset:Double, 
                                   vert-pitch:Double, court-w:Double, 
                                   court-h:Double) :
  inside pcb-package :
    layer(Courtyard(Top)) = Rectangle(court-w, court-h)
    make-four-pads-offset(pin-order, pad-x1, pad-y1, hor-pitch, 
                          hor-pitch-offset, vert-pitch)

public defn make-four-pads-offset (pin-order:Tuple<Int>, pad-x1:Double, 
                                   pad-y1:Double, hor-pitch:Double, 
                                   hor-pitch-offset:Double,
                                   vert-pitch:Double) :
  inside pcb-package :
    pad p[pin-order[0]] : {smd-pad(pad-y1, pad-x1)} at 
                                            loc((hor-pitch-offset - 
                                                 hor-pitch),
                                                vert-pitch / 2.0)
    pad p[pin-order[1]] : {smd-pad(pad-y1, pad-x1)} at 
                                            loc((hor-pitch-offset - 
                                                 hor-pitch),
                                                (- (vert-pitch / 2.0)))
    pad p[pin-order[2]] : {smd-pad(pad-y1, pad-x1)} at 
                                            loc(hor-pitch-offset, 
                                                vert-pitch / 2.0)
    pad p[pin-order[3]] : {smd-pad(pad-y1, pad-x1)} at 
                                            loc(hor-pitch-offset, 
                                                (- (vert-pitch / 2.0)))

public defn make-four-pads (start:Tuple<String>, direction:String,
                            pad-x:Double, pad-y:Double, hor-pitch:Double, 
                            vert-pitch:Double, court-w:Double, 
                            court-h:Double, f-silk:Shape, pol-silk:Shape) :
  inside pcb-package :
    layer(Silkscreen("pol", Top)) = pol-silk 
    make-four-pads(start, direction, pad-x, pad-y, hor-pitch, vert-pitch, 
                   court-w, court-h, f-silk)

public defn make-four-pads (start:Tuple<String>, direction:String,
                            pad-x:Double, pad-y:Double, hor-pitch:Double, 
                            vert-pitch:Double, court-w:Double, 
                            court-h:Double, f-silk:Shape) :
  inside pcb-package :
    layer(Silkscreen("f-silk", Top)) = f-silk 
    make-four-pads(start, direction, pad-x, pad-y, hor-pitch, vert-pitch, 
                   court-w, court-h)

public defn make-four-pads (start:Tuple<String>, direction:String, 
                            pad-x:Double, pad-y:Double, hor-pitch:Double, 
                            vert-pitch:Double, court-w:Double, 
                            court-h:Double) :
  inside pcb-package :
    layer(Courtyard(Top)) = Rectangle(court-w, court-h)
    make-four-pads(start, direction, pad-x, pad-y, hor-pitch, vert-pitch)

public defn make-four-pads (start:Tuple<String>, direction:String, 
                            pad-x:Double, pad-y:Double, hor-pitch:Double, 
                            vert-pitch:Double) :
  val pin-order = get-pin-order(start, direction)
  make-four-pads(pin-order, pad-x, pad-y, hor-pitch, vert-pitch)

public defn make-four-pads (pin-order:Tuple<Int>, pad-x:Double, 
                            pad-y:Double, hor-pitch:Double, 
                            vert-pitch:Double, court-w:Double, 
                            court-h:Double, f-silk:Shape, pol-silk:Shape) :
  inside pcb-package :
    layer(Silkscreen("pol", Top)) = pol-silk 
    make-four-pads(pin-order, pad-x, pad-y, hor-pitch, vert-pitch, court-w,
                   court-h, f-silk)

public defn make-four-pads (pin-order:Tuple<Int>, pad-x:Double, 
                            pad-y:Double, hor-pitch:Double, 
                            vert-pitch:Double, court-w:Double, 
                            court-h:Double, f-silk:Shape) :
  inside pcb-package :
    layer(Silkscreen("f-silk", Top)) = f-silk 
    make-four-pads(pin-order, pad-x, pad-y, hor-pitch, vert-pitch, court-w,
                   court-h)

public defn make-four-pads (pin-order:Tuple<Int>, pad-x:Double, 
                            pad-y:Double, hor-pitch:Double, 
                            vert-pitch:Double, court-w:Double, 
                            court-h:Double) :
  inside pcb-package :
    layer(Courtyard(Top)) = Rectangle(court-w, court-h)
    make-four-pads(pin-order, pad-x, pad-y, hor-pitch, vert-pitch)

public defn make-four-pads (pin-order:Tuple<Int>, pad-x:Double, 
                            pad-y:Double, hor-pitch:Double, 
                            vert-pitch:Double) :
  inside pcb-package :
    for (l in grid-locs(2, 2, hor-pitch, vert-pitch), i in pin-order) do :
      pad p[i] : {smd-pad(pad-y, pad-x)} at l

public defn make-two-sided-pads (start:Tuple<String>, n:Int,
                                 pad-x:Double, pad-y:Double,
                                 hor-pitch:Double, pin-pitch:Double,
                                 court-w:Double, court-h:Double,
                                 f-silk:Shape, pol-silk:Shape) :
  inside pcb-package :
    layer(Silkscreen("pol", Top)) = pol-silk 
    make-two-sided-pads(start, n, pad-x, pad-y, hor-pitch, pin-pitch,
                        court-w, court-h, f-silk)
                        
public defn make-two-sided-pads (start:Tuple<String>, n:Int,
                                 pad-x:Double, pad-y:Double,
                                 hor-pitch:Double, pin-pitch:Double,
                                 court-w:Double, court-h:Double,
                                 f-silk:Shape) :
  inside pcb-package :
    layer(Silkscreen("f-silk", Top)) = f-silk 
    make-two-sided-pads(start, n, pad-x, pad-y, hor-pitch, pin-pitch,
                        court-w, court-h)

public defn make-two-sided-pads (start:Tuple<String>, n:Int,
                                 pad-x:Double, pad-y:Double,
                                 hor-pitch:Double, pin-pitch:Double,
                                 court-w:Double, court-h:Double) :
  inside pcb-package :
    layer(Courtyard(Top)) = Rectangle(court-w, court-h)
    make-two-sided-pads(start, n, pad-x, pad-y, hor-pitch, pin-pitch)

public defn make-two-sided-pads (start:Tuple<String>, n:Int, 
                                 pad-x:Double, pad-y:Double, 
                                 hor-pitch:Double, pin-pitch:Double) :
  inside pcb-package :
    val x0 = (- (hor-pitch / 2.0))
    val y0 = (to-double((n / 2) - 1) * pin-pitch) / 2.0
    val [left, right] = [loc(x0, y0, 0.0), loc((- x0), (- y0), 180.0)]
    val [l0, l1] = switch(start) :
      ["Top", "Left"] : [left, right]
      ["Bottom", "Right"] : [right, left]
      else :
        fatal("Orientation of pins not supported")
    val pin-row = to-list(col-locs(N, n / 2, pin-pitch))
    for (i in 0 to (n / 2), l in pin-row) do :
      pad p[i + 1] : {smd-pad(pad-y, pad-x)} at l0 * l
    for (i in (n / 2) to n, l in pin-row) do :
      pad p[i + 1] : {smd-pad(pad-y, pad-x)} at l1 * l

public defn make-convex-e-pads (n:Int, pad-x1:Double, pad-x2:Double,
                                pad-y:Double, hor-pitch:Double, 
                                pin-pitch:Double, w:Double
                                court-w:Double, court-h:Double,
                                f-silk:Shape, pol-silk:Shape) :
  inside pcb-package :
    layer(Silkscreen("pol", Top)) = pol-silk 
    make-convex-e-pads(n, pad-x1, pad-x2, pad-y, hor-pitch, pin-pitch, w,
                       court-w, court-h, f-silk)

public defn make-convex-e-pads (n:Int, pad-x1:Double, pad-x2:Double,
                                pad-y:Double, hor-pitch:Double, 
                                pin-pitch:Double, w:Double
                                court-w:Double, court-h:Double,
                                f-silk:Shape) :
  inside pcb-package :
    layer(Silkscreen("f-silk", Top)) = f-silk 
    make-convex-e-pads(n, pad-x1, pad-x2, pad-y, hor-pitch, pin-pitch, w,
                       court-w, court-h)

public defn make-convex-e-pads (n:Int, pad-x1:Double, pad-x2:Double,
                                pad-y:Double, hor-pitch:Double, 
                                pin-pitch:Double, w:Double
                                court-w:Double, court-h:Double) :
  inside pcb-package :
    layer(Courtyard(Top)) = Rectangle(court-w, court-h)
    make-convex-e-pads(n, pad-x1, pad-x2, pad-y, hor-pitch, pin-pitch, w)

                                
public defn make-convex-e-pads (n:Int, pad-x1:Double, pad-x2:Double,
                                pad-y:Double, hor-pitch:Double, 
                                pin-pitch:Double, w:Double) :
  inside pcb-package :
    val x0 = (- (hor-pitch / 2.0))
    val y0 = (w / 2.0) - (pad-x2 / 2.0)
    val y1 = (to-double((n / 2) - 3) * pin-pitch) / 2.0
    val [left, right] = [loc(x0, y1, 0.0), loc((- x0), (- y1), 180.0)]
    val pin-row = to-list(col-locs(N, (n / 2) - 2, pin-pitch))
    pad p[1] : {smd-pad(pad-y, pad-x1)} at loc(x0, y0, 0.0)
    for (i in 1 to ((n / 2) - 1), l in pin-row) do :
      pad p[i + 1] : {smd-pad(pad-y, pad-x2)} at left * l
    pad p[(n / 2)] : {smd-pad(pad-y, pad-x1)} at loc(x0, (- y0), 0.0)
    pad p[((n / 2) + 1)] : {smd-pad(pad-y, pad-x1)} at loc((- x0), (- y0),
                                                           180.0)
    for (i in ((n / 2) + 1) to (n - 1), l in pin-row) do :
      pad p[i + 1] : {smd-pad(pad-y, pad-x2)} at right * l
    pad p[n] : {smd-pad(pad-y, pad-x1)} at loc((- x0), y0, 180.0)

public defn make-four-sided-pads (start:Tuple<String>, m:Int, n:Int,
                                  pad-x:Double, pad-y:Double, 
                                  hor-pitch:Double, vert-pitch:Double,
                                  pin-pitch:Double, court-w:Double,
                                  court-h:Double, f-silk:Shape, 
                                  pol-silk:Shape) :
  inside pcb-package :
    layer(Silkscreen("pol", Top)) = pol-silk 
    make-four-sided-pads(start, m, n, pad-x, pad-y, hor-pitch, vert-pitch, 
                         pin-pitch, court-w, court-h, f-silk)

public defn make-four-sided-pads (start:Tuple<String>, m:Int, n:Int,
                                  pad-x:Double, pad-y:Double, 
                                  hor-pitch:Double, vert-pitch:Double,
                                  pin-pitch:Double, court-w:Double,
                                  court-h:Double, f-silk:Shape) :
  inside pcb-package :
    layer(Silkscreen("f-silk", Top)) = f-silk 
    make-four-sided-pads(start, m, n, pad-x, pad-y, hor-pitch, vert-pitch, 
                         pin-pitch, court-w, court-h)

public defn make-four-sided-pads (start:Tuple<String>, m:Int, n:Int,
                                  pad-x:Double, pad-y:Double, 
                                  hor-pitch:Double, vert-pitch:Double,
                                  pin-pitch:Double, court-w:Double,
                                  court-h:Double) :
  inside pcb-package :
    layer(Courtyard(Top)) = Rectangle(court-w, court-h)
    make-four-sided-pads(start, m, n, pad-x, pad-y, hor-pitch, vert-pitch, 
                         pin-pitch)
                                

public defn make-four-sided-pads (start:Tuple<String>, m:Int, 
                                  n:Int, pad-x:Double, pad-y:Double, 
                                  hor-pitch:Double, vert-pitch:Double,
                                  pin-pitch:Double) :
  inside pcb-package :
    val x0 = (- (hor-pitch / 2.0))
    val y0 = (to-double(n - 1) * pin-pitch) / 2.0
    val x1 = (to-double(m - 1) * pin-pitch) / (- 2.0)
    val y1 = (vert-pitch / (- 2.0))
    val [left, right] = [loc(x0, y0, 0.0), loc((- x0), (- y0), 180.0)]
    val [top, bottom] = [loc((- x1), (- y1), 180.0), loc(x1, y1, 0.0)]
    val m-row = to-list(row-locs(W, m, pin-pitch))
    val n-row = to-list(col-locs(N, n, pin-pitch))
    val n-pins = 2 * (m + n)
    ; TODO cleanup and add functions to reduce repetitive code
    val [l0, l1, l2, l3, row0, row1, p0, p1, p2, p3, w, h] = switch(start) :
      ["Top", "Left"] : [left, bottom, right, top, n-row, m-row,
                     0 to n, n to (n + m), (n + m) to ((2 * n) + m),
                     ((2 * n) + m) to (2 * (n + m)), pad-x, pad-y]
      ["Bottom", "Left"] : [bottom, right, top, left, m-row, n-row, 
                     0 to m, m to (m + n), (m + n) to ((2 * m) + n),
                     ((2 * m) + n) to (2 * (m + n)), pad-y, pad-x]
      ["Bottom", "Right"] : [right, top, left, bottom, n-row, m-row, 
                     0 to n, n to (n + m), (n + m) to ((2 * n) + m),
                     ((2 * n) + m) to (2 * (n + m)), pad-x, pad-y]
      ["Top", "Right"] : [top, left, bottom, right, m-row, n-row, 
                     0 to m, m to (m + n), (m + n) to ((2 * m) + n),
                     ((2 * m) + n) to n-pins, pad-y, pad-x]
      ["Left", "Center"] : 
        if n % 2 == 0 :
          [left, bottom, right, top, n-row, m-row,
          cat((n-pins - (n / 2)) to n-pins, 0 to (n / 2)),
          (n / 2) to ((n / 2) + m), 
          ((n / 2) + m) to ((n / 2) + m + n),
          ((n / 2) + m + n) to (n-pins - (n / 2)), pad-x, pad-y]
        else :
          fatal("Can't determine Center for an even number of pins")
      ["Bottom", "Center"] : 
        if m % 2 == 0 :
          [bottom, right, top, left, m-row, n-row,
          cat((n-pins - (m / 2)) to n-pins, 0 to (m / 2)),
          (m / 2) to ((m / 2) + n), 
          ((m / 2) + n) to ((m / 2) + n + m),
          ((m / 2) + n + m) to (n-pins - (m / 2)), pad-y, pad-x]
        else :
          fatal("Can't determine Center for an even number of pins")
      ["Right", "Center"] :
        if n % 2 == 0 :
          [right, top, left, bottom, n-row, m-row,
          cat((n-pins - (n / 2)) to n-pins, 0 to (n / 2)),
          (n / 2) to ((n / 2) + m), 
          ((n / 2) + m) to ((n / 2) + m + n),
          ((n / 2) + m + n) to (n-pins - (n / 2)), pad-x, pad-y]
        else :
          fatal("Can't determine Center for an even number of pins")
      ["Top", "Center"] : 
        if m % 2 == 0 :
          [top, left, bottom, right, m-row, n-row,
          cat((n-pins - (m / 2)) to n-pins, 0 to (m / 2)),
          (m / 2) to ((m / 2) + n), 
          ((m / 2) + n) to ((m / 2) + n + m),
          ((m / 2) + n + m) to (n-pins - (m / 2)), pad-y, pad-x]
        else :
          fatal("Can't determine Center for an even number of pins")
      else :
        fatal("Orientation of pins not supported")
    val pin-pad-h = smd-pad(w, h)
    val pin-pad-v = smd-pad(h, w)
    for (i in p0, l in row0) do :
      pad p[i + 1] : {pin-pad-v} at l0 * l
    for (i in p1, l in row1) do :
      pad p[i + 1] : {pin-pad-h} at l1 * l
    for (i in p2, l in row0) do :
      pad p[i + 1] : {pin-pad-v} at l2 * l
    for (i in p3, l in row1) do :
      pad p[i + 1] : {pin-pad-h} at l3 * l

;TODO make staggered bga and different pitches generator
;public defn make-bga-pads (
