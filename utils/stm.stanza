defpackage ocdb/stm:
  import core
  import collections
  import lang-utils
  import json
  import reader
  import jitx

;=================================================
;========== STM JSON -> Stanza Structs ===========
;=================================================

public defstruct STM :
  pin-properties: STMPinProperties
  bundles: Tuple<STMBundle>
  supports: Tuple<STMSupports>

public defstruct STMPinProperties :
  generic-pin: GenericPin
  power-pin: PowerPin
  rows: Tuple<STMPinProperties-Row>

public defstruct GenericPin :
  pin-name: String ;"generic-props",
  max-voltage: VoltageLimits
  rated-esd: Double

public defstruct PowerPin :
  pin-name: String ;"power-props",
  recommended-voltage: VoltageLimits

public defstruct VoltageLimits:
  min-val: Double
  max-val: Double
  nominal?: True|False ; false

;[BOOT[0]   | 1 | Left | generic-props | - ]
public defstruct STMPinProperties-Row :
  pin: String ;BOOT[0]
  pad: Double|String ;1
  side: Dir ;Left
  generic-props?: True|False ;true
  power-props?: True|False ;false

public defstruct STMBundle :
  name: String ;mybund

public defstruct STMSupports:
  bundle: STMSupportsBundle
  mappings: Tuple<STMSupportMapping>

public defstruct STMSupportsBundle:
  name: String ;mybund
  options: Tuple<String>

public defstruct STMSupportMapping :
  bundle-pin: String
  require: String|False
  pin: String

;=================================================
;=================== Printers ====================
;=================================================

defn lnprint-fields<?S> (o:OutputStream, s:?S, fields:Tuple<(S -> ?)>) :
  for item in map({_(s)}, fields) do :
    lnprint(o, item)

defn lnprint-fields-row<?S> (o:OutputStream, s:?S, fields:Tuple<(S -> ?)>) :
  lnprint(o, "")
  do(print{o, "%_ " % [_]}, map({_(s)}, fields))

defn lnprint-tuple-fields<?S> (o:OutputStream, s:?S, tuple-fields:Tuple<(S -> Tuple)>) :
  for item in map({_(s)}, tuple-fields) do :
    do(lnprint{o, _}, item)

defmethod print (o:OutputStream, s:STM) :
  val o2 = IndentedStream(o)
  print(o, "STM:")
  lnprint-fields(o2, s, [pin-properties])
  lnprint-tuple-fields(o2, s, [bundles, supports])

defmethod print (o:OutputStream, s:STMPinProperties) :
  val o2 = IndentedStream(o)
  print(o, "STMPinProperties:")
  lnprint-fields(o2, s, [generic-pin, power-pin])
  lnprint-tuple-fields(o2, s, [rows])

defmethod print (o:OutputStream, s:GenericPin) :
  val o2 = IndentedStream(o)
  print(o, "GenericPin:")
  lnprint-fields(o2, s, [pin-name, max-voltage, rated-esd])

defmethod print (o:OutputStream, s:PowerPin) :
  val o2 = IndentedStream(o)
  print(o, "PowerPin:")
  lnprint-fields(o2, s, [pin-name, recommended-voltage])

defmethod print (o:OutputStream, s:VoltageLimits) :
  val o2 = IndentedStream(o)
  print(o, "VoltageLimits:")
  lnprint-fields(o2, s, [min-val, max-val, nominal?])

defmethod print (o:OutputStream, s:STMPinProperties-Row) :
  val o2 = IndentedStream(o)
  print(o, "STMPinProperties-Row:")
  lnprint-fields-row(o2, s, [pin, pad, side, generic-props?, power-props?])

defmethod print (o:OutputStream, s:STMBundle) :
  val o2 = IndentedStream(o)
  print(o, "STMBundle:")
  lnprint-fields-row(o2, s, [name])

defmethod print (o:OutputStream, s:STMSupports) :
  val o2 = IndentedStream(o)
  print(o, "STMSupports:")
  lnprint-fields(o2, s, [bundle])
  lnprint-tuple-fields(o2, s, [mappings])

defmethod print (o:OutputStream, s:STMSupportsBundle) :
  val o2 = IndentedStream(o)
  print(o, "STMSupportsBundle:")
  lnprint-fields(o2, s, [name])
  lnprint-tuple-fields(o2, s, [options])

defmethod print (o:OutputStream, s:STMSupportMapping) :
  val o2 = IndentedStream(o)
  print(o, "STMSupportMapping:")
  lnprint-fields-row(o2, s, [bundle-pin, require, pin])

;=================================================
;================= Build Structs =================
;=================================================

;This function creates STMSupports from the "supports" section in the JSON.
defn create-supports (json:JSON) -> Tuple<STMSupports> :
  match((json as JObject)["supports"]) :
    (supports:Tuple<JObject>) :
      for support in supports map :
        ;Build a STMSupportsBundle.
        val supported-bundle = match(support["bundle"]) :
          (supported-bundle:JObject) :
            ;Read the bundle's name.
            val bundle-name = match(supported-bundle["name"]) :
              (bundle-name:String) : bundle-name
              (bundle-name) : fatal("Invalid Supported Bundle Name")
            ;Read the bundle's pin options.
            val bundle-options = match(supported-bundle["options"]) :
              (bundle-options:Tuple<String>) : bundle-options
              (bundle-options) : fatal("Invalid Supported Bundle Options")
            STMSupportsBundle(bundle-name, bundle-options)
        ;Build the collection of STMSupportMappings.
        val mappings = match(support["mappings"]) :
          (mappings:Tuple<JObject>) :
            for mapping in mappings map :
              ;Example map: bund.p => required-pin.q
              ;Read the name of the bundle pin (ex. "p")
              val bundle-pin = match(mapping["bundle-pin"]) :
                (bundle-pin:String) : bundle-pin
                (bundle-pin) : fatal("Invalid Mapping Bundle Pin")
              ;Read the name of the required pin (ex. "required-pin")
              val require = match(mapping["require"]) :
                (require:String|False) : require
                (require) : fatal("Invalid Mapping Require")
              ;Read the name of the mapped pin (ex. "q")
              val pin = match(mapping["pin"]) :
                (pin:String) : pin
                (pin) : fatal("Invalid Mapping Pin")
              STMSupportMapping(bundle-pin, require, pin)
          (mappings) : fatal("Invalid Support Mappings")
        ;Bring the bundle and mappings together to create one STMSupports
        STMSupports(supported-bundle, mappings)
    (supports) : fatal("Invalid Supports")

; This function creates a Tuple of STMBundle from the bundles field in the JSON
; JSON object can match many types. For example,
; match(json) :
;   (json:True) :
;   (json:False) :
;   ...
;   (json:Tuple<JSON>) :
;   (json:String) : ..
;   (json) : fatal("Invalid JSON")

defn create-bundles (json1:JSON) -> Tuple<STMBundle> :
  val bundles = Vector<STMBundle>()
  val json = json1 as JObject

  match(json["bundles"]) :
    (json:Tuple<JSON>) :
      ;Each name should be a String bundle name
      for name in json do :
        match(name:String) : add(bundles, STMBundle(name))
        else : fatal("Invalid JSON")
    (json) :
      fatal("Invalid JSON")
  
  to-tuple(bundles)

;This function creates a Tuple of PinProperties from the bundles field in the JSON
defn create-pin-properties (json1:JSON) -> STMPinProperties :
  val json = json1 as JObject
  val pin-prop = json["pin-properties"] as JObject

  val generic-pin1 = pin-prop["generic-pin"]
  var stm-gen-pin
  match(generic-pin1) :
    (gen-pin: JObject) :
      val name = match(gen-pin["name"]) :
        (name : String) : name
        (name) : fatal("Invalid Generic Pin Name")
      val rated-esd = match(gen-pin["rated-esd"]) :
        (rated-esd: Double) : rated-esd
        (rated-esd) : fatal("Invalid rated-esd")
      var max-voltage-data
      match(gen-pin["max-voltage"]) :
        (max-volt-data: JObject) :
          val min-volts = match(max-volt-data["min"]) :
            (min-volts-double:Double) : min-volts-double
            (min-volts) : fatal("Invalid max-voltage data")
          val max-volts = match(max-volt-data["max"]) :
            (max-volts-double:Double) : max-volts-double
            (max-volts) : fatal("Invalid max-voltage data")
          val nominal = match(max-volt-data["nominal"]) :
            (nominal:True) : nominal
            (nominal:False) : nominal
            (nominal) : fatal("Invalid nominal data")

          println("%_, %_, %_" % [min-volts, max-volts, nominal])
          max-voltage-data = VoltageLimits(min-volts, max-volts, nominal)
          println("%_, %_, %_" % [min-val(max-voltage-data), max-val(max-voltage-data), nominal?(max-voltage-data)])
        (max-volt-data) :
          fatal("Invalid JSON") 

      stm-gen-pin = GenericPin(name, max-voltage-data, rated-esd)
      println("%_, %_, %_" % [pin-name(stm-gen-pin), max-val(max-voltage(stm-gen-pin)), /rated-esd(stm-gen-pin)])


  val power-pin1 = pin-prop["power-pin"]
  var stm-pow-pin
  match(power-pin1) :
    (pow-pin: JObject) :
      val name = match(pow-pin["name"]) :
        (name : String) : name
        (name) : fatal("Invalid Power Pin Name")
      val recommended-volt-data = pow-pin["recommended-voltage"]
      var recommended-voltage-data

      match(recommended-volt-data) :
        (recommended-volt-data: JObject) :
          val min-volts = match(recommended-volt-data["min"]) :
            (min-volts-double:Double) : min-volts-double
            (min-volts) : fatal("Invalid recommended-voltage min data")
          val max-volts = match(recommended-volt-data["max"]) :
            (max-volts-double:Double) : max-volts-double
            (max-volts) : fatal("Invalid recommended-voltage max data")
          val nominal = match(recommended-volt-data["nominal"]) :
            (nominal:True) : nominal
            (nominal:False) : nominal
            (nominal) : fatal("Invalid nominal data")

          println("%_, %_, %_" % [min-volts, max-volts, nominal])
          recommended-voltage-data = VoltageLimits(min-volts, max-volts, nominal)
          println("%_, %_, %_" % [min-val(recommended-voltage-data), max-val(recommended-voltage-data), nominal?(recommended-voltage-data)])
        (recommended-volt-data) :
          fatal("Invalid JSON") 

      stm-pow-pin = PowerPin(name, recommended-voltage-data)
      println("%_, %_" % [pin-name(stm-pow-pin), max-val(recommended-voltage(stm-pow-pin))])

  val pin-properties = Vector<STMPinProperties-Row>()
  val pins = pin-prop["pins"]
  ;print(pins)
  match(pins) :
    (pins:Tuple<JObject>) :
      for pin-item in pins do :
        ;println(pin["pin"])
        val pin-name = match(pin-item["pin"]) :
          (pin-name:String) : pin-name
          (pin-name) : fatal("Invalid Pin Name")
        val pad-name = match(pin-item["pad"]) :
          (pad-double:Double) : pad-double
          (pad-str:String) : pad-str
          (pad-data) : fatal("Invalid Pad Value")
        val side = match(pin-item["side"]) :
          (side-val:String) : 
            switch(side-val) :
              "Up" : Up,
              "Down" : Down,
              "Left" : Left,
              "Right" : Right
          (side-val) : fatal("Invalid Pin Name")
        val power-props? = match(pin-item["power-pin?"]) :
          (power-val:True) : power-val
          (power-val:False) : power-val
          (power-val) : fatal("Invalid Power Value")
        val generic-props? = match(pin-item["generic-pin?"]) :
          (generic-val:True) : generic-val
          (generic-val:False) : generic-val
          (generic-val) : fatal("Invalid Generic Value")

        ;println(pin-name, pad-name, side, generic-props?, power-props?)
        add(pin-properties, STMPinProperties-Row(pin-name, pad-name, side, generic-props?, power-props?))
    (pins) :
      fatal("Invalid JSON")
 
  ;to-tuple(pin-properties)
  val stm-properties = STMPinProperties(stm-gen-pin, stm-pow-pin, to-tuple(pin-properties))
  println("%_, %_, %_" % [ pin-name(generic-pin(stm-properties)), pin-name(power-pin(stm-properties)), pin(rows(stm-properties)[0])])
  stm-properties

;=================================================
;==================== Testing ====================
;=================================================

val JSON-TEST-FILE-LIST = to-hashset<String> $ [
  "stm-test.json"
]

defn create-mcu-struct (file:String) -> STM :
  val input-json = parse $ slurp(file)
  val bundles = create-bundles(input-json)
  val supports = create-supports(input-json)
  val pin-properties = create-pin-properties(input-json)
  STM(pin-properties, bundles, supports)

defn main ():
  for file in JSON-TEST-FILE-LIST do :
    val mcu = create-mcu-struct(file)
    println(mcu)
main()