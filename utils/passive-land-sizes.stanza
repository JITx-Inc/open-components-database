#use-added-syntax(jitx, tests)
defpackage ocdb/passive-land-sizes:
  import core
  import collections
  import math
  import lang-utils
  import jitx
  import jitx/commands
  import ocdb/design-vars
  import ocdb/land-patterns
  import ocdb/tolerance

; A helper struct to contain the physical dimensions of a 
; passive 2-pin component.
public pcb-struct ocdb/passive-dimensions/PassiveDimensions:
  length:Toleranced,
  width:Toleranced,
  lead-length:Toleranced,

defmethod print (o:OutputStream, d:PassiveDimensions):
  print(o, "Dimensions(length:%_, width:%_, lead-length:%_)" % [length(d), width(d), lead-length(d)])

; Parse a part name to get its nominal dimensions. 
defn parse (part-name:String, imperial?:True|False) -> Dims:
  defn leading-zeros (s:String):
    val chars = to-seq(s)
    let loop (count:Int = 0): 
      switch(next(chars)):
        '0': loop(count + 1)
        else:
          count

  defn exponent (n-zeros:Int):
    ; FIXME do the math here.
    switch(n-zeros): 
      0:  0.0 when imperial? else -1.0
      1:  0.0 when imperial? else -1.0  
      2: -1.0 when imperial? else -2.0

  defn parse-str (str:String):
    to-double(str) as Double * pow(10.0, exponent(leading-zeros(str)))

  ; check preconditions
  if length(part-name) < 3 or length(part-name) > 6: 
    throw(Exception("Unsupported package name: %_." % [part-name]))
  
  for ch in part-name do:
    if not digit?(ch):
      throw(Exception("%_ is not a valid part name." % [part-name]))

  ; get the base value of the 
  val [nl, nw] = 
    switch(length(part-name)):
      3: [1, 2]
      4: [2, 2]
      5: [2, 3]
      6: [3, 3]

  ; split the string
  val length-str = part-name[0 to nl]
  val width-str  = part-name[nl to false]
  Dims(parse-str(length-str), parse-str(width-str))

; Convert mils to mm
public defn mil-to-mm (mil:Double) -> Double:
  mil * 0.0254

; Convert mm to mils
public defn mm-to-mil (mm:Double) -> Double:
  mm * 39.3701

; Convert dimensions in mils to mms
public defn mil-to-mm (d:Dims) -> Dims:
  Dims(mil-to-mm(x(d)), mil-to-mm(y(d)))

; Convert dimensions in mms to mils
public defn mm-to-mil (d:Dims) -> Dims:
  Dims(mm-to-mil(x(d)), mm-to-mil(y(d)))

;=======================================================================
;========================== Resistors ==================================
;=======================================================================

; Retrieve the "lead length" or x-dimension of the leads of a chip resistor, 
; given its package size.
;
; From https://b2b-api.panasonic.eu/file_stream/pids/fileversion/1242
defn resistor-lead-length (package-length-mm:Double) -> Toleranced:
  if      in-range?(Toleranced(0.4, 0.02), package-length-mm): Toleranced(0.13, 0.02)
  else if in-range?(Toleranced(0.6, 0.03), package-length-mm): Toleranced(0.23, 0.03)
  else if in-range?(Toleranced(1.0, 0.05), package-length-mm): Toleranced(0.35, 0.05)
  else if in-range?(Toleranced(1.6, 0.15), package-length-mm): Toleranced(0.45, 0.1)
  else if in-range?(Toleranced(2.0, 0.20), package-length-mm): Toleranced(0.60, 0.1)
  else if in-range?(Toleranced(3.2, 0.05, 0.20), package-length-mm): Toleranced(0.60, 0.1)
  else if in-range?(Toleranced(3.2, 0.2), package-length-mm):  Toleranced(0.60, 0.1)
  else if in-range?(Toleranced(4.5, 0.2), package-length-mm):  Toleranced(0.60, 0.1)
  else if in-range?(Toleranced(5.0, 0.2), package-length-mm):  Toleranced(0.60, 0.1)
  else if in-range?(Toleranced(6.4, 0.2), package-length-mm):  Toleranced(0.60, 0.1)
  else:
    ; This is a best guess, the lead length ~ 1/3rd of the package length with
    ; a manufacturing tolerance of +/- 15%. This is based on the values in the table
    ; above, and should be updated as the library matures. 
    tol%(0.15, max(0.33 * package-length-mm, 0.6), 0.15)
  
; Retrieve the tolerance on length/width given the package length in mm. This is
; a best guess, based on the tables above.
defn resistor-tolerance (package-length-mm:Double) -> Double:
  label<Double> return:
    for (base in [0.40, 0.60, 1.00, 1.60, 2.0, 3.2, 4.5, 5.0, 6.4], 
         tol  in [0.02, 0.03, 0.15, 0.20, 0.2, 0.2, 0.2, 0.2, 0.2]) do:
      if in-range?(Toleranced(base, tol), package-length-mm):
        return(tol)
    0.15 * package-length-mm

; Make a best guess at our resistor dimensions given the information we have available.
public defn resistor-dimensions (part-name:String, imperial?:True|False) -> PassiveDimensions:
  var dims: Dims = parse(part-name, imperial?)
  if imperial?:
    dims = mil-to-mm(dims)
  val lead-length = resistor-lead-length(x(dims))
  val tol = resistor-tolerance(x(dims))
  PassiveDimensions(
    Toleranced(x(dims), tol), 
    Toleranced(y(dims), tol),
    lead-length
  )

public pcb-landpattern chip-resistor-landpattern (part-name:String, imperial?:True|False):
  val dimensions = resistor-dimensions(part-name, imperial?)
  println("%_" % [dimensions])
  make-ipc-compliant-two-pin-landpattern(length(dimensions)
                                         width(dimensions)
                                         lead-length(dimensions)
                                         DensityLevelC
                                         imperial?)

;=======================================================================
;=========================== Tests =====================================
;=======================================================================
; Tests are inline in order to reference private functions in this 
; module.
deftest parse-imperial:
  for (part in ["1004", "0603", "0402", "01005", "1206"],
       expect in [[10.0, 4.0], [6.0, 3.0], [4.0, 2.0], [1.0, 0.5], [12.0, 6.0]]
      ) do:
    
    val [l!, w!] = expect
    val d = parse(part, true)
    #EXPECT(in-range?(Toleranced(l!, 0.01), x(d)))
    #EXPECT(in-range?(Toleranced(w!, 0.01), y(d)))

deftest parse-metric:
  for (part in ["104", "0603", "0402", "01005", "1206"],
       expect in [[0.1, 0.4], [0.6, 0.3], [0.4, 0.2], [0.1, 0.05], [1.2, 0.6]]
      ) do:
    
    val [l!, w!] = expect
    val d = parse(part, false)
    #EXPECT(in-range?(Toleranced(l!, 0.01), x(d)))
    #EXPECT(in-range?(Toleranced(w!, 0.01), y(d)))
