#use-added-syntax(jitx)
defpackage ocdb/utils/db-parts :
  import core
  import collections
  import json
  import math
  import lang-utils with:
    prefix(min-max) => lang-

  import jitx with :
    prefix(Resistor) => EModel-
    prefix(Capacitor) => EModel-
    prefix(Inductor) => EModel-
  import jitx/commands
  import jitx/errors

  import ocdb/utils/defaults
  import ocdb/utils/landpatterns
  import ocdb/utils/generator-utils
  import ocdb/utils/parts
  import ocdb/utils/property-structs
  import ocdb/utils/symbols
  import ocdb/utils/design-vars

public deftype Component
public defmulti x (component: Component) -> Double
public defmulti y (component: Component) -> Double
public defmulti area (component: Component) -> Double
public defmulti sellers (component: Component) -> Tuple<Seller>|False
public defmulti query-properties (component: Component) -> JObject|False
public defmulti resolved-price (component: Component) -> Double|False
public defmulti vendor-part-numbers (component: Component) -> Tuple<KeyValue<String, String>>
public defmulti to-jitx (component: Component) -> Instantiable
; The top-level Component includes queryable fields used in parametric queries.
; This inner component represents the actual ESIR-instantiable object, including symbols/landpattern.
public defmulti component (component: Component) -> ComponentCode

defmethod area (component: Component) -> Double :
  x(component) * y(component)

public defstruct Sourcing :
  price: Double|False
  minimum-quantity: Int
  stock: Int

;============================================================
;================= External data souring ====================
;============================================================

public pcb-struct ocdb/utils/db-parts/Seller :
  updated-at: String|False
  company-name: String
  resolved-price: Double
  offers: Tuple<SellerOffer>

public pcb-struct ocdb/utils/db-parts/SellerOffer :
  inventory-level: Int
  prices: Tuple<SellerOfferPrice>

public pcb-struct ocdb/utils/db-parts/SellerOfferPrice :
  quantity: Int
  converted-price: Double

defmethod print (o:OutputStream, s:SellerOfferPrice) : 
  print(o, "SellerOfferPrice(quantity = %_, converted-price = %_)" % [quantity(s), converted-price(s)])

;============================================================
;====================== Resistor ============================
;============================================================

public defstruct Resistor <: Component :
  ; Generic properties
  manufacturer: String
  mpn: String
  trust: String
  x: Double with: (as-method => true)
  y: Double with: (as-method => true)
  z: Double|False
  mounting: String
  rated-temperature: Toleranced|False
  case: String|False
  sourcing: Sourcing
  metadata: Tuple<KeyValue>
  ; Resistor specific properties
  type: String ; Type of resistor
  tolerance: MinMaxRange|False ; Guaranteed tolerance from manufacture (Ohm/Ohm)
  resistance: Double ; Nominal resistance (Ohm)
  composition: String|False ; Composition of resistor
  rated-power: Double|False ; Power dissipation limit as rated by manufacturer. One value, or PWL function (W | [degC, W])
  TCR: TCR|False ; Temperature coefficient of resistance (ohms/ohm*degC)
  sellers: Tuple<Seller>|False with: (as-method => true)
  query-properties: JObject|False with: (as-method => true)
  resolved-price: Double|False with: (as-method => true)
  component: ComponentCode with: (as-method => true)
  vendor-part-numbers: Tuple<KeyValue<String, String>> with: (as-method => true)

public defn delta-resistance (resistor: Resistor, temperature: Double) -> Double :
  val tcr = TCR(resistor) as TCR
  val ref-temp = reference-temperature(tcr)
  val coeff =
    if temperature >= ref-temp :
      positive(tcr)
    else :
      negative(tcr)

  (temperature - ref-temp) * coeff

public defn Resistor (raw-json: JObject) -> Resistor :
  val json = filter-json(raw-json)
  val [x, y, z] = parse-dimensions(json["dimensions"] as JObject)

  Resistor(json["manufacturer"] as String,
           json["mpn"] as String,
           json["trust"] as String,
           x,
           y,
           z,
           optional-mounting(json),
           parse-rated-temperature(json),
           optional-string(json, "case"),
           parse-sourcing(json),
           entries(json["metadata"] as JObject),
           ; Resistor specific properties
           json["type"] as String,  ; FIXME: remove type because it is redundant with mounting ? It is not pot, photo...
           parse-tolerance(json),
           json["resistance"] as Double,
           optional-string(json, "composition"),
           optional-double(json, "rated-power"),
           resistance-tcr(json),
           parse-sellers(json),
           parse-query-properties(json),
           optional-double(json, "resolved_price"),
           ComponentCode(json["component"] as JObject),
           parse-vendor-part-numbers(json))

defn resistance-tcr (json: JObject) -> TCR|False :
  val tcr-json = get?(json, "tcr")
  match(tcr-json: JObject) :
    ; reference temperature assumed to be 25 Cdeg as Digikey does not precise it in the component grids
    TCR(25., tcr-json["pos"] as Double, tcr-json["neg"] as Double)

public defstruct TCR :
  reference-temperature: Double
  positive: Double
  negative: Double

; ========================================================
; ======================= to-jitx ========================
; ========================================================

defmethod to-jitx (resistor: Resistor) -> Instantiable :
  val component = component(resistor)
  match(landpattern(component)) :
    (lp:LandPatternCode):
      ; If the landpattern is included, this part should have everything it needs.
      to-jitx(resistor, component)
    (c):
      ; Otherwise, fall back on the V1 deserializers, which inject everything for 2-pin passives.
      ; We still haven't migrated all the OCDB generative logic to the parts-db population script.
      pcb-component my-resistor :
        val manufacturer-string = manufacturer(resistor)
        match(manufacturer-string: String) :
          manufacturer = manufacturer-string

        mpn = mpn(resistor)
        datasheet = datasheet(component)
        val height = z(resistor)

        val description-string = lookup?(metadata(resistor), "description")
        match(description-string: String) :
          description = description-string

        port p : pin[1 through 2]
        val sym = resistor-sym()
        symbol = sym(p[1] => sym.p[1], p[2] => sym.p[2])
        val case = case(resistor)
        match(case: String) :
          if check-valid-rectangle-pkg-list(case) :
            val pkg = ipc-two-pin-landpattern(case, height)
            landpattern = pkg(p[1] => pkg.p[1], p[2] => pkg.p[2])
          else :  ; example: case = "Axial"
            val pkg = dummy-landpattern(2, [x(resistor) y(resistor)])
            landpattern = pkg(p[1] => pkg.p[1], p[2] => pkg.p[2])
        else :
          val pkg = dummy-landpattern(2, [x(resistor) y(resistor)])
          landpattern = pkg(p[1] => pkg.p[1], p[2] => pkg.p[2])

        emodel = EModel-Resistor(resistance(resistor),
                                emodel-pourcentage-tolerance(tolerance(resistor)),
                                double-or-unknown(rated-power(resistor)))
        reference-prefix = "R"

        ; Include parts-db component properties
        map(to-jitx, properties(component))
        val q = query-properties(resistor)
        match(q:JObject) :
          set-property(self, `query-properties, entries(q))

        ; spice :
        ;   "[R] <p[1]> <p[2]> <resistance>"

      my-resistor

; ========================================================
; ================== Resistor Accessors ==================
; ========================================================

public defn Resistor (user-properties:Tuple<KeyValue>) -> Resistor :
  Resistor(user-properties, [])

public defn Resistor (user-properties:Tuple<KeyValue>, exist:Tuple<String>) -> Resistor :
  Resistor(user-properties, exist, OPTIMIZE-FOR, OPERATING-TEMPERATURE)

public defn Resistor (user-properties:Tuple<KeyValue>, exist:Tuple<String>, sort:Tuple<String>, operating-temperature:Toleranced|False) -> Resistor :
  val query-properties = resistor-query-properties(user-properties, exist, sort, operating-temperature)
  PartsDBComponent(query-properties) as Resistor

public defn Resistors (user-properties:Tuple<KeyValue>, limit: Int) -> Tuple<Resistor> :
  val query-properties = resistor-query-properties(user-properties, [], OPTIMIZE-FOR, OPERATING-TEMPERATURE)
  PartsDBComponents(query-properties, limit) as Tuple<Resistor>

defn resistor-query-properties (user-properties:Tuple<KeyValue>,
                                exist:Tuple<String>,
                                sort:Tuple<String>,
                                operating-temperature:Toleranced|False) -> Tuple<KeyValue> :
  query-properties(user-properties,
                   exist,
                   sort,
                   operating-temperature,
                   "resistor",
                   true)

;============================================================
;======================== Look-ups ==========================
;============================================================

public defn look-up-resistors (attribute: String) -> Tuple :
  look-up-resistors(attribute, [])

public defn look-up-resistors (attribute: String, filter-properties:Tuple<KeyValue>) -> Tuple :
  look-up-resistors(attribute, filter-properties, [])

public defn look-up-resistors (attribute: String, filter-properties:Tuple<KeyValue>, exist:Tuple<String>) -> Tuple :
  look-up-resistors(attribute, filter-properties, exist, OPTIMIZE-FOR, OPERATING-TEMPERATURE)

public defn look-up-resistors (attribute: String,
                               filter-properties:Tuple<KeyValue>,
                               exist:Tuple<String>,
                               sort:Tuple<String>,
                               operating-temperature:Toleranced|False) -> Tuple :
  val user-properties = to-tuple $ cat(filter-properties, ["_distinct" => attribute])
  val query-properties = resistor-query-properties(user-properties, exist, sort, operating-temperature)

  query-distinct(query-properties, "look-up-resistors")

; ========================================================
; ========== query-available-resistance-values ===========
; ========================================================

public defn query-available-resistance-values (filter-properties:Tuple<KeyValue>, exist:Tuple<String>) -> Tuple<Double> :
  look-up-resistors("resistance", filter-properties, exist) as Tuple<Double>

;============================================================
;===================== Capacitor ============================
;============================================================

defstruct Capacitor <: Component :
  ; Generic properties
  manufacturer: String
  mpn: String
  trust: String
  x: Double with: (as-method => true)
  y: Double with: (as-method => true)
  z: Double|False
  mounting: String
  rated-temperature: Toleranced|False
  case: String|False
  sourcing: Sourcing
  metadata: Tuple<KeyValue>
  ; Capacitor specific properties
  type: String ; Type of resistor [“ceramic”, “film”, “electrolytic]
  tolerance: MinMaxRange|False ; Guaranteed tolerance from manufacturer (Farad/Farad)
  capacitance: Double ; Nominal capacitance (Farad)
  anode: String|False ; Anode material of electrolytic capacitor [“aluminum”, “tantalum”, “niobium-oxide”]
  electrolyte: String|False ; Electrolyte material of electrolytic capacitor [“polymer”, “manganese-dioxide”, “hybrid”, “non-solid”]
  temperature-coefficient: String|False ; Temperature coefficient code of capacitance [“X7R”, ...]
  esr: ESR|False
  rated-voltage: Double|False ; Maximum voltage rating from manufacturer (Volts)
  rated-voltage-ac: Double|False
  rated-current-pk: Double|False ; Maximum peak current rating from manufacturer (Amperes)
  rated-current-rms: Double|False ; Maximum rms current rating from manufacturer (Amperes)
  sellers: Tuple<Seller>|False with: (as-method => true)
  query-properties: JObject|False with: (as-method => true)
  resolved-price: Double|False with: (as-method => true)
  component: ComponentCode with: (as-method => true)
  vendor-part-numbers: Tuple<KeyValue<String, String>> with: (as-method => true)

defstruct ESR :
  value: Double
  frequency: Double|False

public defn Capacitor (raw-json: JObject) -> Capacitor :
  val json = filter-json(raw-json)
  val [x, y, z] = parse-dimensions(json["dimensions"] as JObject)

  Capacitor(json["manufacturer"] as String,
            json["mpn"] as String,
            json["trust"] as String,
            x,
            y,
            z,
            optional-mounting(json),
            parse-rated-temperature(json),
            optional-string(json, "case"),
            parse-sourcing(json),
            entries(json["metadata"] as JObject),
            ; Capacitor specific properties
            json["type"] as String,
            parse-tolerance(json),
            json["capacitance"] as Double,
            optional-string(json, "anode"),
            optional-string(json, "electrolyte"),
            capacitor-temperature-coefficient(json),
            parse-esr(json),
            optional-double(json, "rated-voltage"),
            optional-double(json, "rated-voltage-ac"),
            optional-double(json, "rated-current-pk"),
            optional-double(json, "rated-current-rms"),
            parse-sellers(json),
            parse-query-properties(json),
            optional-double(json, "resolved_price"),
            ComponentCode(json["component"] as JObject),
            parse-vendor-part-numbers(json))

defn parse-esr (json: JObject) -> ESR|False :
  val esr-json = get?(json, "esr")
  match(esr-json: Double) :
    ESR(esr-json, optional-double(json, "esr_frequency")) ; FIXME: regenerate DB with esr-frequency in snake-case ?

defn capacitor-temperature-coefficient (json: JObject) -> String|False :
  val temperature-coefficient-json = get?(json, "temperature-coefficient")
  match(temperature-coefficient-json: JObject) :
    temperature-coefficient-json["code"] as String

; ========================================================
; ======================= to-jitx ========================
; ========================================================

defmethod to-jitx (capacitor: Capacitor) -> Instantiable :
  val component = component(capacitor)
  match(landpattern(component)):
    (lp:LandPatternCode):
      ; If the landpattern is included, this part should have everything it needs.
      to-jitx(capacitor, component)
    (c):
      ; Otherwise, fall back on the V1 deserializers, which inject everything for 2-pin passives.
      ; We still haven't migrated all the OCDB generative logic to the parts-db population script.
      pcb-component my-capacitor :
        val manufacturer-string = manufacturer(capacitor)
        match(manufacturer-string: String) :
          manufacturer = manufacturer-string

        mpn = mpn(capacitor)
        datasheet = datasheet(component)

        val description-string = lookup?(metadata(capacitor), "description")
        match(description-string: String) :
          description = description-string

        val type-string = type(capacitor)
        val pol? = not (type-string == "ceramic" or type-string == "film")
        val esr = esr(capacitor)
        val case = case(capacitor)
        val height = match(z(capacitor)):
          (d:Double) : d
          (f:False) : 0.4
        if pol? :
          pin a
          pin c
          val sym = capacitor-sym(CapacitorPolarized)
          symbol = sym(a => sym.p[1], c => sym.p[2])

          match(case: String) :
            if check-valid-rectangle-pkg-list(case) :
              val pkg = ipc-two-pin-landpattern(case, height, pol?)
              landpattern = pkg(a => pkg.a, c => pkg.c)
            else :
              val pkg = dummy-landpattern(2, [x(capacitor) y(capacitor)])
              landpattern = pkg(a => pkg.p[1], c => pkg.p[2])
          else :
            val pkg = dummy-landpattern(2, [x(capacitor) y(capacitor)])
            landpattern = pkg(a => pkg.p[1], c => pkg.p[2])

          ; match(esr: ESR) :
          ;   val esr-value = value(esr)
          ;   spice :
          ;     "[C] <a> [tmp] <capacitance(capacitor)>"
          ;     "[R] [tmp] <c> <esr-value>"
          ; else :
          ;   spice :
          ;     "[C] <a> <c> <capacitance(capacitor)>"

        else :
          port p : pin[1 through 2]

          val sym = capacitor-sym()
          symbol = sym(p[1] => sym.p[1], p[2] => sym.p[2])

          match(case: String) :
            if check-valid-rectangle-pkg-list(case) :
              val pkg = ipc-two-pin-landpattern(case, height)
              landpattern = pkg(p[1] => pkg.p[1], p[2] => pkg.p[2])
            else :
              val pkg = dummy-landpattern(2, [x(capacitor) y(capacitor)])
              landpattern = pkg(p[1] => pkg.p[1], p[2] => pkg.p[2])
          else :
            val pkg = dummy-landpattern(2, [x(capacitor) y(capacitor)])
            landpattern = pkg(p[1] => pkg.p[1], p[2] => pkg.p[2])

          ; match(esr: ESR) :
          ;   val esr-value = value(esr)
          ;   spice :
          ;     "[C] <p[1]> [tmp] <capacitance(capacitor)>"
          ;     "[R] tmp <p[2]> <esr-value>"
          ; else :
          ;   spice :
          ;     "[C] <p[1]> <p[2]> <capacitance(capacitor)>"

        emodel = EModel-Capacitor(capacitance(capacitor),
                                emodel-pourcentage-tolerance(tolerance(capacitor)),
                                double-or-unknown(rated-voltage(capacitor)),
                                pol?,
                                UNKNOWN, ; FIXME: define low-esr? as below a certain threshold on the esr ?
                                string-or-unknown(temperature-coefficient(capacitor)),
                                UNKNOWN) ; FIXME: find out the dielectric information (look at type and anode?)
        reference-prefix = "C"

        ; Include parts-db component properties
        map(to-jitx, properties(component))
        val q = query-properties(capacitor)
        match(q:JObject) :
          set-property(self, `query-properties, entries(q))

      my-capacitor

; ========================================================
; ================ Capacitor Accessors ===================
; ========================================================

public defn Capacitor (user-properties:Tuple<KeyValue>) -> Capacitor :
  Capacitor(user-properties, [])

public defn Capacitor (user-properties:Tuple<KeyValue>, exist:Tuple<String>) -> Capacitor :
  Capacitor(user-properties, exist, OPTIMIZE-FOR, OPERATING-TEMPERATURE)

public defn Capacitor (user-properties:Tuple<KeyValue>, exist:Tuple<String>, sort:Tuple<String>, operating-temperature:Toleranced|False) -> Capacitor :
  val query-properties = capacitor-query-properties(user-properties, exist, sort, operating-temperature)
  PartsDBComponent(query-properties) as Capacitor

public defn Capacitors (user-properties:Tuple<KeyValue>, limit: Int) -> Tuple<Capacitor> :
  val query-properties = capacitor-query-properties(user-properties, [], OPTIMIZE-FOR, OPERATING-TEMPERATURE)
  PartsDBComponents(query-properties, limit) as Tuple<Capacitor>

defn capacitor-query-properties (user-properties:Tuple<KeyValue>,
                                exist:Tuple<String>,
                                sort:Tuple<String>,
                                operating-temperature:Toleranced|False) -> Tuple<KeyValue> :
  query-properties(user-properties,
                   exist,
                   sort,
                   operating-temperature,
                   "capacitor",
                   true)

;============================================================
;======================== Look-ups ==========================
;============================================================

public defn look-up-capacitors (attribute: String) -> Tuple :
  look-up-capacitors(attribute, [])

public defn look-up-capacitors (attribute: String, filter-properties:Tuple<KeyValue>) -> Tuple :
  look-up-capacitors(attribute, filter-properties, [])

public defn look-up-capacitors (attribute: String, filter-properties:Tuple<KeyValue>, exist:Tuple<String>) -> Tuple :
  look-up-capacitors(attribute, filter-properties, exist, OPTIMIZE-FOR, OPERATING-TEMPERATURE)

public defn look-up-capacitors (attribute: String,
                                filter-properties:Tuple<KeyValue>,
                                exist:Tuple<String>,
                                sort:Tuple<String>,
                                operating-temperature:Toleranced|False) -> Tuple :
  val user-properties = to-tuple $ cat(filter-properties, ["_distinct" => attribute])
  val query-properties = capacitor-query-properties(user-properties, exist, sort, operating-temperature)

  query-distinct(query-properties, "look-up-capacitors")

; ========================================================
; ======= query-available-capacitance-values =============
; ========================================================

public defn query-available-capacitance-values (filter-properties:Tuple<KeyValue>, exist:Tuple<String>) -> Tuple<Double> :
  look-up-capacitors("capacitance", filter-properties, exist) as Tuple<Double>

;============================================================
;====================== Inductor ============================
;============================================================

defstruct Inductor <: Component :
  ; Generic properties
  manufacturer: String
  mpn: String
  trust: String
  x: Double with: (as-method => true)
  y: Double with: (as-method => true)
  z: Double|False
  mounting: String
  rated-temperature: Toleranced|False
  case: String|False
  sourcing: Sourcing
  metadata: Tuple<KeyValue>
  ; Inductor specific properties
  type: String ; Type of inductor ["Molded", "Multilayer", "Planar", "Thick Film", "Toroidal", "Wirewound", "adjustable", "fixed"]
  tolerance: MinMaxRange|False ; Guaranteed tolerance from manufacture (Henry/Henry)
  inductance: Double ; Nominal inductance (Henry)
  material-core: String|False ; Composition of inductor [“ceramic”, “Ferrite”, ...]
  shielding: String|False ; Magnetic field status [“semi-shielded”, “shielded”, “unshielded”]
  current-rating: Double|False ; Maximum steady-state current rating from manufacture (Amperes)
  saturation-current: Double|False ; Percentage inductance drop (typ 20-30%) at peak currents (Amperes)
  dc-resistance: Double|False ; Nominal resistance (Ohm)
  quality-factor: Double|False ; Loss factor inverse - ratio between inductors resistance and inductance (ratio@freq)
  self-resonant-frequency: Double|False ; Frequency at which inductor impedance becomes very high / open circuit (freq in Hz)
  sellers: Tuple<Seller>|False with: (as-method => true)
  query-properties: JObject|False with: (as-method => true)
  resolved-price: Double|False with: (as-method => true)
  component: ComponentCode with: (as-method => true)
  vendor-part-numbers: Tuple<KeyValue<String, String>> with: (as-method => true)

public defn Inductor (raw-json: JObject) -> Inductor :
  val json = filter-json(raw-json)
  val [x, y, z] = parse-dimensions(json["dimensions"] as JObject)

  Inductor(json["manufacturer"] as String,
           json["mpn"] as String,
           json["trust"] as String,
           x,
           y,
           z,
           optional-mounting(json),
           parse-rated-temperature(json),
           optional-string(json, "case"),
           parse-sourcing(json),
           entries(json["metadata"] as JObject),
           ; Inductor specific properties
           json["type"] as String,
           parse-tolerance(json),
           json["inductance"] as Double,
           optional-string(json, "material-core"),
           optional-string(json, "shielding"),
           optional-double(json, "current-rating"),
           optional-double(json, "saturation-current"),
           optional-double(json, "dc-resistance"),
           optional-double(json, "quality-factor"),
           optional-double(json, "self-resonant-frequency"),
           parse-sellers(json),
           parse-query-properties(json),
           optional-double(json, "resolved_price"),
           ComponentCode(json["component"] as JObject),
           parse-vendor-part-numbers(json))

; ========================================================
; ======================== to-jitx =======================
; ========================================================

defmethod to-jitx (inductor: Inductor) -> Instantiable :
  val component = component(inductor)
  match(landpattern(component)):
    (lp:LandPatternCode):
      ; If the landpattern is included, this part should have everything it needs.
      to-jitx(inductor, component)
    (c):
      ; Otherwise, fall back on the V1 deserializers, which inject everything for 2-pin passives.
      ; We still haven't migrated all the OCDB generative logic to the parts-db population script.
      pcb-component my-inductor :
        val manufacturer-string = manufacturer(inductor)
        match(manufacturer-string: String) :
          manufacturer = manufacturer-string

        mpn = mpn(inductor)
        datasheet = datasheet(component)

        val description-string = lookup?(metadata(inductor), "description")
        match(description-string: String) :
          description = description-string

        port p : pin[1 through 2]
        val sym = inductor-sym()
        symbol = sym(p[1] => sym.p[1], p[2] => sym.p[2])
        val case = case(inductor)
        match(case: String) :
          if all?(digit?, to-seq(case)) :
            val pkg = ipc-two-pin-landpattern(case)
            landpattern = pkg(p[1] => pkg.p[1], p[2] => pkg.p[2])
          else :  ; example: case = "Axial"
            val pkg = dummy-landpattern(2, [x(inductor) y(inductor)])
            landpattern = pkg(p[1] => pkg.p[1], p[2] => pkg.p[2])
        else :
          val pkg = dummy-landpattern(2, [x(inductor) y(inductor)])
          landpattern = pkg(p[1] => pkg.p[1], p[2] => pkg.p[2])

        val inductance = inductance(inductor)
        emodel = EModel-Inductor(inductance,
                                emodel-pourcentage-tolerance(tolerance(inductor)),
                                double-or-unknown(current-rating(inductor)))
        reference-prefix = "L"

        ; Include parts-db component properties
        map(to-jitx, properties(component))
        val q = query-properties(inductor)
        match(q:JObject) :
          set-property(self, `query-properties, entries(q))

        spice :
          "[L] <p[1]> <p[2]> <inductance>"
      my-inductor

; ========================================================
; ================= Inductor Accessors ===================
; ========================================================

public defn Inductor (user-properties:Tuple<KeyValue>) -> Inductor :
  Inductor(user-properties, [])

public defn Inductor (user-properties:Tuple<KeyValue>, exist:Tuple<String>) -> Inductor :
  Inductor(user-properties, exist, OPTIMIZE-FOR, OPERATING-TEMPERATURE)

public defn Inductor (user-properties:Tuple<KeyValue>, exist:Tuple<String>, sort:Tuple<String>, operating-temperature:Toleranced|False) -> Inductor :
  val query-properties = inductor-query-properties(user-properties, exist, sort, operating-temperature)
  PartsDBComponent(query-properties) as Inductor

public defn Inductors (user-properties:Tuple<KeyValue>, limit: Int) -> Tuple<Inductor> :
  val query-properties = inductor-query-properties(user-properties, [], OPTIMIZE-FOR, OPERATING-TEMPERATURE)
  PartsDBComponents(query-properties, limit) as Tuple<Inductor>

; ========================================================
; =============== inductor-query-properties ==============
; ========================================================

defn inductor-query-properties (user-properties:Tuple<KeyValue>,
                                exist:Tuple<String>,
                                sort:Tuple<String>,
                                operating-temperature:Toleranced|False) -> Tuple<KeyValue> :
  query-properties(user-properties,
                   exist,
                   sort,
                   operating-temperature,
                   "inductor",
                   true)

;============================================================
;======================== Look-ups ==========================
;============================================================

public defn look-up-inductors (attribute: String) -> Tuple :
  look-up-inductors(attribute, [])

public defn look-up-inductors (attribute: String, filter-properties:Tuple<KeyValue>) -> Tuple :
  look-up-inductors(attribute, filter-properties, [])

public defn look-up-inductors (attribute: String, filter-properties:Tuple<KeyValue>, exist:Tuple<String>) -> Tuple :
  look-up-inductors(attribute, filter-properties, exist, OPTIMIZE-FOR, OPERATING-TEMPERATURE)

public defn look-up-inductors (attribute: String,
                               filter-properties:Tuple<KeyValue>,
                               exist:Tuple<String>,
                               sort:Tuple<String>,
                               operating-temperature:Toleranced|False) -> Tuple :
  val user-properties = to-tuple $ cat(filter-properties, ["_distinct" => attribute])
  val query-properties = inductor-query-properties(user-properties, exist, sort, operating-temperature)

  query-distinct(query-properties, "look-up-inductors")

public defn query-available-inductance-values (filter-properties:Tuple<KeyValue>, exist:Tuple<String>) -> Tuple<Double> :
  look-up-inductors("inductance", filter-properties, exist) as Tuple<Double>

;============================================================
;====================== Printer =============================
;============================================================

defmethod print (o:OutputStream, r:Resistor) :
  var items = [
    "mpn = %_" % [mpn(r)]
    "trust = %_" % [trust(r)]
    "(x, y, z) = (%,)" % [[x(r), y(r), z(r)]]
    "mounting = %_" % [mounting(r)]
    "rated-temperature = %_" % [rated-temperature(r)]
    "case = %_" % [case(r)]
    "type = %_" % [type(r)]
    "tolerance = %_" % [tolerance(r)]
    "resistance = %_" % [resistance(r)]
    "composition = %_" % [composition(r)]
    "rated-power = %_" % [rated-power(r)]
    "TCR = %_" % [TCR(r)]
    "sourcing = %_" % [sourcing(r)]
    "metadata = %_" % [indented-list(metadata(r))]]

  match(sellers(r), resolved-price(r)) :
    (s: Tuple<Seller>, p: Double) :
      items = cat(items, ["sellers = %_" % [indented-list(s)]
                          "resolved-price = %_" % [p]])
    (s: Tuple<Seller>, p: False) :
      items = cat(items, ["sellers = %_" % [indented-list(s)]])
    (s: False, p: False): false

  print(o, "Resistor(%_)" % [indented-list(items)])

defmethod print (o:OutputStream, r:Capacitor) :
  var items = [
    "mpn = %_" % [mpn(r)]
    "trust = %_" % [trust(r)]
    "(x, y, z) = (%,)" % [[x(r), y(r), z(r)]]
    "mounting = %_" % [mounting(r)]
    "rated-temperature = %_" % [rated-temperature(r)]
    "case = %_" % [case(r)]
    "type = %_" % [type(r)]
    "tolerance = %_" % [tolerance(r)]
    "capacitance = %_" % [capacitance(r)]
    "anode = %_" % [anode(r)]
    "electrolyte = %_" % [electrolyte(r)]
    "temperature-coefficient = %_" % [temperature-coefficient(r)]
    "esr = %_" % [esr(r)]
    "rated-voltage = %_" % [rated-voltage(r)]
    "rated-voltage-ac = %_" % [rated-voltage-ac(r)]
    "rated-current-pk = %_" % [rated-current-pk(r)]
    "rated-current-rms = %_" % [rated-current-rms(r)]
    "sourcing = %_" % [sourcing(r)]
    "metadata = %_" % [indented-list(metadata(r))]]

  match(sellers(r), resolved-price(r)) :
    (s: Tuple<Seller>, p: Double) :
      items = cat(items, ["sellers = %_" % [indented-list(s)]
                          "resolved-price = %_" % [p]])
    (s: Tuple<Seller>, p: False) :
      items = cat(items, ["sellers = %_" % [indented-list(s)]])
    (s: False, p: False): false

  print(o, "Capacitor(%_)" % [indented-list(items)])

defmethod print (o:OutputStream, r:Inductor) :
  var items = [
    "mpn = %_" % [mpn(r)]
    "trust = %_" % [trust(r)]
    "(x, y, z) = (%,)" % [[x(r), y(r), z(r)]]
    "mounting = %_" % [mounting(r)]
    "rated-temperature = %_" % [rated-temperature(r)]
    "case = %_" % [case(r)]
    "type = %_" % [type(r)]
    "tolerance = %_" % [tolerance(r)]
    "inductance = %_" % [inductance(r)]
    "material-core = %_" % [material-core(r)]
    "shielding = %_" % [shielding(r)]
    "current-rating = %_" % [current-rating(r)]
    "saturation-current = %_" % [saturation-current(r)]
    "dc-resistance = %_" % [dc-resistance(r)]
    "quality-factor = %_" % [quality-factor(r)]
    "self-resonant-frequency = %_" % [self-resonant-frequency(r)]
    "sourcing = %_" % [sourcing(r)]
    "metadata = %_" % [indented-list(metadata(r))]]

  match(sellers(r), resolved-price(r)) :
    (s: Tuple<Seller>, p: Double) :
      items = cat(items, ["sellers = %_" % [indented-list(s)]
                          "resolved-price = %_" % [p]])
    (s: Tuple<Seller>, p: False) :
      items = cat(items, ["sellers = %_" % [indented-list(s)]])
    (s: False, p: False): false

  print(o, "Inductor(%_)" % [indented-list(items)])

defmethod print (o:OutputStream, r:MinMaxRange) :
  print(o, "MinMaxRange(min=%_, max=%_)" % [min(r), max(r)])

defmethod print (o:OutputStream, r:TCR) :
  print(o, "TCR(positive=%_, negative=%_)" % [positive(r), negative(r)])

defmethod print (o:OutputStream, esr:ESR) :
  print(o, "ESR(value=%_, frequency=%_)" % [value(esr), frequency(esr)])

defmethod print (o:OutputStream, s:Sourcing) :
  print(o, "ESR(price=%_, minimum-quantity=%_, stock=%_)" % [price(s), minimum-quantity(s), stock(s)])

defmethod print (o:OutputStream, s:Seller) :
  val items = [
    "updated-at = %_" % [updated-at(s)]
    "company-name = %_" % [company-name(s)]
    "resolved-price = %_" % [resolved-price(s)]
    "offers = (%_)" % [indented-list(offers(s))]]
  print(o, "Seller(%_)" % [indented-list(items)])

defmethod print (o:OutputStream, s:SellerOffer) :
  val items = [
    "inventory-level = %_" % [inventory-level(s)]
    "prices = (%_)" % [indented-list(prices(s))]]
  print(o, "SellerOffer(%_)" % [indented-list(items)])

public defn indented-list (items:Seqable) :
  new Printable :
    defmethod print (o:OutputStream, this) :
      val o2 = IndentedStream(o)
      do(lnprint{o2, _}, items)


;============================================================
;=================== Parsing utils ==========================
;============================================================

defn filter-json (json: JObject) :
  ; we remove metadata.qty and metadata.factory-stock as they seem to be deprecated attributes (always 0)
  JObject $
    for kv in entries(json) map :
      if key(kv) == "metadata":
        val metadata-json = value(kv) as JObject
        key(kv) => JObject $ to-tuple $
          for metadata-kv in entries(metadata-json) filter :
            not contains?(["qty", "factory-stock"], key(metadata-kv))
      else :
        kv

public defn parse-dimensions (dimensions: JObject) -> [Double, Double, Double|False] :
  [dimensions["x"] as Double, dimensions["y"] as Double, optional-double(dimensions, "z")]

defn optional-string (json: JObject, field: String) -> String|False :
  val j = get?(json, field)
  j as String when not (j is False or j is JNull)

public defn optional-double (json: JObject, field: String) -> Double|False :
  val j = get?(json, field)
  j as Double when not (j is False or j is JNull)

public pcb-struct ocdb/utils/db-parts/MinMaxRange :
  min: Double
  max: Double

public defn parse-rated-temperature (json: JObject) -> Toleranced|False :
  val rated-temperature-json = get?(json, "rated-temperature")
  match(rated-temperature-json: JObject) :
    min-max(rated-temperature-json["min"] as Double, rated-temperature-json["max"] as Double)

defn parse-tolerance (json: JObject) -> MinMaxRange|False :
  val tolerance-json = get?(json, "tolerance")
  match(tolerance-json: JObject) :
      MinMaxRange(tolerance-json["min"] as Double, tolerance-json["max"] as Double)

public defn parse-sourcing (json: JObject) -> Sourcing :
  ; minimum-quantity and stock are float in MongoDB even though the python scraper do gives python ints to pymongo.
  Sourcing(optional-double(json, "price"), to-int(json["minimum_quantity"] as Double), to-int(json["stock"] as Double))

defn emodel-pourcentage-tolerance (value: MinMaxRange|False) -> Double|UNKNOWN :  ; FIXME: Tolerance minmax range not handled properly but emodel is going depricated
  match(value: MinMaxRange) :
    100. * max(value)
  else:
    UNKNOWN

defn double-or-unknown (value: Double|False) :
  match(value: Double) :
    value
  else:
    UNKNOWN

defn string-or-unknown (value: String|False) :
  match(value: String) :
    value
  else:
    UNKNOWN

public defn parse-sellers (json: JObject) -> Tuple<Seller>|False:
  defn int (j: JSON):
    to-int(j as Double)

  val json-sellers = get?(json, "sellers")

  if json-sellers is-not False :
    for json-seller in json-sellers as Tuple<JObject> map :
      val updated-at = match(get?(json-seller, "updated_at")) :
        (s:String) : s
        (_) : false
      Seller{updated-at, json-seller["company_name"] as String, json-seller["resolved_price"] as Double, _} $
        for json-offer in json-seller["offers"] as Tuple<JObject> map :
          SellerOffer{int(json-offer["inventory_level"]), _} $
            for json-price in json-offer["prices"] as Tuple<JObject> map :
              SellerOfferPrice(int(json-price["quantity"]), json-price["converted_price"] as Double)

public defn parse-query-properties (json: JObject) -> JObject|False:
  val j = get?(json, "query-properties")
  match(j:JObject) : j
  else : false

defn optional-mounting (json: JObject) -> String :
  match(get?(json, "mounting")) :
    (s:String) : s
    (_) : ""

defn parse-vendor-part-numbers (json: JObject) -> Tuple<KeyValue<String, String>> :
  match(get?(json, "vendor_part_numbers")) :
    (j:JObject) : VendorPartNumbers(j)
    (_) : []

defn set-properties-for-vendor-part-numbers (component: Component) :
  for vpn-kv in vendor-part-numbers(component) do :
    val vendor = key(vpn-kv)
    val prop-key = to-symbol $ append("vendor_part_numbers.", vendor)
    val vendor-part-number = value(vpn-kv)
    set-property(self, prop-key, vendor-part-number)

;============================================================
;===================== Other utils ==========================
;============================================================

; FIXME: add to collections.stanza with hashset-union used in query.stanza ?
; Behaviour: to-tuple $ hashtable-union $ [["category" => "microcontroller"], ["c" => 2], ["category" => "qwerty"]] -> ["c" => 2 "category" => "qwerty"]
defn hashtable-union<K, V> (hs:Seqable<Seqable<KeyValue<K&Equalable&Hashable, V>>>) -> HashTable<K, V> :
  to-hashtable<K, V>(cat-all(hs))

public defn query-properties (user-properties:Tuple<KeyValue>,
                              exist:Tuple<String>,
                              sort:Tuple<String>,
                              operating-temperature:Toleranced|False,
                              category: String,
                              sourcing?: True|False) -> Tuple<KeyValue> :
  val optional-properties =
    generate<KeyValue<String, ?>> :
      ; Part sourcing parameters: if they exist, sourcing data will be used
      if sourcing? :
        val vendors = bom-vendors()
        ; If we want to optimize on cost, we have to put either _stock or _sellers in the query so that the sourcing data is used in the server
        val sort-on-price = length(sort) >= 1 and contains?(["price", "cost", "-price", "-cost"], sort[0])

        yield("_stock" => DESIGN-QUANTITY) when DESIGN-QUANTITY > 0 or sort-on-price
        yield("_sellers" => vendors) when call?<Tuple>({not empty?(_)}, vendors)

      ; Other design parameters
      yield("_sort" => sort) when not empty?(sort)
      yield("_exist" => exist) when not empty?(exist)
      match(operating-temperature:Toleranced):
        yield("max-rated-temperature.min" => min-value(operating-temperature))
        yield("min-rated-temperature.max" => max-value(operating-temperature))

  ; `user-properties` override default properties
  to-tuple $ hashtable-union<String, ?> $ [["category" => category],
                                           optional-properties,
                                           user-properties]

public defn query-distinct (query-properties: Tuple<KeyValue<String, ?>>, callee: String) -> Tuple :
  ; 1000 is the maximum number of values that the JITX server is allowed to return at once
  val values = dbquery(query-properties, 1000) as Tuple

  if length(values) == 1000 :
    print("[WARNING] `%_` returned the maximum allowed of 1000 values. " % [callee])
    println("The result does not contain all available values for:")
    do(println{IndentedStream(current-output-stream()), _}, query-properties)

  values

public defn dbquery-first-allow-non-stock (args: Tuple<KeyValue<String, Tuple<String>|Tuple<Double>|String|Double|Int>>) -> JSON :
  try :
    dbquery-first(args)
  catch (e:NoComponentMeetingRequirements) :
    if ALLOW-NON-STOCK :
      println("[WARNING] %_" % [to-string(e)])

      ; Do not check stock for this out-of-stock component by
      ; removing "_stock" and "min-stock and retry
      val args2 = to-tuple $ for entry in args filter :
                      (key(entry) != "min-stock") and (key(entry) != "_stock")
      dbquery-first(args2)
    else :
      throw(e)
