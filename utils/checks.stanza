#use-added-syntax(jitx)
defpackage ocdb/checks:
  import core
  import collections
  import math
  import jitx
  import jitx/commands
  import ocdb/defaults
  import ocdb/space-derating
  import ocdb/generator-utils
  import ocdb/property-structs
  import ocdb/design-vars
  import ocdb/tolerance

; #CHECK(
;   condition = p-props is GenericPin,                    ; A boolean check                     (True|False)                       
;   name = "Generic Pin",                                 ; short name for the check category   (Printable)
;   description = "Checks the voltage applied to pins",   ; The description of the pcb check    (Printable)
;   category = "pin-check",                               ; Category for the check              (Printable)
;   subcheck-description = "sub-check detail description",; The description of the sub check    (Printable)
;   pass-message = "pass printable %_" % [ref(p)],        ; What is printed if the check passes (Printable)
;   fail-message = "fail printable %_ " % [ref(p)],       ; What is printed if the check fails  (Printable)
;   ; locators = [p]                                        ; Locators                            (Tuple<JITXObject|JITXDef>)
; )


; ==== Check convenience functions ===
; ====================================

public defn check-design (module:JITXObject):
  inside pcb-module:
    for i in component-instances(module) do :
      if not (has-property?(i.DNP) or has-property?(i.do-not-populate) or has-property?(i.dnp)) :
        check rated-temperature(i)
        if has-property?(i.capacitance) :
          check capacitor-component(i)
        if has-property?(i.resistance) :
          check resistor-component(i)

        for p in pins(i) do :
          if has-property?(p.generic-pin) :
            check generic-pin(p)
          if has-property?(p.power-pin) :
            check power-pin(p)
          if has-property?(p.reset-pin) :
            check reset-pin(p)

    check io(module)
    check-all-landpatterns(module)

defn get-other-pin (comp:JITXObject,  p:JITXObject) :
  for ps in pins(comp) find! :
    ps != p

public pcb-check within? (t:Toleranced, value:Toleranced) :
  val name = "Within Check"
  val description = "Check that a value is within a given range"
  val category = "value-check"
  #CHECK(
    condition =            in-range?(t, value),
    name =                 "Within Check",
    description =          "Check that a value is within a given range",
    category =             "value-check"
    subcheck-description = "Check that a value is within a given range"
    pass-message =         "Value %_ to %_ is within the range of %_ to %_" % [min-value(t) max-value(t) min-value(value) max-value(value)]
    fail-message =         "Value %_ to %_ is not within the range of %_ to %_" % [min-value(t) max-value(t) min-value(value) max-value(value)]
    ; locators =             [t value]
    )

public pcb-check rated-temperature (component:JITXObject):
  val name = "Rated temperature check"
  val description = "Check rated temperatures for components versus design constraints"
  val category = "rated-temperature"
  ; println("%_ check temp-rating" % [ref(component)])
  #CHECK(
    condition =            has-property?(component.rated-temperature),
    name =                 "Rated temperature check"
    description =          "Check rated temperatures for components versus design constraints"
    category =             "rated-temperature"
    subcheck-description = "Check rated temperature of component versus design constraints",
    pass-message =         "%_ has a property for rated-temperature of %_C" % [ref(component) property(component.rated-temperature)],
    fail-message =         "%_ does not have a property for rated-temperature" % [ref(component)],
    ; locators =             [component]
  )
    ; {
    ;   type: "instance-of-component"
    ;   info: {
    ;     file: "myfile.stanza"
    ;     line: 18
    ;     column: 20
    ;   }
    ; }

  val temp = operating-temperature(property(component.rated-temperature))
  ; println("Rating %_" % [temp])
  #CHECK(
    condition =            in-range?(temp, OPERATING-TEMPERATURE[0]),
    name =                 "Rated temperature check"
    description =          "Check rated temperatures for components versus design constraints"
    category =             "rated-temperature"
    subcheck-description = "Check rated temperature (low) of component versus design constraints",
    pass-message =         "%_ has an acceptable lower operating temperature versus design target (%_C <= %_C)" % [ref(component), temp, OPERATING-TEMPERATURE[0]],
    fail-message =         "%_ does not have an acceptable lower operating temperature versus design target (%_C > %_C)" % [ref(component), temp, OPERATING-TEMPERATURE[0]],
    ; locators =             [component]
  )
  #CHECK(
    condition =            in-range?(temp, OPERATING-TEMPERATURE[1]),
    name =                 "Rated temperature check"
    description =          "Check rated temperatures for components versus design constraints"
    category =             "rated-temperature"
    subcheck-description = "Check rated temperature (high) of component versus design constraints",
    pass-message =         "%_ has higher operating temperature that is compatible with the design target(%_C >= %_C)" % [ref(component), temp, OPERATING-TEMPERATURE[1]],
    fail-message =         "%_ does not have an acceptable higher operating temperature versus design target (%_C < %_C)" % [ref(component), temp, OPERATING-TEMPERATURE[1]],
    ; locators =             [component]  
  )

public pcb-check io (module:JITXObject) :

  val name = "IO pin checks"
  val description = "Check io pin properties"
  val category = "pin-check"
  val pins = to-tuple(seq-cat(pins, component-instances(module)))
  var net-pins = []
  for p1 in pins do :
    if (has-property?(p1.no-connect)) :
      net-pins = to-tuple(filter({connected?([p1, _])}, pins))
      #CHECK(
        condition =            length(net-pins) > 1,
        name =                 "IO pin checks"
        description =          "Check io pin properties"
        category =             "pin-check"
        subcheck-description = "Check that no-connect pads are not connected",
        pass-message =         "Pin %_ is marked no-connect and is correctly not connected" % [ref(p1)],
        fail-message =         "Pin %_ is marked no-connect and is incorrectly connected to other pins" % [ref(p1)],
        ; locators =             [p1]
      )
    ; Look for Digital inputs\
    if (has-property?(p1.digital-output) or has-property?(p1.digital-io)) :
      ; Get all pins on the net
      net-pins = to-tuple(filter({connected?([p1, _])}, pins))
      val out-pins = to-tuple(filter({has-property?(_.digital-output)}, net-pins))
      val io-pins  = to-tuple(filter({has-property?(_.digital-io)}, net-pins))
      ; val in-pins  = to-tuple(filter({has-property?(_.digital-input)}, net-pins))
      ; Check outputs against every pin
      for out-p in cat(out-pins, io-pins) do :
        #CHECK(
          condition =            (has-property?(out-p.digital-output) or has-property?(out-p.digital-io)),
          name =                 "IO pin checks"
          description =          "Check io pin properties"
          category =             "pin-check"
          subcheck-description = "Verify output or i-o pins have the correct digital-output or digital-io property",
          pass-message =         "Output or I/O pin %_ has the correct digital-output or digital-io property attached" % [ref(out-p)],
          fail-message =         "Output or I/O pin %_ does not have the correct digital-output or digital-io property attached" % [ref(out-p)],
          ; locators =             [out-p]
        )
        val o = 
          if has-property?(out-p.digital-output) : driver(property(out-p.digital-output))
          else if has-property?(out-p.digital-io) : driver(property(out-p.digital-io))
          else : false

        ; println("Out %_ is %_" % [ref(out-p) o])
        ; for n in net-pins do: println(ref(n))

        if (o is CMOSOutput or o is TTLOutput) :
          for in-p in net-pins do :
            if in-p != out-p :
              ; println("checking %_ vs %_" % [ref(out-p) ref(in-p)])
              check-single-push-pull-levels(out-p, in-p)

        match(o:OpenCollector) :
          ; println("checking %_ as OpenCollector" % [ref(out-p)])
          var is-open-collector-ok? = false
          for p in net-pins do :
            val myinst = containing-instance(p) as JITXObject
            if has-property?(myinst.resistance) :
              val high-pin = get-other-pin(myinst, p)
              if has-property?(high-pin.rail-voltage):
                val rail-voltage = property(high-pin.rail-voltage)
                ; Valid open-collector nets have pull up resistors
                is-open-collector-ok? = true
                val i = rail-voltage / property(myinst.resistance)
                #CHECK(
                  condition =            i < iol(o),
                  name =                 "IO pin checks"
                  description =          "Check io pin properties"
                  category =             "pin-check"
                  subcheck-description = "Check open collector pin sink current requirement versus resistance specification",
                  pass-message =         "Open collector pin %_ current sink specification %_A satisfies the design requirement %_A" % [ref(p),iol(o),i],
                  fail-message =         "Open collector pin %_ current specification %_A does not satisfy the design requirement %_A" % [ref(p),iol(o),i],
                  ; locators =             [p]
                )
                for p in net-pins do :
                  if has-property?(p.digital-input) or has-property?(p.digital-io) :
                    val vih-v = 
                      if has-property?(p.digital-input) : vih(property(p.digital-input))
                      else if has-property?(p.digital-io) : vih(property(p.digital-io))
                    #CHECK(
                      condition =            rail-voltage > vih-v,
                      name =                 "IO pin checks"
                      description =          "Check io pin properties"
                      category =             "pin-check"
                      subcheck-description = "Check power supply rail is higher than the vih pin specification",
                      pass-message =         "Input pin %_ vih specification %_V is correctly lower than the power supply rail %_V" % [ref(p),vih-v,rail-voltage],
                      fail-message =         "Input pin %_ vih specification %_V is incorrectly higher than the power supply rail %_V" % [ref(p),vih-v,rail-voltage],
                      ; locators =             [p]
                    )
                  if has-property?(p.generic-pin):
                    #CHECK(
                      condition =            in-range?(max-voltage(property(p.generic-pin)), rail-voltage),
                      name =                 "IO pin checks"
                      description =          "Check io pin properties"
                      category =             "pin-check"
                      subcheck-description = "Check pin maximum voltage is within the design specification",
                      pass-message =         "Generic pin %_ maximum voltage %_V is correctly within the power supply specification %_V" % [ref(p),max-voltage(property(p.generic-pin)),rail-voltage],
                      fail-message =         "Generic pin %_ maximum voltage %_V is incorrectly outside the power supply specification %_V" % [ref(p),max-voltage(property(p.generic-pin)),rail-voltage],
                      ; locators =             [p]
                    )
          
            #CHECK(
              condition =            is-open-collector-ok?,
              name =                 "IO pin checks"
              description =          "Check io pin properties"
              category =             "pin-check"
              subcheck-description = "Verify open-collector pin is connected to a pull-up resistor and a power supply",
              pass-message =         "Open-collector pin %_ is correctly connected to a pull-up resistor and a power supply rail" % [ref(p)],
              fail-message =         "Open-collector pin %_ is not correctly connected to a pull-up resistor and a power supply rail" % [ref(p)],
              ; locators =             [p]
            )




; Checks two push-pull digital logic pins, at least one of which can output
public defn check-single-push-pull-levels (out-p:JITXObject, in-p:JITXObject) :
  ; if has-property?(in-p.digital-input): println(ref(gnd-pin(property(in-p.digital-input))))
  #CHECK(
    condition =            has-property?(out-p.digital-output) or has-property?(out-p.digital-io),
    name =                 "IO pin checks"
    description =          "Check io pin properties"
    category =             "pin-check"
    subcheck-description = "Verify output or i-o pin has the correct digital-output or digital-io property",
    pass-message =         "Output or I/O pin %_ has the correct digital-output or digital-io property attached" % [ref(out-p)],
    fail-message =         "Output or I/O pin %_ does not have the correct digital-output or digital-io property attached" % [ref(out-p)],
    ; locators =             [out-p]
  )
  val o = 
    if has-property?(out-p.digital-output) : property(out-p.digital-output)
    else if has-property?(out-p.digital-io) : property(out-p.digital-io)
    else : fatal("Verifying digital-output or digital-io pin property precludes this case.")
  #CHECK(
    condition =            driver(o) is CMOSOutput|TTLOutput,
    name =                 "IO pin checks"
    description =          "Check io pin properties"
    category =             "pin-check"
    subcheck-description = "Verify output driver is either CMOS or TTL",
    pass-message =         "Output pin %_ has the correct driver property property attached" % [ref(out-p)],
    fail-message =         "Output pin %_ does not have the correct driver property property attached" % [ref(out-p)],
    ; locators =             [out-p]
  )

  ; If in-p is just an input, check output against input
  if has-property?(in-p.digital-input) :
    val [vih vil] = [vih(property(in-p.digital-input)) vil(property(in-p.digital-input))]
    #CHECK(
      condition =            connected?([gnd-pin(o) gnd-pin(property(in-p.digital-input))]),
      name =                 "IO pin checks"
      description =          "Check io pin properties"
      category =             "pin-check"
      subcheck-description = "Verify input pin is referenced to ground of the output driver",
      pass-message =         "Gnd of the input pin %_ is correctly referenced to the ground net of the driver pin %_" % [ref(in-p), ref(out-p)],
      fail-message =         "Gnd of the input pin %_ is not correctly referenced to the ground net of the driver pin %_" % [ref(in-p), ref(out-p)],
      ; locators =             [in-p]
    )
    #CHECK(
      condition =            min-value(voh(driver(o))) > vih,
      name =                 "IO pin checks"
      description =          "Check io pin properties"
      category =             "pin-check"
      subcheck-description = "Verify min voh of output driver is higher than the vih of the input pin",
      pass-message =         "Output pin %_ min voh %_ is compatible with the input pin %_ vih %_" % [ref(out-p), min-value(voh(driver(o))), ref(in-p), vih],
      fail-message =         "Output pin %_ min voh %_ is not compatible with the input pin %_ vih %_" % [ref(out-p), min-value(voh(driver(o))), ref(in-p), vih],
      ; locators =             [in-p]
    )
    #CHECK(
      condition =            max-value(vol(driver(o))) < vil,
      name =                 "IO pin checks"
      description =          "Check io pin properties"
      category =             "pin-check"
      subcheck-description = "Verify max vol of output driver is compatible with the vil of the input pin",
      pass-message =         "Output pin %_ max vol %_ is compatible with the input pin %_ vil %_" % [ref(out-p), max-value(vol(driver(o))), ref(in-p), vil],
      fail-message =         "Output pin %_ max vol %_ is not compatible with the input pin %_ vil %_" % [ref(out-p), max-value(vol(driver(o))), ref(in-p), vil],
      ; locators =             [in-p]
    )
    if has-property?(in-p.generic-pin):
      #CHECK(
        condition =            in-range?(max-voltage(property(in-p.generic-pin)), voh(driver(o))),
        name =                 "IO pin checks"
        description =          "Check io pin properties"
        category =             "pin-check"
        subcheck-description = "Verify voh of output driver is compatible with voltage range of a generic pin",
        pass-message =         "Output pin %_ max voh %_ is compatible with the voltage range of the generic pin %_ of %_" % [ref(out-p), voh(driver(o)), ref(in-p), max-voltage(property(in-p.generic-pin))],
        fail-message =         "Output pin %_ max voh %_ is not compatible with the voltage range of the generic pin %_ of %_" % [ref(out-p), voh(driver(o)), ref(in-p), max-voltage(property(in-p.generic-pin))],
        ; locators =             [in-p]
      )
  else if has-property?(in-p.digital-io):
    #CHECK(
      condition =            connected?([gnd-pin(o) gnd-pin(property(in-p.digital-io))]),
      name =                 "IO pin checks"
      description =          "Check io pin properties"
      category =             "pin-check"
      subcheck-description = "Verify the digital io pin is referenced to the ground of the output driver",
      pass-message =         "Gnd of the io pin %_ is correctly referenced to the ground net of the driver pin %_" % [ref(in-p), ref(out-p)],
      fail-message =         "Gnd of the io pin %_ is not correctly referenced to the ground net of the driver pin %_" % [ref(in-p), ref(out-p)],
      ; locators =             [in-p]
    )
    val i = driver(property(in-p.digital-io))
    #CHECK(
      condition =            i is CMOSOutput|TTLOutput,
      name =                 "IO pin checks"
      description =          "Check io pin properties"
      category =             "pin-check"
      subcheck-description = "Verify io driver is either CMOS or TTL",
      pass-message =         "IO pin %_ has the correct driver property property attached" % [ref(out-p)],
      fail-message =         "IO pin %_ does not have the correct driver property property attached" % [ref(out-p)],
      ; locators =             ref(in-p)
    )
    val [vih-v vil-v] = [vih(property(in-p.digital-io)) vil(property(in-p.digital-io))]
    #CHECK(
      condition =            min-value(voh(driver(o))) > vih-v,
      name =                 "IO pin checks"
      description =          "Check io pin properties"
      category =             "pin-check"
      subcheck-description = "Verify min voh of output driver is higher than the vih of the input pin",
      pass-message =         "Output pin %_ min voh %_ is compatible with the input pin %_ vih %_" % [ref(out-p), min-value(voh(driver(o))), ref(in-p), vih-v],
      fail-message =         "Output pin %_ min voh %_ is not compatible with the input pin %_ vih %_" % [ref(out-p), min-value(voh(driver(o))), ref(in-p), vih-v],
      ; locators =             ref(in-p)
    )
    #CHECK(
      condition =            max-value(vol(driver(o))) < vil-v,
      name =                 "IO pin checks"
      description =          "Check io pin properties"
      category =             "pin-check"
      subcheck-description = "Verify max vol of output driver is compatible with the vil of the input pin",
      pass-message =         "Output pin %_ max vol %_ is compatible with the input pin %_ vil %_" % [ref(out-p), max-value(vol(driver(o))), ref(in-p), vil-v],
      fail-message =         "Output pin %_ max vol %_ is not compatible with the input pin %_ vil %_" % [ref(out-p), max-value(vol(driver(o))), ref(in-p), vil-v],
      ; locators =             [in-p]
    )
    if has-property?(out-p.digital-io):
      #CHECK(
        condition =            min-value(voh(i)) > vih(o),
        name =                 "IO pin checks"
        description =          "Check io pin properties"
        category =             "pin-check"
        subcheck-description = "Verify min voh of io driver is higher than the vih of the io pin",
        pass-message =         "IO pin %_ min voh %_ is compatible with the io pin %_ vih %_" % [ref(in-p), min-value(voh(i)), ref(out-p), vih(o)],
        fail-message =         "IO pin %_ min voh %_ is not compatible with the io pin %_ vih %_" % [ref(in-p), min-value(voh(i)), ref(out-p), vih(o)],
        ; locators =             [in-p]
      )
      #CHECK(
        condition =            max-value(vol(i)) < vil(o),
        name =                 "IO pin checks"
        description =          "Check io pin properties"
        category =             "pin-check"
        subcheck-description = "Verify max vol of io driver is compatible with the vil of the io pin",
        pass-message =         "IO pin %_ max vol %_ is compatible with the io pin %_ vil %_" % [ref(in-p), max-value(vol(i)), ref(out-p), vil(o)],
        fail-message =         "IO pin %_ max vol %_ is not compatible with the io pin %_ vil %_" % [ref(in-p), max-value(vol(i)), ref(out-p), vil(o)],
        ; locators =             [in-p]
      )
    if has-property?(in-p.generic-pin):
      #CHECK(
        condition =            in-range?(max-voltage(property(in-p.generic-pin)), voh(driver(o))),
        name =                 "IO pin checks"
        description =          "Check io pin properties"
        category =             "pin-check"
        subcheck-description = "Verify voh of output driver is compatible with voltage range of a generic pin",
        pass-message =         "Output pin %_ max voh %_ is compatible with the voltage range of the generic pin %_ of %_" % [ref(out-p), voh(driver(o)), ref(in-p), max-voltage(property(in-p.generic-pin))],
        fail-message =         "Output pin %_ max voh %_ is not compatible with the voltage range of the generic pin %_ of %_" % [ref(out-p), voh(driver(o)), ref(in-p), max-voltage(property(in-p.generic-pin))],
        ; locators =             [in-p]
      )
    if has-property?(out-p.generic-pin):
      #CHECK(
        condition =            in-range?(max-voltage(property(out-p.generic-pin)), voh(i)),
        name =                 "IO pin checks"
        description =          "Check io pin properties"
        category =             "pin-check"
        subcheck-description = "Verify voh of output driver is compatible with voltage range of a generic pin",
        pass-message =         "IO pin %_ max voh %_ is compatible with the voltage range of the generic pin %_ of %_" % [ref(in-p), voh(i), ref(out-p), max-voltage(property(out-p.generic-pin))],
        fail-message =         "IO pin %_ max voh %_ is not compatible with the voltage range of the generic pin %_ of %_" % [ref(in-p), voh(i), ref(out-p), max-voltage(property(out-p.generic-pin))],
        ; locators =             [out-p]
      )
  else if has-property?(in-p.digital-output) and o is DigitalOutput:
    #CHECK(
      condition =            tristateable(o),
      name =                 "IO pin checks"
      description =          "Check io pin properties"
      category =             "pin-check"
      subcheck-description = "Verify output driver is tri-stateable to be compatible with input pin type",
      pass-message =         "IO pin %_ is tri-stateable and is compatible with the input pin %_" % [ref(out-p), ref(in-p)],
      fail-message =         "IO pin %_ is not tri-stateable and is not compatible with the input pin %_" % [ref(out-p), ref(in-p)],
      ; locators =             [out-p]
    )

    #CHECK(
      condition =            tristateable(property(in-p.digital-output)),
      name =                 "IO pin checks"
      description =          "Check io pin properties"
      category =             "pin-check"
      subcheck-description = "Verify input pin is tri-stateable to be compatible with output pin type",
      pass-message =         "Input pin %_ is tri-stateable and is compatible with the output pin %_" % [ref(in-p), ref(out-p)],
      fail-message =         "Input pin %_ is not tri-stateable and is not compatible with the output pin %_" % [ref(in-p), ref(out-p)],
      ; locators =             [in-p]
    )

public pcb-check connected (p:JITXObject|Tuple<JITXObject>) :
  val name = "connected net checks"
  val description = "Check that the object(s) are connected"
  val category = "net-check"
  val pass-message =
    match(p) :
      (p:JITXObject) : "Object %_ is connected" % [ref(p)]
      (p:Tuple<JITXObject>) : "Objects %, are connected" % [map(ref, p)]
  val fail-message =
    match(p) :
      (p:JITXObject) : "Object %_ is not connected" % [ref(p)]
      (p:Tuple<JITXObject>) : "Objects %, are not connected" % [map(ref, p)]
  #CHECK(
    condition =            connected?(p),
    name =                 "connected net checks"
    description =          "Check that the object(s) are connected"
    category =             "net-check"
    subcheck-description = "Verify object is connected",
    pass-message =         pass-message,
    fail-message =         fail-message,
    ; locators =             [p]
  )

; Checks any generic pin for rated voltage
public pcb-check generic-pin (p:JITXObject):
  val name = "Generic pin checks"
  val description = "Check generic pin properties"
  val category = "pin-check"
  if (has-property?(p.rail-voltage)) :
    val p-props = property(p.generic-pin)
    ; Check that the maxima are never crossed
    #CHECK(
      condition =            p-props is GenericPin,
      name =                 "Generic pin checks"
      description =          "Check generic pin properties"
      category =             "pin-check"
      subcheck-description = "Verify pin has the generic pin property expected",
      pass-message =         "Pin %_ is marked correctly as a generic pin" % [ref(p)],
      fail-message =         "Pin %_ is not marked as a generic pin" % [ref(p)],
      ; locators =             [p]
    )
    #CHECK(
      condition =            in-range?(max-voltage(p-props), property(p.rail-voltage)),
      name =                 "Generic pin checks"
      description =          "Check generic pin properties"
      category =             "pin-check"
      subcheck-description = "Verify generic pin is compatible with the design supply voltage range",
      pass-message =         "Generic pin %_ max-voltage %_ is compatible with the supply voltage range %_" % [ref(p), max-voltage(p-props), property(p.rail-voltage)],
      fail-message =         "Generic pin %_ max-voltage %_ is not compatible with the supply voltage range %_" % [ref(p), max-voltage(p-props), property(p.rail-voltage)],
      ; locators =             [p]
    )

; Checks a power pin located on an active component
public pcb-check power-pin (p:JITXObject) :
  val name = "Power pin checks"
  val description = "Check power pin properties"
  val category = "pin-check"
  #CHECK(
    condition =            has-property?(p.power-pin),
    name =                 "Power pin checks"
    description =          "Check power pin properties"
    category =             "pin-check"
    subcheck-description = "Verify power pins have the correct power-pin property",
    pass-message =         "Pin %_ has the correct power-pin property attached" % [ref(p)],
    fail-message =         "Pin %_ does not have the correct power-pin property attached" % [ref(p)],
    ; locators =             [p]
  )

  val p-props = property(p.power-pin)
  #CHECK(
    condition =            p-props is PowerPin,
    name =                 "Power pin checks"
    description =          "Check power pin properties"
    category =             "pin-check"
    subcheck-description = "Verify power pins have the correct power-pin type property",
    pass-message =         "Pin %_ has the correct power-pin type property attached" % [ref(p)],
    fail-message =         "Pin %_ does not have the correct power-pin type property attached" % [ref(p)],
    ; locators =             [p]
  )
  ; println("%_ has power" % [ref(p)])
  #CHECK(
    condition =            has-property?(p.rail-voltage),
    name =                 "Power pin checks"
    description =          "Check power pin properties"
    category =             "pin-check"
    subcheck-description = "Verify power pins have the correct rail-voltage property",
    pass-message =         "Pin %_ has the correct rail-voltage property attached of %_V" % [ref(p), property(p.rail-voltage)],
    fail-message =         "Pin %_ does not have the correct rail-voltage property attached" % [ref(p)],
    ; locators =             [p]
  )
  ; println("%_ has %_" % [ref(p) property(p.rail-voltage)])
  #CHECK(
    condition =            in-range?(recommended-voltage(p-props), property(p.rail-voltage)),
    name =                 "Power pin checks"
    description =          "Check power pin properties"
    category =             "pin-check"
    subcheck-description = "Check power pin rail-voltage property is within the design specification",
    pass-message =         "Power pin %_ rail voltage %_V is correctly within the design specification %_V" % [ref(p),property(p.rail-voltage),recommended-voltage(p-props)],
    fail-message =         "Power pin %_ rail voltage %_V is not correctly within the design specification %_V" % [ref(p),property(p.rail-voltage),recommended-voltage(p-props)],
    ; locators =             [p]
  )

public pcb-check reset-pin (p:JITXObject) :
  val name = "Reset pin checks"
  val description = "Check reset pin properties"
  val category = "pin-check"
  #CHECK(
    condition =            has-property?(p.reset-pin),
    name =                 "Reset pin checks"
    description =          "Check reset pin properties"
    category =             "pin-check"
    subcheck-description = "Verify reset pins have the correct reset-pin property",
    pass-message =         "Reset pin %_ has the correct reset-pin property attached" % [ref(p)],
    fail-message =         "Reset pin %_ does not have the correct reset-pin property attached" % [ref(p)],
    ; locators =             [p]
  )

  val p-props = property(p.reset-pin)
  #CHECK(
    condition =            p-props is ResetPin,
    name =                 "Reset pin checks"
    description =          "Check reset pin properties"
    category =             "pin-check"
    subcheck-description = "Verify reset pins have the correct reset-pin type property",
    pass-message =         "Reset pin %_ has the correct reset-pin type property attached" % [ref(p)],
    fail-message =         "Reset pin %_ does not have the correct reset-pin type property attached" % [ref(p)],
    ; locators =             [p]
  )
  ; Improve this to check togglability
  #CHECK(
    condition =            connected?(p),
    name =                 "Reset pin checks"
    description =          "Check reset pin properties"
    category =             "pin-check"
    subcheck-description = "Verify reset pins have the correct connectivity",
    pass-message =         "Reset pin %_ has the correct connectivity" % [ref(p)],
    fail-message =         "Reset pin %_ does not have the correct connectivity" % [ref(p)],
    ; locators =             [p]
  )


defn check-rated-voltage (p:JITXObject) :
  val rating = property(p.rated-voltage)
  val v = property(p.voltage)
  match(rating, v):
    (r:Double, v:Double) : #CHECK(
                              condition =            property(p.rated-voltage) >= v,
                              name =                 "Check rated-voltage property"
                              description =          "Check design for the correct rated-voltage value"
                              category =             "rated-voltage"
                              subcheck-description = "Check pin rated voltage is within the design voltage specification",
                              pass-message =         "Pin %_ rated voltage %_V is correctly within the design supply specification %_V" % [ref(p),property(p.rated-voltage),v],
                              fail-message =         "Pin %_ rated voltage %_V is incorrectly outside the design supply specification %_V" % [ref(p),property(p.rated-voltage),v],
                              ; locators =             [p]
                            )
    (r:[Double,Double], v:Double) : 
      #CHECK(
        condition =            property(p.rated-voltage)[1] >= v.
        name =                 "Check rated-voltage property"
        description =          "Check design for the correct rated-voltage value"
        category =             "rated-voltage"
        subcheck-description = "Check pin rated voltage is within the design voltage specification",
        pass-message =         "Pin %_ rated voltage %_V high is correctly within the design supply specification %_V" % [ref(p),property(p.rated-voltage)[1],v],
        fail-message =         "Pin %_ rated voltage %_V high is incorrectly outside the design supply specification %_V" % [ref(p),property(p.rated-voltage)[1],v],
        ; locators =             [p]
      )
      #CHECK(
        condition =            property(p.rated-voltage)[0] <= v,
        name =                 "Check rated-voltage property"
        description =          "Check design for the correct rated-voltage value"
        category =             "rated-voltage"
        subcheck-description = "Check pin rated voltage is within the design voltage specification",
        pass-message =         "Pin %_ rated voltage %_V low is correctly within the design supply specification %_V" % [ref(p),property(p.rated-voltage)[0],v],
        fail-message =         "Pin %_ rated voltage %_V low is incorrectly outside the design supply specification %_V" % [ref(p),property(p.rated-voltage)[0],v],
        ; locators =             [p]
      )
    (r:[Double,Double], v:[Double|Double|Double]) : 
      #CHECK(
        condition =            property(p.rated-voltage)[1] >= v[2],
        name =                 "Check rated-voltage property"
        description =          "Check design for the correct rated-voltage value"
        category =             "rated-voltage"
        subcheck-description = "Check pin rated voltage is within the design voltage specification",
        pass-message =         "Pin %_ rated voltage %_V high is correctly within the design supply specification %_V" % [ref(p),property(p.rated-voltage)[1],v[2]],
        fail-message =         "Pin %_ rated voltage %_V high is incorrectly outside the design supply specification %_V" % [ref(p),property(p.rated-voltage)[1],v[2]],
        ; locators =             [p]
      )
      #CHECK(
        condition =            property(p.rated-voltage)[0] <= v[0],
        name =                 "Check rated-voltage property"
        description =          "Check design for the correct rated-voltage value"
        category =             "rated-voltage"
        subcheck-description = "Check pin rated voltage is within the design voltage specification",
        pass-message =         "Pin %_ rated voltage %_V low is correctly within the design supply specification %_V" % [ref(p),property(p.rated-voltage)[0],v[0]],
        fail-message =         "Pin %_ rated voltage %_V low is incorrectly outside the design supply specification %_V" % [ref(p),property(p.rated-voltage)[0],v[0]],
        ; locators =             [p]
      )
    (r, v) : false

; Checks if voltage on a pin is within acceptable limits
public pcb-check voltage-levels (p:JITXObject, range:[Double,Double,Double]) :
  val name = "Voltage level pin checks"
  val description = "Check voltage pin properties"
  val category = "pin-check"

  #CHECK(
    condition =            has-property?(p.voltage),
    name =                 "Voltage level pin checks"
    description =          "Check voltage pin properties"
    category =             "pin-check"
    subcheck-description = "Check pin has voltage property",
    pass-message =         "Pin %_ has a property for voltage" % [ref(p)],
    fail-message =         "Pin %_ does not have a property for voltage" % [ref(p)],
    ; locators =             [p]
  )
  #CHECK(
    condition =            property(p.voltage)[0] >= range[0],
    name =                 "Voltage level pin checks"
    description =          "Check voltage pin properties"
    category =             "pin-check"
    subcheck-description = "Check pin voltage is within the design voltage specification",
    pass-message =         "Pin %_ rated voltage %_V low is correctly within the design range specification %_V" % [ref(p),property(p.voltage)[0],range[0]],
    fail-message =         "Pin %_ rated voltage %_V low is incorrectly outside the design range specification %_V" % [ref(p),property(p.voltage)[0],range[0]],
    ; locators =             [p]
  )
  #CHECK(
    condition =            property(p.voltage)[2] <= range[2],
    name =                 "Voltage level pin checks"
    description =          "Check voltage pin properties"
    category =             "pin-check"
    subcheck-description = "Check pin rated voltage is within the design voltage specification",
    pass-message =         "Pin %_ rated voltage %_V high is correctly within the design range specification %_V" % [ref(p),property(p.voltage)[2],range[2]],
    fail-message =         "Pin %_ rated voltage %_V high is incorrectly outside the design range specification %_V" % [ref(p),property(p.voltage)[2],range[2]],
    ; locators =             [p]
  )

; ====== Component-level checks ======
; ====================================

; Checks resistors against operating point and environment
public pcb-check resistor-component (r:JITXObject) :
  val name = "Resistor checks"
  val description = "Check resistor component properties"
  val category = "component-check"
  #CHECK(
    condition =            has-property?(r.resistor),
    name =                 "Resistor checks"
    description =          "Check resistor component properties"
    category =             "component-check"
    subcheck-description = "Check resistor component has the correct resistor property",
    pass-message =         "Component %_ has the correct property for resistor" % [ref(r)],
    fail-message =         "Component %_ does not have the correct property for a resistor" % [ref(r)],
    ; locators =             [r]
  )
  #CHECK(
    condition =            has-property?(r.operating-point),
    name =                 "Resistor checks"
    description =          "Check resistor component properties"
    category =             "component-check"
    subcheck-description = "Check resistor component has the correct operating-point property",
    pass-message =         "Component %_ has the correct property for operating-point" % [ref(r)],
    fail-message =         "Component %_ does not have the correct property for the operating-point" % [ref(r)],
    ; locators =             [r]
  )

  val [vpk i temp] = [[min-value(peak-voltage(property(r.operating-point))) max-value(peak-voltage(property(r.operating-point)))] max-value(peak-current(property(r.operating-point))) OPERATING-TEMPERATURE[1]]

  val power = property(r.resistance) * pow(i, 2.0)
  if has-property?(r.derating) :
    ; Derate the power based on the piecewise linear curve from MFG
    val derating = PWL(property(r.derating))[temp]
    val pwr = derating * property(r.rated-power)
    #CHECK(
      condition =            pwr * DERATE-RESISTOR-POWER > power,
      name =                 "Resistor checks"
      description =          "Check resistor component properties"
      category =             "component-check"
      subcheck-description = "Check resistor power derating meets the design requirements",
      pass-message =         "Component %_ power derating %_W meets the design requirements of %_W" % [ref(r), pwr * DERATE-RESISTOR-POWER, power],
      fail-message =         "Component %_ power derating %_W does not meet the design requirements of %_W" % [ref(r), pwr * DERATE-RESISTOR-POWER, power],
      ; locators =             [r]
    )
  else :
    ; Derate the power if MFG derating is missing
    val derating = PWL([[0.0 1.0] [70.0 1.0] [125.0 0.0]])[temp]
    val pwr = derating * property(r.rated-power)
    #CHECK(
      condition =            pwr * DERATE-RESISTOR-POWER > power,
      name =                 "Resistor checks"
      description =          "Check resistor component properties"
      category =             "component-check"
      subcheck-description = "Check resistor default power derating meets the design requirements",
      pass-message =         "Component %_ default power derating %_W meets the design requirements of %_W" % [ref(r), pwr * DERATE-RESISTOR-POWER, power],
      fail-message =         "Component %_ default power derating %_W does not meet the design requirements of %_W" % [ref(r), pwr * DERATE-RESISTOR-POWER, power],
      ; locators =             [r]
    )

public pcb-check capacitor-component (c:JITXObject) :
  val name = "Capacitor checks"
  val description = "Check capacitor component properties"
  val category = "component-check"
  #CHECK(
    condition =            has-property?(c.capacitor),
    name =                 "Capacitor checks"
    description =          "Check capacitor component properties"
    category =             "component-check"
    subcheck-description = "Check capacitor component has the correct capacitor property",
    pass-message =         "Component %_ has the correct property for a capacitor" % [ref(c)],
    fail-message =         "Component %_ does not have the correct property for a capacitor" % [ref(c)],
    ; locators =             [c]
  )
  #CHECK(
    condition =            has-property?(c.operating-point),
    name =                 "Capacitor checks"
    description =          "Check capacitor component properties"
    category =             "component-check"
    subcheck-description = "Check capacitor component has the correct operating-point property",
    pass-message =         "Component %_ has the correct property for operating-point" % [ref(c)],
    fail-message =         "Component %_ does not have the correct property for the operating-point" % [ref(c)],
    ; locators =             [c]
  )
  val [vpk temp] = [[min-value(peak-voltage(property(c.operating-point))) max-value(peak-voltage(property(c.operating-point)))] OPERATING-TEMPERATURE[1]]
  val max-temp = max-value(operating-temperature(property(c.rated-temperature)))
  switch(property(c.type)) :

    "ceramic" :
      val vpk-derate-wc = PWL(DERATE-CAPACITOR-MLCC-VPK-WC)[temp]
      #CHECK(
        condition =            vpk[0] <= (vpk-derate-wc * property(c.rated-voltage)),
        name =                 "Capacitor checks"
        description =          "Check capacitor component properties"
        category =             "component-check"
        subcheck-description = "Check ceramic capacitor voltage derating matches the operating-point voltage",
        pass-message =         "Capacitor %_ voltage derating %_V is compatible with the wc design constraint %_V" % [ref(c),vpk[0],(vpk-derate-wc * property(c.rated-voltage))],
        fail-message =         "Capacitor %_ voltage derating %_V is not compatible with the wc design constraint %_V" % [ref(c),vpk[0],(vpk-derate-wc * property(c.rated-voltage))],
        ; locators =             [c]
      )

      #CHECK(
        condition =            vpk[1] <= (vpk-derate-wc * property(c.rated-voltage)),
        name =                 "Capacitor checks"
        description =          "Check capacitor component properties"
        category =             "component-check"
        subcheck-description = "Check ceramic capacitor voltage derating matches the operating-point voltage",
        pass-message =         "Capacitor %_ voltage derating %_V is compatible with the wc design constraint %_V" % [ref(c),vpk[1],(vpk-derate-wc * property(c.rated-voltage))],
        fail-message =         "Capacitor %_ voltage derating %_V is not compatible with the wc design constraint %_V" % [ref(c),vpk[1],(vpk-derate-wc * property(c.rated-voltage))],
        ; locators =             [c]
      )

      val vpk-derate-nom = PWL(DERATE-CAPACITOR-MLCC-VPK-NOM)[temp]
      #CHECK(
        condition =            vpk[0] <= (vpk-derate-nom * property(c.rated-voltage)),
        name =                 "Capacitor checks"
        description =          "Check capacitor component properties"
        category =             "component-check"
        subcheck-description = "Check ceramic capacitor voltage derating matches the operating-point voltage",
        pass-message =         "Capacitor %_ voltage derating %_V is compatible with the nominal design constraint %_V" % [ref(c),vpk[0],(vpk-derate-nom * property(c.rated-voltage))],
        fail-message =         "Capacitor %_ voltage derating %_V is not compatible with the nominal design constraint %_V" % [ref(c),vpk[0],(vpk-derate-nom * property(c.rated-voltage))],
        ; locators =             [c]
      )

      #CHECK(
        condition =            vpk[1] <= (vpk-derate-nom * property(c.rated-voltage)),
        name =                 "Capacitor checks"
        description =          "Check capacitor component properties"
        category =             "component-check"
        subcheck-description = "Check ceramic capacitor voltage derating matches the operating-point voltage",
        pass-message =         "Capacitor %_ voltage derating %_V is compatible with the nominal design constraint %_V" % [ref(c),vpk[1],(vpk-derate-nom * property(c.rated-voltage))],
        fail-message =         "Capacitor %_ voltage derating %_V is not compatible with the nominal design constraint %_V" % [ref(c),vpk[1],(vpk-derate-nom * property(c.rated-voltage))],
        ; locators =             [c]
      )

      #CHECK(
        condition =            temp <= min-value(DERATE-CAPACITOR-MLCC-TEMP, max-temp),
        name =                 "Capacitor checks"
        description =          "Check capacitor component properties"
        category =             "component-check"
        subcheck-description = "Check ceramic capacitor de-rated temperature operating point versus design constraints",
        pass-message =         "Capacitor %_ operating temp %_C satisfies the temperature derating spec of %_C" % [ref(c),temp,min-value(DERATE-CAPACITOR-MLCC-TEMP, max-temp)],
        fail-message =         "Capacitor %_ operating temp %_C does not satisfy the temperature derating spec of %_C" % [ref(c),temp,min-value(DERATE-CAPACITOR-MLCC-TEMP, max-temp)],
        ; locators =             [c]
      )

    "electrolytic" :
      #CHECK(
        condition =            has-property?(c.anode),
        name =                 "Capacitor checks"
        description =          "Check capacitor component properties"
        category =             "component-check"
        subcheck-description = "Check electrolytic capacitor component has the anode property",
        pass-message =         "Electrolytic capacitor %_ has the correct anode property" % [ref(c)],
        fail-message =         "Electrolytic capacitor %_ does not have the correct anode property" % [ref(c)],
        ; locators =             [c]
      )

      #CHECK(
        condition =            has-property?(c.electrolyte),
        name =                 "Capacitor checks"
        description =          "Check capacitor component properties"
        category =             "component-check"
        subcheck-description = "Check electrolytic capacitor component has the electrolyte property",
        pass-message =         "Electrolytic capacitor %_ has the correct electrolyte property" % [ref(c)],
        fail-message =         "Electrolytic capacitor %_ does not have the correct electrolyte property" % [ref(c)],
        ; locators =             [c]
      )

      val [i-pk i-rms] = [lookup(property(c.operating-point), `current-pk) lookup(property(c.operating-point), `current-rms)]

      if (property(c.anode) == "tantalum" and property(c.electrolyte) == "polymer") :
        #CHECK(
          condition =            vpk[1]   <= (DERATE-CAPACITOR-ETANTPOLY-VPK * property(c.rated-voltage)),
          name =                 "Capacitor checks"
          description =          "Check capacitor component properties"
          category =             "component-check"
          subcheck-description = "Check polymer tantalum capacitor voltage derating matches the operating-point voltage",
          pass-message =         "Capacitor %_ voltage operating point %_V is compatible with the constraint %_V" % [ref(c),vpk[1],(DERATE-CAPACITOR-ETANTPOLY-VPK * property(c.rated-voltage))],
          fail-message =         "Capacitor %_ voltage operating point %_V is not compatible with the constraint %_V" % [ref(c),vpk[1],(DERATE-CAPACITOR-ETANTPOLY-VPK * property(c.rated-voltage))],
          ; locators =             [c]
        )

        #CHECK(
          condition =            temp  <= min-value(DERATE-CAPACITOR-ETANTPOLY-TEMP, max-temp),
          name =                 "Capacitor checks"
          description =          "Check capacitor component properties"
          category =             "component-check"
          subcheck-description = "Check capacitor de-rated temperature operating point versus design constraints",
          pass-message =         "Capacitor %_ operating temp %_C satisfies the temperature derating spec of %_C" % [ref(c),temp,min-value(DERATE-CAPACITOR-ETANTPOLY-TEMP, max-temp)],
          fail-message =         "Capacitor %_ operating temp %_C does not satisfy the temperature derating spec of %_C" % [ref(c),temp,min-value(DERATE-CAPACITOR-ETANTPOLY-TEMP, max-temp)],
          ; locators =             [c]
        )

        #CHECK(
          condition =            i-pk  <= property(c.rated-current-pk),
          name =                 "Capacitor checks"
          description =          "Check capacitor component properties"
          category =             "component-check"
          subcheck-description = "Check capacitor peak current matches the rated peak current",
          pass-message =         "Capacitor %_ peak current %_A is compatible with the rated peak current %_A" % [ref(c),i-pk,property(c.rated-current-pk)],
          fail-message =         "Capacitor %_ peak current %_A is not compatible with the rated peak current %_A" % [ref(c),i-pk,property(c.rated-current-pk)],
          ; locators =             [c]
        )

        #CHECK(
          condition =            i-rms <= PWL(property(c.rated-current-rms))[temp],
          name =                 "Capacitor checks"
          description =          "Check capacitor component properties"
          category =             "component-check"
          subcheck-description = "Check capacitor rms current matches the rated rms current",
          pass-message =         "Capacitor %_ rms current %_A is compatible with the rated rms current %_A" % [ref(c),i-rms,PWL(property(c.rated-current-rms))[temp]],
          fail-message =         "Capacitor %_ rms current %_A is not compatible with the rated rms current %_A" % [ref(c),i-rms,PWL(property(c.rated-current-rms))[temp]],
          ; locators =             ref(c)
        )

        #CHECK(
          condition =            vpk[0]  >= 0.0,
          name =                 "Capacitor checks"
          description =          "Check capacitor component properties"
          category =             "component-check"
          subcheck-description = "Check capacitor has min peak voltage greater than 0V",
          pass-message =         "Capacitor %_ min peak voltage %_V is greater than or equal to 0V" % [ref(c),vpk[0]],
          fail-message =         "Capacitor %_ min peak voltage %_V is less than 0V" % [ref(c),vpk[0]],
          ; locators =             [c]
        )

      else if (property(c.anode) == "tantalum" and property(c.electrolyte) == "manganese-dioxide") :
        #CHECK(
          condition =            i-pk <= property(c.rated-current-pk),
          name =                 "Capacitor checks"
          description =          "Check capacitor component properties"
          category =             "component-check"
          subcheck-description = "Check manganese-dioxide tantalum capacitor peak current matches the rated peak current",
          pass-message =         "Capacitor %_ peak current %_A is compatible with the rated peak current %_A" % [ref(c),i-pk,property(c.rated-current-pk)],
          fail-message =         "Capacitor %_ peak current %_A is not compatible with the rated peak current %_A" % [ref(c),i-pk,property(c.rated-current-pk)],
          ; locators =             [c]
        )

        #CHECK(
          condition =            i-rms <= PWL(property(c.rated-current-rms))[temp],
          name =                 "Capacitor checks"
          description =          "Check capacitor component properties"
          category =             "component-check"
          subcheck-description = "Check manganese-dioxide tantalum capacitor rms current matches the rated rms current",
          pass-message =         "Capacitor %_ rms current %_A is compatible with the rated rms current %_A" % [ref(c),i-rms,PWL(property(c.rated-current-rms))[temp]],
          fail-message =         "Capacitor %_ rms current %_A is not compatible with the rated rms current %_A" % [ref(c),i-rms,PWL(property(c.rated-current-rms))[temp]],
          ; locators =             [c]
        )

        #CHECK(
          condition =            vpk[0]  >= 0.0,
          name =                 "Capacitor checks"
          description =          "Check capacitor component properties"
          category =             "component-check"
          subcheck-description = "Check manganese-dioxide tantalum capacitor has min peak voltage greater than 0V",
          pass-message =         "Capacitor %_ min peak voltage %_V is greater than or equal to 0V" % [ref(c),vpk[0]],
          fail-message =         "Capacitor %_ min peak voltage %_V is less than 0V" % [ref(c),vpk[0]],
          ; locators =             [c]
        )

        val vpk-derate-wc = PWL(DERATE-CAPACITOR-ETANTMNO2-VPK-WC)[temp]
        val vpk-derate-nom = PWL(DERATE-CAPACITOR-ETANTMNO2-VPK-NOM)[temp]
        if i-pk <= 2.0 :
          #CHECK(
            condition =            vpk[1]  <= (vpk-derate-wc * property(c.rated-voltage)),
            name =                 "Capacitor checks"
            description =          "Check capacitor component properties"
            category =             "component-check"
            subcheck-description = "Check capacitor voltage derating matches the wc operating-point voltage",
            pass-message =         "Capacitor %_ voltage derating %_V is compatible with the wc design constraint %_V" % [ref(c),vpk[1],(vpk-derate-wc * property(c.rated-voltage))],
            fail-message =         "Capacitor %_ voltage derating %_V is not compatible with the wc design constraint %_V" % [ref(c),vpk[1],(vpk-derate-wc * property(c.rated-voltage))],
            ; locators =             [c]
          )

          #CHECK(
            condition =            vpk[1]  <= (vpk-derate-nom * property(c.rated-voltage)),
            name =                 "Capacitor checks"
            description =          "Check capacitor component properties"
            category =             "component-check"
            subcheck-description = "Check capacitor voltage derating matches the operating-point voltage",
            pass-message =         "Capacitor %_ voltage derating %_V is compatible with the nominal design constraint %_V" % [ref(c),vpk[1],(vpk-derate-nom * property(c.rated-voltage))],
            fail-message =         "Capacitor %_ voltage derating %_V is not compatible with the nominal design constraint %_V" % [ref(c),vpk[1],(vpk-derate-nom * property(c.rated-voltage))],
            ; locators =             [c]
          )

          #CHECK(
            condition =            temp <= min-value(DERATE-CAPACITOR-ETANTMNO2-TEMP-NOM, max-temp),
            name =                 "Capacitor checks"
            description =          "Check capacitor component properties"
            category =             "component-check"
            subcheck-description = "Check capacitor de-rated nominal temperature operating point versus design constraints",
            pass-message =         "Capacitor %_ operating temp %_C satisfies the nominal temperature derating spec of %_C" % [ref(c),temp,min-value(DERATE-CAPACITOR-ETANTMNO2-TEMP-NOM, max-temp)],
            fail-message =         "Capacitor %_ operating temp %_C does not satisfy the nominal temperature derating spec of %_C" % [ref(c),temp,min-value(DERATE-CAPACITOR-ETANTMNO2-TEMP-NOM, max-temp)],
            ; locators =             [c]
          )

          #CHECK(
            condition =            temp <= min-value(DERATE-CAPACITOR-ETANTMNO2-TEMP-WC, max-temp),
            name =                 "Capacitor checks"
            description =          "Check capacitor component properties"
            category =             "component-check"
            subcheck-description = "Check capacitor de-rated wc temperature operating point versus design constraints",
            pass-message =         "Capacitor %_ operating temp %_C satisfies the wc temperature derating spec of %_C" % [ref(c),temp,min-value(DERATE-CAPACITOR-ETANTMNO2-TEMP-WC, max-temp)],
            fail-message =         "Capacitor %_ operating temp %_C does not satisfy the wc temperature derating spec of %_C" % [ref(c),temp,min-value(DERATE-CAPACITOR-ETANTMNO2-TEMP-WC, max-temp)],
            ; locators =             [c]
          )

        else if i-pk > 2.0 :
          #CHECK(
            condition =            vpk[1]  <= (DERATE-CAPACITOR-ETANTMNO2-VPK * property(c.rated-voltage)),
            name =                 "Capacitor checks"
            description =          "Check capacitor component properties"
            category =             "component-check"
            subcheck-description = "Check capacitor voltage derating matches the wc operating-point voltage",
            pass-message =         "Capacitor %_ voltage derating %_V is compatible with the wc design constraint %_V" % [ref(c),vpk[1],(vpk-derate-wc * property(c.rated-voltage))],
            fail-message =         "Capacitor %_ voltage derating %_V is not compatible with the wc design constraint %_V" % [ref(c),vpk[1],(vpk-derate-wc * property(c.rated-voltage))],
            ; locators =             [c]
          )


          #CHECK(
            condition =            temp <= min-value(DERATE-CAPACITOR-ETANTMNO2-TEMP-NOM, max-temp),
            name =                 "Capacitor checks"
            description =          "Check capacitor component properties"
            category =             "component-check"
            subcheck-description = "Check capacitor de-rated nominal temperature operating point versus design constraints",
            pass-message =         "Capacitor %_ operating temp %_C satisfies the nominal temperature derating spec of %_C" % [ref(c),temp,min-value(DERATE-CAPACITOR-ETANTMNO2-TEMP-NOM, max-temp)],
            fail-message =         "Capacitor %_ operating temp %_C does not satisfy the nominal temperature derating spec of %_C" % [ref(c),temp,min-value(DERATE-CAPACITOR-ETANTMNO2-TEMP-NOM, max-temp)],
            ; locators =             [ref(c)]
          )

      else :
        println("Unhandled electrolytic type for capacitor check on %_" % [c])

    "mica" :
      #CHECK(
        condition =            vpk[0] <= (DERATE-CAPACITOR-MICA-VPK * property(c.rated-voltage)),
        name =                 "Capacitor checks"
        description =          "Check capacitor component properties"
        category =             "component-check"
        subcheck-description = "Check mica capacitor voltage derating matches the operating-point voltage",
        pass-message =         "Capacitor %_ voltage operating point %_V is compatible with the constraint %_V" % [ref(c),vpk[0],(DERATE-CAPACITOR-MICA-VPK * property(c.rated-voltage))],
        fail-message =         "Capacitor %_ voltage operating point %_V is not compatible with the constraint %_V" % [ref(c),vpk[0],(DERATE-CAPACITOR-MICA-VPK * property(c.rated-voltage))],
        ; locators =             [c]
      )

      #CHECK(
        condition =            vpk[1] <= (DERATE-CAPACITOR-MICA-VPK * property(c.rated-voltage)),
        name =                 "Capacitor checks"
        description =          "Check capacitor component properties"
        category =             "component-check"
        subcheck-description = "Check mica capacitor voltage derating matches the operating-point voltage",
        pass-message =         "Capacitor %_ voltage operating point %_V is compatible with the constraint %_V" % [ref(c),vpk[1],(DERATE-CAPACITOR-MICA-VPK * property(c.rated-voltage))],
        fail-message =         "Capacitor %_ voltage operating point %_V is not compatible with the constraint %_V" % [ref(c),vpk[1],(DERATE-CAPACITOR-MICA-VPK * property(c.rated-voltage))],
        ; locators =             [c]
      )

      #CHECK(
          condition =            temp <= min-value(DERATE-CAPACITOR-MICA-TEMP, max-temp),
          name =                 "Capacitor checks"
          description =          "Check capacitor component properties"
          category =             "component-check"
          subcheck-description = "Check capacitor de-rated temperature operating point versus design constraints",
          pass-message =         "Capacitor %_ operating temp %_C satisfies the temperature derating spec of %_C" % [ref(c),temp,min-value(DERATE-CAPACITOR-MICA-TEMP, max-temp)],
          fail-message =         "Capacitor %_ operating temp %_C does not satisfy the temperature derating spec of %_C" % [ref(c),temp,min-value(DERATE-CAPACITOR-MICA-TEMP, max-temp)],
          ; locators =             [c]
        )

    else : println("Unhandled type for capacitor check on %_" % [c])

  #CHECK(
    condition =            OPERATING-TEMPERATURE[0] >= min-value(operating-temperature(property(c.rated-temperature))),
    name =                 "Capacitor checks"
    description =          "Check capacitor component properties"
    category =             "component-check"
    subcheck-description = "Check capacitor operating temperature versus design constraints",
    pass-message =         "Capacitor %_ has an acceptable operating temperature %_C versus design target %_C" % [ref(c), min-value(operating-temperature(property(c.rated-temperature))), OPERATING-TEMPERATURE[0]],
    fail-message =         "Capacitor %_ does not have an acceptable operating temperature %_C versus design target %_C" % [ref(c), min-value(operating-temperature(property(c.rated-temperature))), OPERATING-TEMPERATURE[0]],
    ; locators =             [c]
  )

; Checks the frequency of an oscillator (o) against an interface on an IC (intf)
public pcb-check oscillator-check-property (o:JITXObject) :
  val name = "Crystal oscillator checks"
  val description = "Check crystal oscillator property"
  val category = "oscillator-check"
  ; Check existence of property  
  #CHECK(
    condition =            has-property?(o.crystal-resonator),
    name =                 "Crystal oscillator checks"
    description =          "Check crystal oscillator property"
    category =             "oscillator-check"
    subcheck-description = "Check crystal component has the correct crystal-resonator property",
    pass-message =         "Component %_ has the correct property for a crystal-resonator" % [ref(o)],
    fail-message =         "Component %_ does not have the correct property for a crystal-resonator" % [ref(o)],
    ; locators =             [o]
  )

; Checks the frequency of an oscillator (o) against an interface on an IC (intf)
public pcb-check oscillator-check-frequency (o:JITXObject, intf:CrystalOscillator) :
  val name = "Crystal oscillator checks"
  val description = "Check crystal oscillator frequency"
  val category = "oscillator-check"
  ; Check critical gain point to ensure oscillation
  #CHECK(
    condition =            frequency(property(o.crystal-resonator)) == frequency(intf),
    name =                 "Crystal oscillator checks"
    description =          "Check crystal oscillator frequency"
    category =             "oscillator-check"
    subcheck-description = "Check crystal has the correct frequency meeting design specs",
    pass-message =         "Crystal %_ does have the correct frequency %_ to meet design specs %_" % [ref(o),frequency(property(o.crystal-resonator)),frequency(intf)],
    fail-message =         "Crystal %_ does not have the correct frequency %_ to meet design specs %_" % [ref(o),frequency(property(o.crystal-resonator)),frequency(intf)],
    ; locators =             [o]
  )

; Checks the critical gain of an oscillator (o) against an interface on an IC (intf)
public pcb-check oscillator-check-gain (o:JITXObject, intf:CrystalOscillator, load-cap:JITXObject) :
  val name = "Crystal oscillator checks"
  val description = "Check crystal oscillator gain"
  val category = "oscillator-check"
  ; Check critical gain point to ensure oscillation
  val op = property(o.crystal-resonator)
  val gain = 4.0 * ESR(op) * pow(2.0 * PI * frequency(op), 2.0) * pow(shunt-capacitance(op) + load-capacitance(op), 2.0)
  #CHECK(
    condition =            gain < max-critical-gain(intf),
    name =                 "Crystal oscillator checks"
    description =          "Check crystal oscillator gain"
    category =             "oscillator-check"
    subcheck-description = "Check crystal circuit gain meets the design criteria for max-critical-gain",
    pass-message =         "Crystal %_ gain %_ meets the design criteria for max-critical-gain" % [ref(o), gain, max-critical-gain(intf)],
    fail-message =         "Crystal %_ gain %_ does not meet the design criteria for max-critical-gain" % [ref(o), gain, max-critical-gain(intf)],
    ; locators =             [o]
  )

; Checks the drive level of an oscillator (o) against an interface on an IC (intf)
public pcb-check oscillator-check-drive (o:JITXObject, intf:CrystalOscillator, load-cap:JITXObject) :
  val name = "Crystal oscillator checks"
  val description = "Check crystal oscillator drive level"
  val category = "oscillator-check"
  ; Check drive level against crystal maximum
  #CHECK(
    condition =            drive-level(intf) <= max-drive-level(property(o.crystal-resonator)),
    name =                 "Crystal oscillator checks"
    description =          "Check crystal oscillator drive level"
    category =             "oscillator-check"
    subcheck-description = "Check crystal oscillator circuit has the correct drive-level property to match crystal",
    pass-message =         "Crystal circuit %_ has the correct drive-level property %_ that matches the crystal spec %_" % [ref(o),drive-level(intf),max-drive-level(property(o.crystal-resonator))],
    fail-message =         "Crystal circuit %_ does not have the correct drive-level property %_ that matches the crystal spec %_" % [ref(o),drive-level(intf),max-drive-level(property(o.crystal-resonator))],
    ; locators =             [o]
  )

; Check pullability of crystal to ensure accuracy
public pcb-check oscillator-check-pullability (o:JITXObject, intf:CrystalOscillator, load-cap:JITXObject) :
  val name = "Crystal oscillator checks"
  val description = "Check crystal oscillator pullability"
  val category = "oscillator-check"
  val op = property(o.crystal-resonator)
  val pullability = motional-capacitance(op) / (2.0 * pow(shunt-capacitance(op) + load-capacitance(op), 2.0))
  #CHECK(
    condition =            has-property?(load-cap.tolerance),
    name =                 "Crystal oscillator checks"
    description =          "Check crystal oscillator pullability"
    category =             "oscillator-check"
    subcheck-description = "Check crystal tuning capacitor has the correct tolerance property",
    pass-message =         "Capacitor %_ has the correct tolerance property for crystal tuning" % [ref(load-cap)],
    fail-message =         "Capacitor %_ does not have the correct tolerance property for crystal tuning" % [ref(load-cap)],
    ; locators =             [load-cap]
  )
  #CHECK(
    condition =            has-property?(load-cap.capacitance),
    name =                 "Crystal oscillator checks"
    description =          "Check crystal oscillator pullability"
    category =             "oscillator-check"
    subcheck-description = "Check crystal tuning capacitor has the correct capacitance property",
    pass-message =         "Capacitor %_ has the correct capacitance property for crystal tuning" % [ref(load-cap)],
    fail-message =         "Capacitor %_ does not have the correct capacitance property for crystal tuning" % [ref(load-cap)],
    ; locators =             [load-cap]
  )

  val dC = (property(load-cap.capacitance) as Double) * (property(load-cap.tolerance)[1] as Double)
  val freq-error = (pullability as Double) * (dC as Double) * frequency(op)
  #CHECK(
    condition =            frequency-tolerance(op) + freq-error < frequency-tolerance(intf),
    name =                 "Crystal oscillator checks"
    description =          "Check crystal oscillator pullability"
    category =             "oscillator-check"
    subcheck-description = "Check crystal frequency tolerance with pullability meets the design specification",
    pass-message =         "Crystal %_ has the correct frequency tolerance %_ that meets the design spec %_" % [ref(load-cap),frequency-tolerance(op) + freq-error,frequency-tolerance(intf)],
    fail-message =         "Crystal %_ does not have the correct frequency tolerance %_ that meets the design spec %_" % [ref(load-cap),frequency-tolerance(op) + freq-error,frequency-tolerance(intf)],
    ; locators =             [load-cap op]
  )

public defn check-oscillator (o:JITXObject, intf:CrystalOscillator, load-cap:JITXObject) :
  inside pcb-module:
    check oscillator-check-property(o)
    if has-property?(o.crystal-resonator) :
      check oscillator-check-frequency(o, intf)
      check oscillator-check-gain(o, intf, load-cap)
      check oscillator-check-drive(o, intf, load-cap)
      check oscillator-check-pullability(o, intf, load-cap)

; Extract the copper layer on a given side of a landpattern
; - note: geoms unsupported
defn copper (lp:LandPattern, side:Side) -> Seqable<Shape> :
  for pad in pads(lp) seq?: 
    if /side(pad) == side or pad-type(/pad(pad)) == TH:
      One(pose(pad) * pad-shape(/pad(pad)))
    else:
      None()

; Get the locations of all the pads in a land pattern
defn pad-locs (lp:LandPattern) -> Seqable<Pose> :
  seq(pose, pads(lp))

; Get the minimum pitch of all the pads in a land pattern
defn min-pitch (lp:LandPattern) -> Double :
  min-space(seq(center, pad-locs(lp)))

; Checks that the copper layers on both sides of a landpattern are within the 
; min-copper-copper-space rule.
public pcb-check check-min-copper-copper-space (lp:LandPattern, side:Side) :
  val name = "Layout checks"
  val description = "Check min copper spacing"
  val category = "landpattern-check"

  val copper = to-tuple(copper(lp, side))
  if not empty?(copper) :
    val min-copper-copper-space = clearance(current-rules(), MinCopperCopperSpace)
    val min-space = min-space(copper)
    #CHECK(
      condition =            min-space >= min-copper-copper-space,
      name =                 "Layout checks"
      description =          "Check min copper spacing"
      category =             "landpattern-check"
      subcheck-description = "Check landpattern copper minimum spacing",
      pass-message =         "Landpattern %_ min spacing %_ does not violate min spacing rules %_" % [/name(lp),min-space,min-copper-copper-space],
      fail-message =         "Landpattern %_ min spacing %_ violates min spacing rules %_" % [/name(lp),min-space,min-copper-copper-space],
      ; locators =             [landpattern]
    )

; Checks that the copper layers on both sides of a ladnpattern dont' violate 
; the minimum copper width rule
public pcb-check check-min-copper-width (lp:LandPattern, side:Side) :
  val name = "Layout checks"
  val description = "Check min copper width"
  val category = "landpattern-check"
  val copper = to-seq(copper(lp, side))
  if not empty?(copper) :
    val min-copper-width = clearance(current-rules(), MinCopperCopperSpace)
    val min-width = min-width(copper)
    #CHECK(
      condition =            min-width >= min-copper-width,
      name =                 "Layout checks"
      description =          "Check min copper width"
      category =             "landpattern-check"
      subcheck-description = "Check landpattern copper minimum width",
      pass-message =         "Landpattern %_ min width %_ does not violate min width rules %_" % [/name(lp),min-width,min-copper-width],
      fail-message =         "Landpattern %_ min width %_ violates min width rules %_" % [/name(lp),min-width,min-copper-width],
      ; locators =             [landpattern]
    )

; Checks that a BGA landpattern does not violate the min-pitch-bga design rule
public pcb-check check-bga-pitch (lp:LandPattern) :
  val name = "Layout checks"
  val description = "Check bga pad pitch"
  val category = "landpattern-check"
  val min-pitch-bga = clearance(current-rules(), MinPitchBGA)
  #CHECK(
    condition =            min-pitch(lp) >= min-pitch-bga,
    name =                 "Layout checks"
    description =          "Check bga pad pitch"
    category =             "landpattern-check"
    subcheck-description = "Check landpattern bga minimum pitch",
    pass-message =         "Landpattern %_ min bga pitch %_ does not violate min bga pitch rules %_" % [/name(lp),min-pitch(lp),min-pitch-bga],
    fail-message =         "Landpattern %_ min bga pitch %_ violates min bga pitch rules %_" % [/name(lp),min-pitch(lp),min-pitch-bga],
    ; locators =             [landpattern]
  )

; Checks that a leaded component does not violate the min-leaded-pitc  design rule
public pcb-check check-leaded-pitch (lp:LandPattern) :
  val name = "Layout checks"
  val description = "Check leaded pad pitch"
  val category = "landpattern-check"
  val min-pitch-leaded = clearance(current-rules(), MinPitchLeaded)
  val min-pitch =  min-pitch(lp)
  #CHECK(
    condition =            min-pitch >= min-pitch-leaded,
    name =                 "Layout checks"
    description =          "Check leaded pad pitch"
    category =             "landpattern-check"
    subcheck-description = "Check landpattern leaded minimum pitch",
    pass-message =         "Landpattern %_ min leaded pitch %_ does not violate min leaded pitch rules %_" % [/name(lp),min-pitch,min-pitch-leaded],
    fail-message =         "Landpattern %_ min leaded pitch %_ violates min leaded pitch rules %_" % [/name(lp),min-pitch,min-pitch-leaded],
    ; locators =             [landpattern]
  )

; Checks that the solder mask layers of a land pattern do not violate the minimum
; solder mask sliver
public pcb-check check-min-solder-mask-sliver (lp:LandPattern, shapes:Seqable<Shape>) :
  val name = "Layout checks"
  val description = "Check min soldermask size"
  val category = "layout-check"
  val s = to-seq(shapes)
  if not empty?(s):
    val min-space = min-space(s)
    val rule-space = clearance(current-rules(), MinSolderMaskBridge)
    #CHECK(
      condition =            min-space >= rule-space,
      name =                 "Layout checks"
      description =          "Check min soldermask size"
      category =             "landpattern-check"
      subcheck-description = "Check landpattern minimum soldermask bridge spacing",
      pass-message =         "Landpattern %_ min soldermask spacing %_ does not violate min rules %_" % [/name(lp),min-space,rule-space],
      fail-message =         "Landpattern %_ min soldermask spacing %_ violates min rules %_" % [/name(lp),min-space,rule-space],
      ; locators =             [landpattern]
    )

; Runs all the land pattern checks on either an instance or definition. 
public defn check-landpattern (component:JITXObject|JITXDef) :
  ; extract the land pattern
  val lp = 
    match(component) :
      (landpattern:LandPattern) :
        landpattern
      (d:JITXDef) :
        landpattern(d)
      (i:JITXObject) : 
        landpattern(instance-definition(i))

  ; perform the checks
  inside pcb-module :
    for side in [Top, Bottom] do :
      check check-min-copper-copper-space(lp, side)
      check check-min-copper-width(lp, side)
      check check-min-solder-mask-sliver(lp, layer(lp, SolderMask(side)))

    if has-property?(component.bga) and property(component.bga):
      check check-bga-pitch(lp)

    if has-property?(component.leaded) and property(component.leaded):
      check check-leaded-pitch(lp)

; Runs landpattern checks recursively on all the lands in a module
public defn check-all-landpatterns (module:JITXObject) : 
  inside pcb-module :
    val components = to-tuple(component-instances(module))
    val modules    = filter({not contains?(components, _)}, instances(module))
    for component in components do :
      check-landpattern(component)
    for module in modules do :
      check-all-landpatterns(module)
    
; Runs landpattern checks recursively starting from self.
public defn check-all-landpatterns () : 
  inside pcb-module: 
    check-all-landpatterns(self)
