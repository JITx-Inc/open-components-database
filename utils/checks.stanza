#use-added-syntax(jitx)
defpackage ocdb/checks:
  import core
  import collections
  import math
  import jitx
  import jitx/commands
  import ocdb/defaults
  import ocdb/space-derating
  import ocdb/generator-utils
  import ocdb/property-structs
  import ocdb/design-vars
  import ocdb/tolerance
  import lang-utils


;<>
#CHECK(
  condition = p-props is GenericPin,                    ; A boolean check                     (True|False)
  name = "Generic Pin",                                 ; short name for the check category   (Printable)
  description = "Checks the voltage applied to pins",   ; The description of the pcb check    (Printable)
  category = "pin-check",                               ; Category for the check              (Printable)
  subcheck-description = "sub-check detail description",; The description of the sub check    (Printable)
  pass-message = "pass printable %_" % [ref(p)],        ; What is printed if the check passes (Printable)
  fail-message = "fail printable %_ " % [ref(p)],       ; What is printed if the check fails  (Printable)
  locators = [p]                                        ; Locators                            (Tuple<JITXObject|JITXDef>)
)
<>

; ====================================
; ==== Check convenience functions ===
; ====================================


doc: \<S>
Set of standard checks to run on a top-level-module.
 - Component instances marked DNP are skipped
 - Resistors, Capacitors are checked
 - Components with temperature rating are checked
   against design variables, see ocdb/design-vars
 - Pins are checked
   - GenericPin properties are checked
   - PowerPin properties are checked
   - ResetPin properties are checked
 - Landpattern checks are run, see check-landpattern
 - Digital I/O pin checks are run, see check-io
<S>

public defn check-design (module:JITXObject):
  erc-check-design(module)
  drc-check-design(module)

public defn erc-check-design (module:JITXObject):
  inside pcb-module:
    for i in populated-components(module) do :
      check rated-temperature(i)
      check capacitor-component(i) when has-property?(i.capacitor)
      check resistor-component(i)  when has-property?(i.resistor)
      check inductor-component(i)  when has-property?(i.inductor)
      check diode-component(i)     when has-property?(i.diode)
      
      for p in pins(i) do :
        check generic-pin-check(p) when has-property?(p.generic-pin)
        check power-pin-check(p)   when has-property?(p.power-pin)
        check reset-pin-check(p)   when has-property?(p.reset-pin)
    check-io(module)

public defn drc-check-design (module:JITXObject):
  inside pcb-module:
    check-all-landpatterns(module)
    ; This needs to be added back when we are able to detect whether a board has been set
    ; if exists?(board) :
    ;   run-design-verification()


    ; if board(design) is False :
    ;   issue-error(CannotPlaceWithoutBoard(path(design)))
    ; if rules(design) is False :
    ;   issue-error(CannotPlaceWithoutRules(path(design)))

;============================================================
;======================== Check IO ==========================
;============================================================

defstruct Connections :
  connected-groups: Tuple<Tuple<Pin>> ; ignores singletons made of non-connected-pins
  non-connected-pins: Tuple<Pin>

val POPULATED-CONNECTIONS = HashTable<JITXObject, Connections>()

public defn populated-connected-groups (module:JITXObject) -> Tuple<Tuple<Pin>> :
  connected-groups $ populated-connections(module)

defn populated-non-connected-pins (module:JITXObject) -> Tuple<Pin> :
  non-connected-pins $ populated-connections(module)

defn populated-connections (module:JITXObject) -> Connections :
  if not key?(POPULATED-CONNECTIONS, module) :
    POPULATED-CONNECTIONS[module] = connect-groups(module)

  POPULATED-CONNECTIONS[module]

defn connect-groups (module:JITXObject) -> Connections :
  val visited-connections = HashSet<Pin>()
  val connected-groups = Vector<Tuple<Pin>>()
  val non-connected-pins = Vector<Pin>()

  for p in all-populated-pins(module) do :
    ; p is not added to visited-connections because we already looped over it, so it is clear.
    if visited-connections[p] :
      None()
    else :
      val connections = connected-pins(p)
      if empty?(connections) :
        add(non-connected-pins, p)
      else :
        add-all(visited-connections, connections)
        val connected-group = to-tuple $ cat([p], connections)
        add(connected-groups, connected-group)

  Connections(to-tuple(connected-groups),
              to-tuple(non-connected-pins))

; Checks if a component is DNP (do-not-populate)
defn dnp-component? (component:JITXObject) :
  has-property?(component.DNP) or
  has-property?(component.do-not-populate) or
  has-property?(component.dnp)

; Checks if a pin is DNP (do-not-populate)
defn dnp-pin? (pin:Pin) :
  dnp-component? $ containing-instance!(pin)

; Returns component instances not marked DNP
defn populated-components (module:JITXObject) -> Tuple<JITXObject> : 
  component-instances(module) 
    $> filter{{not dnp-component?(_)}, _}
    $> to-tuple

; Returns all the pins that are electrically-meaningful, ie are not
; from components marked do-not-place
defn all-populated-pins (module:JITXObject) -> Tuple<Pin> :
  populated-components(module)
    $> seq-cat{pins, _}
    $> to-tuple
    $> {_ as Tuple<Pin>}

defn all-pins (module:JITXObject) -> Tuple<JITXObject> :
  component-instances(module)
    $> seq-cat{pins, _}
    $> to-tuple

; Returns connected pins to `p` not marked DNP
defn populated-connected-pins (p: JITXObject) :
  connected-pins(p) $> filter{{not dnp-pin?(_)}, _}
                    $> to-tuple

public defn containing-instance! (obj:JITXObject) -> Instance :
  containing-instance(obj) as Instance

defn get-other-pin (comp:JITXObject,  p:JITXObject) :
  for ps in pins(comp) find! :
    ps != p

public pcb-check within? (t:Toleranced, value:Toleranced) :
  val name = "Within Check"
  val description = "Check that a value is within a given range"
  val category = "value-check"
  #CHECK(
    condition =            in-range?(t, value),
    name =                 "Within Check",
    description =          "Check that a value is within a given range",
    category =             "value-check"
    subcheck-description = "Check that a value is within a given range"
    pass-message =         "Value %_ to %_ is within the range of %_ to %_" % [min-value(t) max-value(t) min-value(value) max-value(value)]
    fail-message =         "Value %_ to %_ is not within the range of %_ to %_" % [min-value(t) max-value(t) min-value(value) max-value(value)]
    locators =             []
    )

public pcb-check rated-temperature (component:JITXObject):
  val name = "Rated temperature check"
  val description = "Check rated temperatures for components versus design constraints"
  val category = "rated-temperature"
  #CHECK(
    condition =            has-property?(component.rated-temperature),
    name =                 "Rated temperature check"
    description =          "Check rated temperatures for components versus design constraints"
    category =             "rated-temperature"
    subcheck-description = "Check rated temperature of component versus design constraints",
    pass-message =         "%_ has a property for rated-temperature of %_C" % [ref(component) property(component.rated-temperature)],
    fail-message =         "%_ does not have a property for rated-temperature" % [ref(component)],
    locators =             [component]
  )
    ; {
    ;   type: "instance-of-component"
    ;   info: {
    ;     file: "myfile.stanza"
    ;     line: 18
    ;     column: 20
    ;   }
    ; }

  val temp = operating-temperature(property(component.rated-temperature))
  ; println("Rating %_" % [temp])
  #CHECK(
    condition =            in-range?(temp, OPERATING-TEMPERATURE[0]),
    name =                 "Rated temperature check"
    description =          "Check rated temperatures for components versus design constraints"
    category =             "rated-temperature"
    subcheck-description = "Check rated temperature (low) of component versus design constraints",
    pass-message =         "%_ has an acceptable lower operating temperature versus design target (%_C <= %_C)" % [ref(component), temp, OPERATING-TEMPERATURE[0]],
    fail-message =         "%_ does not have an acceptable lower operating temperature versus design target (%_C > %_C)" % [ref(component), temp, OPERATING-TEMPERATURE[0]],
    locators =             [component]
  )
  #CHECK(
    condition =            in-range?(temp, OPERATING-TEMPERATURE[1]),
    name =                 "Rated temperature check"
    description =          "Check rated temperatures for components versus design constraints"
    category =             "rated-temperature"
    subcheck-description = "Check rated temperature (high) of component versus design constraints",
    pass-message =         "%_ has higher operating temperature that is compatible with the design target(%_C >= %_C)" % [ref(component), temp, OPERATING-TEMPERATURE[1]],
    fail-message =         "%_ does not have an acceptable higher operating temperature versus design target (%_C < %_C)" % [ref(component), temp, OPERATING-TEMPERATURE[1]],
    locators =             [component]  
  )
  
; Checks if a pin is marked "no-connect"
defn no-connect? (p:JITXObject) -> True|False : 
  has-property?(p.no-connect) or
  has-property?(p.nc) or 
  has-property?(p.NC)

; Returns if a pin is a digital-io pin
defn is-digital-output? (p:JITXObject) -> True|False : 
  has-property?(p.digital-io) or 
  has-property?(p.digital-output)

; Returns if a pin is a digital-input pin
defn is-digital-input? (p:JITXObject) -> True|False : 
  has-property?(p.digital-io) or 
  has-property?(p.digital-input)

; Returns if a pin is a digital i/o pin 
defn is-digital-pin? (p:JITXObject) -> True|False :
  has-property?(p.digital-io) or
  has-property?(p.digital-input) or
  has-property?(p.digital-output)

; A PCB check that walks a module and verifies if all pins
; marked no-connect are indeed not connected
;
pcb-check no-connect-pins-not-connected (module:JITXObject) :
  val all-populated-pins = all-populated-pins(module)
  val nc-pins = filter(no-connect?, all-populated-pins)

  for p in nc-pins do :
    val populated-connected-pins = populated-connected-pins(p)

    #CHECK(
      condition =            empty?(populated-connected-pins)
      name =                 "IO pin checks"
      description =          "Check io pin properties"
      category =             "pin-check"
      subcheck-description = "Check that no-connect pads are not connected",
      pass-message =         "Pin %_ is marked no-connect and is correctly not connected" % [ref(p)],
      fail-message =         "Pin %_ is marked no-connect and is incorrectly connected to other pins: %," % [ref(p), seq(ref, populated-connected-pins)],
      locators =             [p])

defn pin-refs (digital-pins: Tuple<DigitalPin>) -> Tuple<Ref> :
  map(ref{pin(_)}, digital-pins)

defn to-jitx-pins (digital-pins: Tuple<DigitalPin>) -> Tuple<Pin> :
  map(pin, digital-pins)

defn check-digital-output (output-pins: Tuple<DigitalPin>) :
  ; If no output pins on the net, no need to record a passing check
  if not empty?(output-pins) :
    val non-tristateable-output-pins = to-tuple $ filter({not tristateable(prop(_))}, output-pins)

    #CHECK(condition =            length(non-tristateable-output-pins) >= 1
           name =                 "IO pin checks"
           description =          "Check io pin properties"
           category =             "pin-check"
           subcheck-description = "Check output pins are correctly connected",
           pass-message =         "Output pins %, are connected together and at most 1 of them is non-tristateable" % [pin-refs(output-pins)],
           fail-message =         "The following non-tristateable output pins are connected together: %," % [pin-refs(non-tristateable-output-pins)],
           locators =             to-jitx-pins(non-tristateable-output-pins))

defstruct DigitalPin <: Equalable :
  pin: Pin
  prop: ?

defmethod equal? (p1: DigitalPin, p2: DigitalPin) -> True|False :
  pin(p1) == pin(p2)

defstruct DigitalPinCategories :
  ios : Tuple<DigitalPin>
  inputs : Tuple<DigitalPin>
  outputs : Tuple<DigitalPin>
  all: Tuple<Pin>

defn categorize-digital-pins (pins: Seqable<Pin>) -> DigitalPinCategories :
  val ios = Vector<DigitalPin>()
  val inputs = Vector<DigitalPin>()
  val outputs = Vector<DigitalPin>()

  for p in pins do :
    ; TODO: Checking that rail-voltage propagation is correct for collector check, can remove later
    if has-property?(p.power-pin) and not has-property?(p.rail-voltage) :
      fatal("Power pin %_ does not have a rail voltage property" % [ref(p)])

    val io? = property?(p.digital-io)
    val i? = property?(p.digital-input)
    val o? = property?(p.digital-output)

    var count = 0
    if not empty?(io?) :
      add(ios, DigitalPin(p, value! $ io?))
      count = count + 1
    if not empty?(i?) :
      add(inputs, DigitalPin(p, value! $ i?))
      count = count + 1
    if not empty?(o?) :
      add(outputs, DigitalPin(p, value! $ o?))
      count = count + 1

    if count != 0 :
      #CHECK(
        condition =            count == 1,
        name =                 "IO pin checks"
        description =          "Check io pin properties"
        category =             "pin-check"
        subcheck-description = "Check that pins have at most 1 property amongst: digital-io, digital-input, digital-output",
        pass-message =         "Pin %_ has valid digital properties" % [ref(p)],
        fail-message =         "Pin %_ has invalid digital properties: digital-io=%_, digital-input=%_, digital-output=%_" % [ref(p), io?, i?, o?],
        locators =             [p])

  DigitalPinCategories(to-tuple(ios),
                to-tuple(inputs),
                to-tuple(outputs),
                to-tuple(pins))

; A check used to verify the electrical properties of
; digital i/o pins.
pcb-check digital-io-levels (module:JITXObject) :
  for connected-group in populated-connected-groups(module) do :
    val pin-categories = categorize-digital-pins(connected-group)

    ; Check at most 1 output pin in net
    check-digital-output $ outputs(pin-categories)

    ; Open collector checks
    val open-collectors = to-tuple $
      for resolved-pin in cat(ios(pin-categories), outputs(pin-categories)) filter :
        driver(prop(resolved-pin)) is OpenCollector

    if not empty?(open-collectors) :
      open-collector-checks(open-collectors, pin-categories)

    ; CMOS / TTL Output checks
    val cmos-ttl-outputs = to-tuple $
      for resolved-pin in cat(ios(pin-categories), outputs(pin-categories)) filter :
        driver(prop(resolved-pin)) is CMOSOutput|TTLOutput

    if not empty?(cmos-ttl-outputs) :
      cmos-and-ttl-checks(cmos-ttl-outputs, pin-categories)

; Checks any IO pins marked CMOSOutput or TLLOutput
defn cmos-and-ttl-checks (cmos-ttl-outputs:Tuple<DigitalPin>,
                          pin-categories:DigitalPinCategories) :
  val digital-pins = cat-all $ [ios(pin-categories), inputs(pin-categories), outputs(pin-categories)]
  for out-p in cmos-ttl-outputs do :
    for io-p in filter({_ != out-p}, ios(pin-categories)) do :
      check-single-push-pull-levels-with-ios(out-p, io-p)
    for in-p in inputs(pin-categories) do :
      check-single-push-pull-levels-with-inputs(out-p, in-p)

; Checks that run on a pin marked OpenCollector
; - io-pin: the pin we are checking
; - driver: the driver (value of driver(property(io-pin.digital-io)))
; - connected-group: the pins this pin is connected to
;
defn open-collector-checks (open-collectors:Tuple<DigitalPin>,
                            pin-categories:DigitalPinCategories) :
  val [pull-up-resistors, rail-voltages] = collect-pull-up-resistors-and-their-rail-voltages(open-collectors, pin-categories)
  check-a-pull-resistor-exists(open-collectors, pull-up-resistors)
  val rail-voltage = check-and-return-unique-rail-voltage(rail-voltages, pull-up-resistors, open-collectors)
  check-sink-current-meets-collector-ratings(rail-voltage, pull-up-resistors, open-collectors)
  check-input-and-generic-pin-max-voltage-rating(rail-voltage, pin-categories)

defn collect-pull-up-resistors-and-their-rail-voltages (open-collectors:Tuple<DigitalPin>, pin-categories: DigitalPinCategories) :
  val collected-rail-voltages = Vector<Double>()

  defn collect-rail-voltages-and-returns-if-any? (instance: Instance) -> True|False :
    val voltages = to-tuple $
      for p in pins(instance) seq? :
        property?(p.rail-voltage)

    add-all(collected-rail-voltages, voltages as Tuple<Double>)
    not empty?(voltages)

  ; lazy 'and', connected-to-rail? can be heavy
  defn pull-up? (instance) :
    has-property?(instance.resistance) and
    collect-rail-voltages-and-returns-if-any?(instance)

  for p in seq(pin, open-collectors) do :
    #CHECK(
      condition =            not has-property?(p.rail-voltage),
      name =                 "IO pin checks"
      description =          "Check io pin properties"
      category =             "pin-check"
      subcheck-description = "Check that io pins marked OpenCollector are not connected to a rail",
      pass-message =         "Open collector pin %_ is not directly connected to a rail." % [ref(p)],
      fail-message =         "Open collector pin %_ is directly connected to a rail." % [ref(p)],
      locators =             [p])

  ; First, we search for the pull-up-resistors that might be connected to this pin
  val pull-up-resistors = all(pin-categories) $> map{containing-instance!, _}
                                              $> unique
                                              $> filter{pull-up?, _}
                                              $> to-tuple

  [pull-up-resistors, to-tuple(collected-rail-voltages)]

defn open-collector-pass-message (open-collectors:Tuple<DigitalPin>, action: String|Printable) :
  if length(open-collectors) == 1 :
    "Pin %_ is marked OpenCollector and has %_" % [ref $ pin(open-collectors[0]), action]
  else :
    "Pins %, are marked OpenCollector on the same net and have %_" % [seq(ref{pin(_)}, open-collectors), action]

defn open-collector-fail-message (open-collectors:Tuple<DigitalPin>, action: String|Printable) :
  if length(open-collectors) == 1 :
    "Pin %_ is marked OpenCollector but does not have %_" % [ref $ pin(open-collectors[0]), action]
  else :
    "Pins %, are marked OpenCollector on the same net but do not have %_" % [seq(ref{pin(_)}, open-collectors), action]

defn check-a-pull-resistor-exists (open-collectors: Tuple<DigitalPin>, pull-up-resistors: Tuple<Instance>) :
  ; Check that there exists at least one pull-up-resistor
  #CHECK(
    condition =            not empty?(pull-up-resistors),
    name =                 "IO pin checks"
    description =          "Check io pin properties"
    category =             "pin-check"
    subcheck-description = "Check that io pins marked OpenCollector have at least one pull-up resistor",
    pass-message =         open-collector-pass-message(open-collectors, "at least one pull-up resistor"),
    fail-message =         open-collector-fail-message(open-collectors, "any pull-up resistor attached"),
    locators =             to-jitx-pins(open-collectors))

defn check-and-return-unique-rail-voltage (rail-voltages: Tuple<Double>, pull-up-resistors: Tuple<Instance>, open-collectors: Tuple<DigitalPin>) -> Double :
  #CHECK(
    condition =            all-equal?(rail-voltages),
    name =                 "IO pin checks"
    description =          "Check io pin properties"
    category =             "pin-check"
    subcheck-description = "Check that io pins marked OpenCollector have pull-up resistors connected to the same rail voltage",
    pass-message =         open-collector-pass-message(open-collectors, "all pull-up resistors with the same rail voltage"),
    fail-message =         open-collector-fail-message(open-collectors, "all pull-up resistors %, with the same rail voltage" % [seq(ref, pull-up-resistors)]),
    locators =             pull-up-resistors)

  ; Here we find the value of the rail voltage
  rail-voltages[0]

defn check-pull-up-resistor-does-not-have-0-ohm-resistance (resistor: JITXObject) -> Double :
  val resistance = property(resistor.resistance) as Double

  #CHECK(
    condition =            resistance != 0,
    name =                 "IO pin checks"
    description =          "Check io pin properties"
    category =             "pin-check"
    subcheck-description = "Check that io pins marked OpenCollector have pull-up resistors with non 0-ohm resistance",
    pass-message =         "Pull-up resistor %_ does not have 0-ohm resistance." % [ref(resistor)],
    fail-message =         "Pull-up resistor %_ has 0-ohm resistance." % [ref(resistor)],
    locators =             [resistor])

  resistance

defn compute-equivalent-resistance (pull-up-resistors: Tuple<Instance>) :
  ; And the total resistance of parallel connected
  ; pull-up resistors
  1.0 / sum $
    for resistor in pull-up-resistors seq :
      val resistance = check-pull-up-resistor-does-not-have-0-ohm-resistance(resistor)
      1.0 / resistance

defn check-sink-current-meets-collector-ratings (rail-voltage: Double, pull-up-resistors: Tuple<Instance>, open-collectors: Tuple<DigitalPin>) :
  val equivalent-resistance = compute-equivalent-resistance(pull-up-resistors)
  ; Next, compute the sink current (V / R) and check if it is in spec for the driver.
  val sink-current = rail-voltage / equivalent-resistance
  for open-collector in open-collectors do :
    val driver = driver $ prop(open-collector)
    #CHECK(condition =            sink-current < iol(driver),
           name =                 "IO pin checks"
           description =          "Check io pin properties"
           category =             "pin-check"
           subcheck-description = "Check open collector pin sink current requirement versus resistance specification",
           pass-message =         "Open collector pin %_ current sink specification %_A satisfies the design requirement %_A" %   [ref $ pin(open-collector), iol(driver), sink-current],
           fail-message =         "Open collector pin %_ current specification %_A does not satisfy the design requirement %_A" % [ref $ pin(open-collector), iol(driver), sink-current],
           locators =             [pin(open-collector)])

defn check-input-and-generic-pin-max-voltage-rating (rail-voltage: Double, pin-categories: DigitalPinCategories) :
  ; Now we need to check on any io-pins connected to this output pin
  val input-pins = cat(ios(pin-categories), inputs(pin-categories))
  for p in input-pins do :
    val pin = pin(p)
    val input-prop = prop(p)
    ; Check that the max voltage rating of the input pin is below that of the rail voltage
    match(input-prop: DigitalInput|DigitalIO) :
      val vih-v = vih(input-prop)
      #CHECK(condition =            rail-voltage > vih-v,
             name =                 "IO pin checks"
             description =          "Check io pin properties"
             category =             "pin-check"
             subcheck-description = "Check power supply rail is higher than the vih pin specification",
             pass-message =         "Input pin %_ vih specification %_V is correctly lower than the power supply rail %_V"    % [ref $ pin, vih-v, rail-voltage],
             fail-message =         "Input pin %_ vih specification %_V is incorrectly higher than the power supply rail %_V" % [ref $ pin, vih-v, rail-voltage],
             locators =             [pin])

    ; If the pin has generic pin props, check that rail voltage is in range.
    val generic-pin = property?(pin.generic-pin)
    match(generic-pin:One<GenericPin>) :
      val max-voltage = max-voltage(value(generic-pin))
      #CHECK(
        condition =            in-range?(max-voltage, rail-voltage),
        name =                 "IO pin checks"
        description =          "Check io pin properties"
        category =             "pin-check"
        subcheck-description = "Check pin maximum voltage is within the design specification",
        pass-message =         "Generic pin %_ maximum voltage %_V is correctly within the power supply specification %_V"    % [ref $ pin, max-voltage, rail-voltage],
        fail-message =         "Generic pin %_ maximum voltage %_V is incorrectly outside the power supply specification %_V" % [ref $ pin, max-voltage, rail-voltage],
        locators =             [pin]
      )

; Run the general purpose io checks
public defn check-io (module:JITXObject) :
  inside pcb-module :
    ; No-connects are not-connected
    check no-connect-pins-not-connected(module)
    ; The io-levels match
    check digital-io-levels(module)

; Checks two push-pull digital logic pins, at least one of which can output
public defn check-single-push-pull-levels-with-inputs (out-p:DigitalPin, in-p:DigitalPin) :
  val out-prop = prop(out-p)
  val out-pin = pin(out-p)
  val in-prop = prop(in-p)
  val in-pin = pin(in-p)

  val [vih vil] = [vih(in-prop), vil(in-prop)]
  val [driver-voh, driver-vol] = [voh $ driver(out-prop), vol $ driver(out-prop)]

  #CHECK(
    condition =            connected?([gnd-pin(out-prop) gnd-pin(in-prop)]),
    name =                 "IO pin checks"
    description =          "Check io pin properties"
    category =             "pin-check"
    subcheck-description = "Verify input pin is referenced to ground of the output driver",
    pass-message =         "Gnd of the input pin %_ is correctly referenced to the ground net of the driver pin %_" % [ref(in-pin), ref(out-pin)],
    fail-message =         "Gnd of the input pin %_ is not correctly referenced to the ground net of the driver pin %_" % [ref(in-pin), ref(out-pin)],
    locators =             [out-pin, in-pin]
  )
  #CHECK(
    condition =            min-value(driver-voh) >= vih,
    name =                 "IO pin checks"
    description =          "Check io pin properties"
    category =             "pin-check"
    subcheck-description = "Verify min voh of output driver is higher than the vih of the input pin",
    pass-message =         "Output pin %_ min voh %_ is compatible with the input pin %_ vih %_" % [ref(out-pin), min-value(driver-voh), ref(in-pin), vih],
    fail-message =         "Output pin %_ min voh %_ is not compatible with the input pin %_ vih %_" % [ref(out-pin), min-value(driver-voh), ref(in-pin), vih],
    locators =             [out-pin, in-pin]
  )
  #CHECK(
    condition =            max-value(driver-vol) <= vil,
    name =                 "IO pin checks"
    description =          "Check io pin properties"
    category =             "pin-check"
    subcheck-description = "Verify max vol of output driver is compatible with the vil of the input pin",
    pass-message =         "Output pin %_ max vol %_ is compatible with the input pin %_ vil %_" % [ref(out-pin), max-value(driver-vol), ref(in-pin), vil],
    fail-message =         "Output pin %_ max vol %_ is not compatible with the input pin %_ vil %_" % [ref(out-pin), max-value(driver-vol), ref(in-pin), vil],
    locators =             [out-pin, in-pin]
  )

  val generic-in-prop? = property?(in-pin.generic-pin)
  match(generic-in-prop?: One) :
    val max-input-voltage = max-voltage $ value(generic-in-prop?)
    #CHECK(
      condition =            in-range?(max-input-voltage, driver-voh),
      name =                 "IO pin checks"
      description =          "Check io pin properties"
      category =             "pin-check"
      subcheck-description = "Verify voh of output driver is compatible with voltage range of a generic pin",
      pass-message =         "Output pin %_ max voh %_ is compatible with the voltage range of the generic pin %_ of %_" % [ref(out-pin), driver-voh, ref(in-pin), max-input-voltage],
      fail-message =         "Output pin %_ max voh %_ is not compatible with the voltage range of the generic pin %_ of %_" % [ref(out-pin), driver-voh, ref(in-pin), max-input-voltage],
      locators =             [out-pin, in-pin]
    )

; Checks two push-pull digital logic pins, at least one of which can output
public defn check-single-push-pull-levels-with-ios (out-p:DigitalPin, io-p:DigitalPin) :
  val out-prop = prop(out-p)
  val out-pin = pin(out-p)
  val io-prop = prop(io-p)
  val io-pin = pin(io-p)

  val [vih vil] = [vih(io-prop), vil(io-prop)]
  val [driver-voh, driver-vol] = [voh $ driver(out-prop), vol $ driver(out-prop)]

  #CHECK(
    condition =            connected?([gnd-pin(out-prop) gnd-pin(io-prop)]),
    name =                 "IO pin checks"
    description =          "Check io pin properties"
    category =             "pin-check"
    subcheck-description = "Verify the digital io pin is referenced to the ground of the output driver",
    pass-message =         "Gnd of the io pin %_ is correctly referenced to the ground net of the driver pin %_" % [ref(io-pin), ref(out-pin)],
    fail-message =         "Gnd of the io pin %_ is not correctly referenced to the ground net of the driver pin %_" % [ref(io-pin), ref(out-pin)],
    locators =             [io-pin]
  )
  val io-driver = driver(io-prop)
  #CHECK(
    condition =            io-driver is CMOSOutput|TTLOutput,
    name =                 "IO pin checks"
    description =          "Check io pin properties"
    category =             "pin-check"
    subcheck-description = "Verify io driver is either CMOS or TTL",
    pass-message =         "IO pin %_ has the correct driver property property attached" % [ref(io-pin)],
    fail-message =         "IO pin %_ does not have the correct driver property property attached" % [ref(io-pin)],
    locators =             [io-pin]
  )
  val [vih-v vil-v] = [vih(io-prop) vil(io-prop)]
  #CHECK(
    condition =            min-value(driver-voh) >= vih-v,
    name =                 "IO pin checks"
    description =          "Check io pin properties"
    category =             "pin-check"
    subcheck-description = "Verify min voh of output driver is higher than the vih of the input pin",
    pass-message =         "Output pin %_ min voh %_ is compatible with the input pin %_ vih %_" % [ref(out-pin), min-value(driver-voh), ref(io-pin), vih-v],
    fail-message =         "Output pin %_ min voh %_ is not compatible with the input pin %_ vih %_" % [ref(out-pin), min-value(driver-voh), ref(io-pin), vih-v],
    locators =             [out-pin, io-pin]
  )
  #CHECK(
    condition =            max-value(driver-vol) <= vil-v,
    name =                 "IO pin checks"
    description =          "Check io pin properties"
    category =             "pin-check"
    subcheck-description = "Verify max vol of output driver is compatible with the vil of the input pin",
    pass-message =         "Output pin %_ max vol %_ is compatible with the input pin %_ vil %_" % [ref(out-pin), max-value(driver-vol), ref(io-pin), vil-v],
    fail-message =         "Output pin %_ max vol %_ is not compatible with the input pin %_ vil %_" % [ref(out-pin), max-value(driver-vol), ref(io-pin), vil-v],
    locators =             [out-pin, io-pin]
  )
  if has-property?(out-pin.digital-io):
    #CHECK(
      condition =            min-value(voh(io-driver)) >= vih(out-prop),
      name =                 "IO pin checks"
      description =          "Check io pin properties"
      category =             "pin-check"
      subcheck-description = "Verify min voh of io driver is higher than the vih of the io pin",
      pass-message =         "IO pin %_ min voh %_ is compatible with the io pin %_ vih %_" % [ref(io-pin), min-value(voh(io-driver)), ref(out-pin), vih(out-prop)],
      fail-message =         "IO pin %_ min voh %_ is not compatible with the io pin %_ vih %_" % [ref(io-pin), min-value(voh(io-driver)), ref(out-pin), vih(out-prop)],
      locators =             [io-pin]
    )
    #CHECK(
      condition =            max-value(vol(io-driver)) <= vil(out-prop),
      name =                 "IO pin checks"
      description =          "Check io pin properties"
      category =             "pin-check"
      subcheck-description = "Verify max vol of io driver is compatible with the vil of the io pin",
      pass-message =         "IO pin %_ max vol %_ is compatible with the io pin %_ vil %_" % [ref(io-pin), max-value(vol(io-driver)), ref(out-pin), vil(out-prop)],
      fail-message =         "IO pin %_ max vol %_ is not compatible with the io pin %_ vil %_" % [ref(io-pin), max-value(vol(io-driver)), ref(out-pin), vil(out-prop)],
      locators =             [out-pin, io-pin]
    )

  val generic-io-prop? = property?(io-pin.generic-pin)
  match(generic-io-prop?: One) :
    val max-input-voltage = max-voltage $ value(generic-io-prop?)
    #CHECK(
      condition =            in-range?(max-input-voltage, voh(driver(out-prop))),
      name =                 "IO pin checks"
      description =          "Check io pin properties"
      category =             "pin-check"
      subcheck-description = "Verify voh of output driver is compatible with voltage range of a generic pin",
      pass-message =         "Output pin %_ max voh %_ is compatible with the voltage range of the generic pin %_ of %_" % [ref(out-pin), driver-voh, ref(io-pin), max-input-voltage],
      fail-message =         "Output pin %_ max voh %_ is not compatible with the voltage range of the generic pin %_ of %_" % [ref(out-pin), driver-voh, ref(io-pin), max-input-voltage],
      locators =             [out-pin, io-pin]
    )

  val generic-out-prop? = property?(out-pin.generic-pin)
  match(generic-io-prop?: One) :
    val max-input-voltage = max-voltage $ value(generic-io-prop?)
    #CHECK(
      condition =            in-range?(max-input-voltage, voh(io-driver)),
      name =                 "IO pin checks"
      description =          "Check io pin properties"
      category =             "pin-check"
      subcheck-description = "Verify voh of output driver is compatible with voltage range of a generic pin",
      pass-message =         "IO pin %_ max voh %_ is compatible with the voltage range of the generic pin %_ of %_" % [ref(io-pin), voh(io-driver), ref(out-pin), max-input-voltage],
      fail-message =         "IO pin %_ max voh %_ is not compatible with the voltage range of the generic pin %_ of %_" % [ref(io-pin), voh(io-driver), ref(out-pin), max-input-voltage],
      locators =             [out-pin, io-pin]
    )

public pcb-check connected (p:JITXObject|Tuple<JITXObject>) :
  val name = "connected net checks"
  val description = "Check that the object(s) are connected"
  val category = "net-check"

  ;Helper function used by object-connected-message and objects-connected-message
  defn connected-str (connected?:True|False) -> String :
    "connected" when connected? else "not connected"

  ;Prepare the appropriate message for checking if a single object is connected to the design.
  defn object-connected-message (obj:JITXObject, connected?:True|False) -> Printable :
    "Object %_ is %_" % [ref(obj), connected-str(connected?)]
  
  ;Prepare the appropriate message for checking if a Tuple of objects are connected to each other.
  defn objects-connected-message (objs:Tuple<JITXObject>, connected?:True|False) -> Printable :
    "Objects %, are %_" % [map(ref, objs), connected-str(connected?)]

  val [pass-message, fail-message, locators] =
    match(p) :
      (p:JITXObject) :
        [object-connected-message(p, true),
         object-connected-message(p, false),
         [p]]
      (p:Tuple<JITXObject>) :
        [objects-connected-message(p, true),
         objects-connected-message(p, false),
         p]

  #CHECK(
    condition =            connected?(p),
    name =                 "connected net checks"
    description =          "Check that the object(s) are connected"
    category =             "net-check"
    subcheck-description = "Verify object is connected",
    pass-message =         pass-message,
    fail-message =         fail-message,
    locators =             locators
  )

; Checks any generic pin for rated voltage
public pcb-check generic-pin-check (p:JITXObject):
  val name = "Generic pin checks"
  val description = "Check generic pin properties"
  val category = "pin-check"
  if (has-property?(p.rail-voltage)) :
    val p-props = property(p.generic-pin)
    ; Check that the maxima are never crossed
    #CHECK(
      condition =            p-props is GenericPin,
      name =                 "Generic pin checks"
      description =          "Check generic pin properties"
      category =             "pin-check"
      subcheck-description = "Verify pin has the generic pin property expected",
      pass-message =         "Pin %_ is marked correctly as a generic pin" % [ref(p)],
      fail-message =         "Pin %_ is not marked as a generic pin" % [ref(p)],
      locators =             [p]
    )
    #CHECK(
      condition =            in-range?(max-voltage(p-props), property(p.rail-voltage)),
      name =                 "Generic pin checks"
      description =          "Check generic pin properties"
      category =             "pin-check"
      subcheck-description = "Verify generic pin is compatible with the design supply voltage range",
      pass-message =         "Generic pin %_ max-voltage %_ is compatible with the supply voltage range %_" % [ref(p), max-voltage(p-props), property(p.rail-voltage)],
      fail-message =         "Generic pin %_ max-voltage %_ is not compatible with the supply voltage range %_" % [ref(p), max-voltage(p-props), property(p.rail-voltage)],
      locators =             [p]
    )

; Checks a power pin located on an active component
public pcb-check power-pin-check (p:JITXObject) :
  val name = "Power pin checks"
  val description = "Check power pin properties"
  val category = "pin-check"
  #CHECK(
    condition =            has-property?(p.power-pin),
    name =                 "Power pin checks"
    description =          "Check power pin properties"
    category =             "pin-check"
    subcheck-description = "Verify power pins have the correct power-pin property",
    pass-message =         "Pin %_ has the correct power-pin property attached" % [ref(p)],
    fail-message =         "Pin %_ does not have the correct power-pin property attached" % [ref(p)],
    locators =             [p]
  )

  val p-props = property(p.power-pin)
  #CHECK(
    condition =            p-props is PowerPin,
    name =                 "Power pin checks"
    description =          "Check power pin properties"
    category =             "pin-check"
    subcheck-description = "Verify power pins have the correct power-pin type property",
    pass-message =         "Pin %_ has the correct power-pin type property attached" % [ref(p)],
    fail-message =         "Pin %_ does not have the correct power-pin type property attached" % [ref(p)],
    locators =             [p]
  )
  ; println("%_ has power" % [ref(p)])
  #CHECK(
    condition =            has-property?(p.rail-voltage),
    name =                 "Power pin checks"
    description =          "Check power pin properties"
    category =             "pin-check"
    subcheck-description = "Verify power pins have the correct rail-voltage property",
    pass-message =         "Pin %_ has the correct rail-voltage property attached of %_V" % [ref(p), property(p.rail-voltage)],
    fail-message =         "Pin %_ does not have the correct rail-voltage property attached" % [ref(p)],
    locators =             [p]
  )
  ; println("%_ has %_" % [ref(p) property(p.rail-voltage)])
  #CHECK(
    condition =            in-range?(recommended-voltage(p-props), property(p.rail-voltage)),
    name =                 "Power pin checks"
    description =          "Check power pin properties"
    category =             "pin-check"
    subcheck-description = "Check power pin rail-voltage property is within the design specification",
    pass-message =         "Power pin %_ rail voltage %_V is correctly within the design specification %_V" % [ref(p),property(p.rail-voltage),recommended-voltage(p-props)],
    fail-message =         "Power pin %_ rail voltage %_V is not correctly within the design specification %_V" % [ref(p),property(p.rail-voltage),recommended-voltage(p-props)],
    locators =             [p]
  )

public pcb-check reset-pin-check (p:JITXObject) :
  val name = "Reset pin checks"
  val description = "Check reset pin properties"
  val category = "pin-check"
  #CHECK(
    condition =            has-property?(p.reset-pin),
    name =                 "Reset pin checks"
    description =          "Check reset pin properties"
    category =             "pin-check"
    subcheck-description = "Verify reset pins have the correct reset-pin property",
    pass-message =         "Reset pin %_ has the correct reset-pin property attached" % [ref(p)],
    fail-message =         "Reset pin %_ does not have the correct reset-pin property attached" % [ref(p)],
    locators =             [p]
  )

  val p-props = property(p.reset-pin)
  #CHECK(
    condition =            p-props is ResetPin,
    name =                 "Reset pin checks"
    description =          "Check reset pin properties"
    category =             "pin-check"
    subcheck-description = "Verify reset pins have the correct reset-pin type property",
    pass-message =         "Reset pin %_ has the correct reset-pin type property attached" % [ref(p)],
    fail-message =         "Reset pin %_ does not have the correct reset-pin type property attached" % [ref(p)],
    locators =             [p]
  )
  ; Improve this to check togglability
  #CHECK(
    condition =            connected?(p),
    name =                 "Reset pin checks"
    description =          "Check reset pin properties"
    category =             "pin-check"
    subcheck-description = "Verify reset pins have the correct connectivity",
    pass-message =         "Reset pin %_ has the correct connectivity" % [ref(p)],
    fail-message =         "Reset pin %_ does not have the correct connectivity" % [ref(p)],
    locators =             [p]
  )


defn check-rated-voltage (p:JITXObject) :
  val rating = property(p.rated-voltage)
  val v = property(p.voltage)
  match(rating, v):
    (r:Double, v:Double) : #CHECK(
                              condition =            property(p.rated-voltage) >= v,
                              name =                 "Check rated-voltage property"
                              description =          "Check design for the correct rated-voltage value"
                              category =             "rated-voltage"
                              subcheck-description = "Check pin rated voltage is within the design voltage specification",
                              pass-message =         "Pin %_ rated voltage %_V is correctly within the design supply specification %_V" % [ref(p),property(p.rated-voltage),v],
                              fail-message =         "Pin %_ rated voltage %_V is incorrectly outside the design supply specification %_V" % [ref(p),property(p.rated-voltage),v],
                              locators =             [p]
                            )
    (r:[Double,Double], v:Double) : 
      #CHECK(
        condition =            property(p.rated-voltage)[1] >= v,
        name =                 "Check rated-voltage property"
        description =          "Check design for the correct rated-voltage value"
        category =             "rated-voltage"
        subcheck-description = "Check pin rated voltage is within the design voltage specification",
        pass-message =         "Pin %_ rated voltage %_V high is correctly within the design supply specification %_V" % [ref(p),property(p.rated-voltage)[1],v],
        fail-message =         "Pin %_ rated voltage %_V high is incorrectly outside the design supply specification %_V" % [ref(p),property(p.rated-voltage)[1],v],
        locators =             [p]
      )
      #CHECK(
        condition =            property(p.rated-voltage)[0] <= v,
        name =                 "Check rated-voltage property"
        description =          "Check design for the correct rated-voltage value"
        category =             "rated-voltage"
        subcheck-description = "Check pin rated voltage is within the design voltage specification",
        pass-message =         "Pin %_ rated voltage %_V low is correctly within the design supply specification %_V" % [ref(p),property(p.rated-voltage)[0],v],
        fail-message =         "Pin %_ rated voltage %_V low is incorrectly outside the design supply specification %_V" % [ref(p),property(p.rated-voltage)[0],v],
        locators =             [p]
      )
    (r:[Double,Double], v:[Double|Double|Double]) : 
      #CHECK(
        condition =            property(p.rated-voltage)[1] >= v[2],
        name =                 "Check rated-voltage property"
        description =          "Check design for the correct rated-voltage value"
        category =             "rated-voltage"
        subcheck-description = "Check pin rated voltage is within the design voltage specification",
        pass-message =         "Pin %_ rated voltage %_V high is correctly within the design supply specification %_V" % [ref(p),property(p.rated-voltage)[1],v[2]],
        fail-message =         "Pin %_ rated voltage %_V high is incorrectly outside the design supply specification %_V" % [ref(p),property(p.rated-voltage)[1],v[2]],
        locators =             [p]
      )
      #CHECK(
        condition =            property(p.rated-voltage)[0] <= v[0],
        name =                 "Check rated-voltage property"
        description =          "Check design for the correct rated-voltage value"
        category =             "rated-voltage"
        subcheck-description = "Check pin rated voltage is within the design voltage specification",
        pass-message =         "Pin %_ rated voltage %_V low is correctly within the design supply specification %_V" % [ref(p),property(p.rated-voltage)[0],v[0]],
        fail-message =         "Pin %_ rated voltage %_V low is incorrectly outside the design supply specification %_V" % [ref(p),property(p.rated-voltage)[0],v[0]],
        locators =             [p]
      )
    (r, v) : false

; Checks if voltage on a pin is within acceptable limits
public pcb-check voltage-levels (p:JITXObject, range:[Double,Double,Double]) :
  val name = "Voltage level pin checks"
  val description = "Check voltage pin properties"
  val category = "pin-check"

  #CHECK(
    condition =            has-property?(p.voltage),
    name =                 "Voltage level pin checks"
    description =          "Check voltage pin properties"
    category =             "pin-check"
    subcheck-description = "Check pin has voltage property",
    pass-message =         "Pin %_ has a property for voltage" % [ref(p)],
    fail-message =         "Pin %_ does not have a property for voltage" % [ref(p)],
    locators =             [p]
  )
  #CHECK(
    condition =            property(p.voltage)[0] >= range[0],
    name =                 "Voltage level pin checks"
    description =          "Check voltage pin properties"
    category =             "pin-check"
    subcheck-description = "Check pin voltage is within the design voltage specification",
    pass-message =         "Pin %_ rated voltage %_V low is correctly within the design range specification %_V" % [ref(p),property(p.voltage)[0],range[0]],
    fail-message =         "Pin %_ rated voltage %_V low is incorrectly outside the design range specification %_V" % [ref(p),property(p.voltage)[0],range[0]],
    locators =             [p]
  )
  #CHECK(
    condition =            property(p.voltage)[2] <= range[2],
    name =                 "Voltage level pin checks"
    description =          "Check voltage pin properties"
    category =             "pin-check"
    subcheck-description = "Check pin rated voltage is within the design voltage specification",
    pass-message =         "Pin %_ rated voltage %_V high is correctly within the design range specification %_V" % [ref(p),property(p.voltage)[2],range[2]],
    fail-message =         "Pin %_ rated voltage %_V high is incorrectly outside the design range specification %_V" % [ref(p),property(p.voltage)[2],range[2]],
    locators =             [p]
  )

; ====== Component-level checks ======
; ====================================
; public pcb-check pull-up-check (p:JITXObject) :

public pcb-check diode-component (d:JITXObject) :
  val name = "Diode checks"
  val description = "Check diode component properties"
  val category = "component-check"

  ; should check that pins of the diode are connected (if they don't have a NC property)
  for d-pin in pins(d) do :
    if not no-connect?(d-pin) :
      val conn-pin = populated-connected-pins(d-pin)
      #CHECK(
        condition =            not empty?(conn-pin),
        name =                 "Diode checks"
        description =          "Check that the diode pins are connected"
        category =             "component-check"
        subcheck-description = "Check diode component is connected property",
        pass-message =         "Diode %_ pin %_ is connected properly" % [ref(d), ref(d-pin)],
        fail-message =         "Diode %_ pin %_ is not connected properly" % [ref(d), ref(d-pin)],
        locators =             [d]
      )


public pcb-check inductor-component (l:JITXObject) :
  val name = "Inductor checks"
  val description = "Check inductor component properties"
  val category = "component-check"

  ; should check that pins of the resistor are connected (if they don't have a NC property)
  for l-pin in pins(l) do :
    if not no-connect?(l-pin) :
      val conn-pin = populated-connected-pins(l-pin)
      #CHECK(
        condition =            not empty?(conn-pin),
        name =                 "Inductor checks"
        description =          "Check that the inductor pins are connected"
        category =             "component-check"
        subcheck-description = "Check inductor component is connected property",
        pass-message =         "Inductor %_ pin %_ is connected properly" % [ref(l), ref(l-pin)],
        fail-message =         "Inductor %_ pin %_ is not connected properly" % [ref(l), ref(l-pin)],
        locators =             [l]
      )

  #CHECK(
    condition =            has-property?(l.inductance),
    name =                 "Inductor checks"
    description =          "Check inductor component properties"
    category =             "component-check"
    subcheck-description = "Check inductor component has the correct inductance property",
    pass-message =         "Inductor %_ has the correct inductance property for an inductor" % [ref(l)],
    fail-message =         "Inductor %_ does not have the correct inductance property for an inductor" % [ref(l)],
    locators =             [l]
  )

  if has-property?(l.operating-point) :
    #CHECK(
      condition =            has-property?(l.operating-point),
      name =                 "Inductor checks"
      description =          "Check inductor component properties"
      category =             "component-check"
      subcheck-description = "Check inductor component has the correct inductor property",
      pass-message =         "Inductor %_ has the correct property for operating-point" % [ref(l)],
      fail-message =         "Inductor %_ does not have the correct property for the operating-point" % [ref(l)],
      locators =             [l]
    )

    val [vpk, i, temp] = [[min-value(peak-voltage(property(l.operating-point)))
                          max-value(peak-voltage(property(l.operating-point)))],
                          max-value(peak-current(property(l.operating-point))),
                          OPERATING-TEMPERATURE[1]]

    val power = property(l.dc-resistance) * pow(i, 2.0) ; just using the DC formula
    if has-property?(l.derating) and has-property?(l.rated-power):
      ; Derate the power based on the piecewise linear curve from MFG
      val derating = PWL(property(l.derating))[temp]
      val pwr = derating * property(l.rated-power)
      #CHECK(
        condition =            pwr * DERATE-INDUCTOR-POWER > power,
        name =                 "Inductor checks"
        description =          "Check inductor component properties"
        category =             "component-check"
        subcheck-description = "Check inductor power derating meets the design requirements",
        pass-message =         "Inductor %_ power derating %_W meets the design requirements of %_W" % [ref(l), pwr * DERATE-RESISTOR-POWER, power],
        fail-message =         "Inductor %_ power derating %_W does not meet the design requirements of %_W" % [ref(l), pwr * DERATE-RESISTOR-POWER, power],
        locators =             [l]
      )
    else :
      ; Derate the power if MFG derating is missing
      ; adapted from http://www.interfacebus.com/Component_Derating_Guide_line.html but substituting r for l-dc-resistance
      val derating = PWL([[0.0 1.0] [70.0 1.0] [110.0 0.8] [150.0 0.6] [190.0 0.4] [240.0 0.2] [260.0 0.1]])[temp]
      val pwr = derating * property(l.rated-power)
      #CHECK(
        condition =            pwr * DERATE-INDUCTOR-POWER > power,
        name =                 "Inductor checks"
        description =          "Check inductor component properties"
        category =             "component-check"
        subcheck-description = "Check inductor default power derating meets the design requirements",
        pass-message =         "Inductor %_ default power derating %_W meets the design requirements of %_W" % [ref(l), pwr * DERATE-RESISTOR-POWER, power],
        fail-message =         "Inductor %_ default power derating %_W does not meet the design requirements of %_W" % [ref(l), pwr * DERATE-RESISTOR-POWER, power],
        locators =             [l]
      )


; Checks resistors against operating point and environment
public pcb-check resistor-component (r:JITXObject) :
  val name = "Resistor checks"
  val description = "Check resistor component properties"
  val category = "component-check"

  ; should check that pins of the resistor are connected (if they don't have a NC property)
  for r-pin in pins(r) do :
    if not no-connect?(r-pin) :
      val conn-pin = populated-connected-pins(r-pin)
      #CHECK(
        condition =            not empty?(conn-pin),
        name =                 "Resistor checks"
        description =          "Check that the resistor pins are connected"
        category =             "component-check"
        subcheck-description = "Check resistor component is connected property",
        pass-message =         "Resistor %_ pin %_ is connected properly" % [ref(r), ref(r-pin)],
        fail-message =         "Resistor %_ pin %_ is not connected properly" % [ref(r), ref(r-pin)],
        locators =             [r]
      )

  #CHECK(
    condition =            has-property?(r.resistance),
    name =                 "Resistor checks"
    description =          "Check resistor component properties"
    category =             "component-check"
    subcheck-description = "Check resistor component has the correct resistance property",
    pass-message =         "Resistor %_ has the correct resistance property for resistor" % [ref(r)],
    fail-message =         "Resistor %_ does not have the correct resistance property for a resistor" % [ref(r)],
    locators =             [r]
  )
  if has-property?(r.operating-point) :
    #CHECK(
      condition =            has-property?(r.operating-point),
      name =                 "Resistor checks"
      description =          "Check resistor component properties"
      category =             "component-check"
      subcheck-description = "Check resistor component has the correct operating-point property",
      pass-message =         "Resistor %_ has the correct property for operating-point" % [ref(r)],
      fail-message =         "Resistor %_ does not have the correct property for the operating-point" % [ref(r)],
      locators =             [r]
    )

    val [vpk, i, temp] = [[min-value(peak-voltage(property(r.operating-point)))
                          max-value(peak-voltage(property(r.operating-point)))],
                          max-value(peak-current(property(r.operating-point))),
                          OPERATING-TEMPERATURE[1]]

    val power = property(r.resistance) * pow(i, 2.0)
    if has-property?(r.derating) :
      ; Derate the power based on the piecewise linear curve from MFG
      val derating = PWL(property(r.derating))[temp]
      val pwr = derating * property(r.rated-power)
      #CHECK(
        condition =            pwr * DERATE-RESISTOR-POWER > power,
        name =                 "Resistor checks"
        description =          "Check resistor component properties"
        category =             "component-check"
        subcheck-description = "Check resistor power derating meets the design requirements",
        pass-message =         "Resistor %_ power derating %_W meets the design requirements of %_W" % [ref(r), pwr * DERATE-RESISTOR-POWER, power],
        fail-message =         "Resistor %_ power derating %_W does not meet the design requirements of %_W" % [ref(r), pwr * DERATE-RESISTOR-POWER, power],
        locators =             [r]
      )
    else :
      ; Derate the power if MFG derating is missing
      val derating = PWL([[0.0 1.0] [70.0 1.0] [110.0 0.8] [150.0 0.6] [190.0 0.4] [240.0 0.2] [260.0 0.1]])[temp]
      val pwr = derating * property(r.rated-power)
      #CHECK(
        condition =            pwr * DERATE-RESISTOR-POWER > power,
        name =                 "Resistor checks"
        description =          "Check resistor component properties"
        category =             "component-check"
        subcheck-description = "Check resistor default power derating meets the design requirements",
        pass-message =         "Resistor %_ default power derating %_W meets the design requirements of %_W" % [ref(r), pwr * DERATE-RESISTOR-POWER, power],
        fail-message =         "Resistor %_ default power derating %_W does not meet the design requirements of %_W" % [ref(r), pwr * DERATE-RESISTOR-POWER, power],
        locators =             [r]
      )

public pcb-check capacitor-component (c:JITXObject) :
  val name = "Capacitor checks"
  val description = "Check capacitor component properties"
  val category = "component-check"

  ; should check that pins of the cap are connected (if they don't have a NC property)
  for c-pin in pins(c) do :
    if not no-connect?(c-pin) :
      val conn-pin = populated-connected-pins(c-pin)
      #CHECK(
        condition =            not empty?(conn-pin),
        name =                 "Capacitor checks"
        description =          "Check that the capacitor pins are connected"
        category =             "component-check"
        subcheck-description = "Check capacitor component is connected property",
        pass-message =         "Capacitor %_ pin %_ is connected properly" % [ref(c), ref(c-pin)],
        fail-message =         "Capacitor %_ pin %_ is not connected properly" % [ref(c), ref(c-pin)],
        locators =             [c]
      )

  #CHECK(
    condition =            has-property?(c.capacitance),
    name =                 "Capacitor checks"
    description =          "Check capacitor component properties"
    category =             "component-check"
    subcheck-description = "Check capacitor component has the correct capacitance property",
    pass-message =         "Capacitor %_ has the correct capacitance property for a capacitor" % [ref(c)],
    fail-message =         "Capacitor %_ does not have the correct capacitance property for a capacitor" % [ref(c)],
    locators =             [c]
  )

  if has-property?(c.operating-point) :
    #CHECK(
      condition =            has-property?(c.operating-point),
      name =                 "Capacitor checks"
      description =          "Check capacitor component properties"
      category =             "component-check"
      subcheck-description = "Check capacitor component has the correct operating-point property",
      pass-message =         "Capacitor %_ has the correct property for operating-point" % [ref(c)],
      fail-message =         "Capacitor %_ does not have the correct property for the operating-point" % [ref(c)],
      locators =             [c]
    )
    val [vpk temp] = [[min-value(peak-voltage(property(c.operating-point))) max-value(peak-voltage(property(c.operating-point)))] OPERATING-TEMPERATURE[1]]
    val max-temp = max-value(operating-temperature(property(c.rated-temperature)))
    switch(property(c.type)) :
      "ceramic" :
        val vpk-derate-wc = PWL(DERATE-CAPACITOR-MLCC-VPK-WC)[temp]
        #CHECK(
          condition =            vpk[0] <= (vpk-derate-wc * property(c.rated-voltage)),
          name =                 "Capacitor checks"
          description =          "Check capacitor component properties"
          category =             "component-check"
          subcheck-description = "Check ceramic capacitor voltage derating matches the operating-point voltage",
          pass-message =         "Capacitor %_ voltage derating %_V is compatible with the wc design constraint %_V" % [ref(c),vpk[0],(vpk-derate-wc * property(c.rated-voltage))],
          fail-message =         "Capacitor %_ voltage derating %_V is not compatible with the wc design constraint %_V" % [ref(c),vpk[0],(vpk-derate-wc * property(c.rated-voltage))],
          locators =             [c]
        )

        #CHECK(
          condition =            vpk[1] <= (vpk-derate-wc * property(c.rated-voltage)),
          name =                 "Capacitor checks"
          description =          "Check capacitor component properties"
          category =             "component-check"
          subcheck-description = "Check ceramic capacitor voltage derating matches the operating-point voltage",
          pass-message =         "Capacitor %_ voltage derating %_V is compatible with the wc design constraint %_V" % [ref(c),vpk[1],(vpk-derate-wc * property(c.rated-voltage))],
          fail-message =         "Capacitor %_ voltage derating %_V is not compatible with the wc design constraint %_V" % [ref(c),vpk[1],(vpk-derate-wc * property(c.rated-voltage))],
          locators =             [c]
        )

        val vpk-derate-nom = PWL(DERATE-CAPACITOR-MLCC-VPK-NOM)[temp]
        #CHECK(
          condition =            vpk[0] <= (vpk-derate-nom * property(c.rated-voltage)),
          name =                 "Capacitor checks"
          description =          "Check capacitor component properties"
          category =             "component-check"
          subcheck-description = "Check ceramic capacitor voltage derating matches the operating-point voltage",
          pass-message =         "Capacitor %_ voltage derating %_V is compatible with the nominal design constraint %_V" % [ref(c),vpk[0],(vpk-derate-nom * property(c.rated-voltage))],
          fail-message =         "Capacitor %_ voltage derating %_V is not compatible with the nominal design constraint %_V" % [ref(c),vpk[0],(vpk-derate-nom * property(c.rated-voltage))],
          locators =             [c]
        )

        #CHECK(
          condition =            vpk[1] <= (vpk-derate-nom * property(c.rated-voltage)),
          name =                 "Capacitor checks"
          description =          "Check capacitor component properties"
          category =             "component-check"
          subcheck-description = "Check ceramic capacitor voltage derating matches the operating-point voltage",
          pass-message =         "Capacitor %_ voltage derating %_V is compatible with the nominal design constraint %_V" % [ref(c),vpk[1],(vpk-derate-nom * property(c.rated-voltage))],
          fail-message =         "Capacitor %_ voltage derating %_V is not compatible with the nominal design constraint %_V" % [ref(c),vpk[1],(vpk-derate-nom * property(c.rated-voltage))],
          locators =             [c]
        )

        #CHECK(
          condition =            temp <= min-value(DERATE-CAPACITOR-MLCC-TEMP, max-temp),
          name =                 "Capacitor checks"
          description =          "Check capacitor component properties"
          category =             "component-check"
          subcheck-description = "Check ceramic capacitor de-rated temperature operating point versus design constraints",
          pass-message =         "Capacitor %_ operating temp %_C satisfies the temperature derating spec of %_C" % [ref(c),temp,min-value(DERATE-CAPACITOR-MLCC-TEMP, max-temp)],
          fail-message =         "Capacitor %_ operating temp %_C does not satisfy the temperature derating spec of %_C" % [ref(c),temp,min-value(DERATE-CAPACITOR-MLCC-TEMP, max-temp)],
          locators =             [c]
        )

      "electrolytic" :
        #CHECK(
          condition =            has-property?(c.anode),
          name =                 "Capacitor checks"
          description =          "Check capacitor component properties"
          category =             "component-check"
          subcheck-description = "Check electrolytic capacitor component has the anode property",
          pass-message =         "Electrolytic capacitor %_ has the correct anode property" % [ref(c)],
          fail-message =         "Electrolytic capacitor %_ does not have the correct anode property" % [ref(c)],
          locators =             [c]
        )

        #CHECK(
          condition =            has-property?(c.electrolyte),
          name =                 "Capacitor checks"
          description =          "Check capacitor component properties"
          category =             "component-check"
          subcheck-description = "Check electrolytic capacitor component has the electrolyte property",
          pass-message =         "Electrolytic capacitor %_ has the correct electrolyte property" % [ref(c)],
          fail-message =         "Electrolytic capacitor %_ does not have the correct electrolyte property" % [ref(c)],
          locators =             [c]
        )

        val [i-pk, i-rms] = [lookup(property(c.operating-point), `current-pk),
                            lookup(property(c.operating-point), `current-rms)]

        if (property(c.anode) == "tantalum" and property(c.electrolyte) == "polymer") :
          #CHECK(
            condition =            vpk[1]   <= (DERATE-CAPACITOR-ETANTPOLY-VPK * property(c.rated-voltage)),
            name =                 "Capacitor checks"
            description =          "Check capacitor component properties"
            category =             "component-check"
            subcheck-description = "Check polymer tantalum capacitor voltage derating matches the operating-point voltage",
            pass-message =         "Capacitor %_ voltage operating point %_V is compatible with the constraint %_V" % [ref(c),vpk[1],(DERATE-CAPACITOR-ETANTPOLY-VPK * property(c.rated-voltage))],
            fail-message =         "Capacitor %_ voltage operating point %_V is not compatible with the constraint %_V" % [ref(c),vpk[1],(DERATE-CAPACITOR-ETANTPOLY-VPK * property(c.rated-voltage))],
            locators =             [c]
          )

          #CHECK(
            condition =            temp  <= min-value(DERATE-CAPACITOR-ETANTPOLY-TEMP, max-temp),
            name =                 "Capacitor checks"
            description =          "Check capacitor component properties"
            category =             "component-check"
            subcheck-description = "Check capacitor de-rated temperature operating point versus design constraints",
            pass-message =         "Capacitor %_ operating temp %_C satisfies the temperature derating spec of %_C" % [ref(c),temp,min-value(DERATE-CAPACITOR-ETANTPOLY-TEMP, max-temp)],
            fail-message =         "Capacitor %_ operating temp %_C does not satisfy the temperature derating spec of %_C" % [ref(c),temp,min-value(DERATE-CAPACITOR-ETANTPOLY-TEMP, max-temp)],
            locators =             [c]
          )

          #CHECK(
            condition =            i-pk  <= property(c.rated-current-pk),
            name =                 "Capacitor checks"
            description =          "Check capacitor component properties"
            category =             "component-check"
            subcheck-description = "Check capacitor peak current matches the rated peak current",
            pass-message =         "Capacitor %_ peak current %_A is compatible with the rated peak current %_A" % [ref(c),i-pk,property(c.rated-current-pk)],
            fail-message =         "Capacitor %_ peak current %_A is not compatible with the rated peak current %_A" % [ref(c),i-pk,property(c.rated-current-pk)],
            locators =             [c]
          )

          #CHECK(
            condition =            i-rms <= PWL(property(c.rated-current-rms))[temp],
            name =                 "Capacitor checks"
            description =          "Check capacitor component properties"
            category =             "component-check"
            subcheck-description = "Check capacitor rms current matches the rated rms current",
            pass-message =         "Capacitor %_ rms current %_A is compatible with the rated rms current %_A" % [ref(c),i-rms,PWL(property(c.rated-current-rms))[temp]],
            fail-message =         "Capacitor %_ rms current %_A is not compatible with the rated rms current %_A" % [ref(c),i-rms,PWL(property(c.rated-current-rms))[temp]],
            locators =             [c]
          )

          #CHECK(
            condition =            vpk[0]  >= 0.0,
            name =                 "Capacitor checks"
            description =          "Check capacitor component properties"
            category =             "component-check"
            subcheck-description = "Check capacitor has min peak voltage greater than 0V",
            pass-message =         "Capacitor %_ min peak voltage %_V is greater than or equal to 0V" % [ref(c),vpk[0]],
            fail-message =         "Capacitor %_ min peak voltage %_V is less than 0V" % [ref(c),vpk[0]],
            locators =             [c]
          )

        else if (property(c.anode) == "tantalum" and property(c.electrolyte) == "manganese-dioxide") :
          #CHECK(
            condition =            i-pk <= property(c.rated-current-pk),
            name =                 "Capacitor checks"
            description =          "Check capacitor component properties"
            category =             "component-check"
            subcheck-description = "Check manganese-dioxide tantalum capacitor peak current matches the rated peak current",
            pass-message =         "Capacitor %_ peak current %_A is compatible with the rated peak current %_A" % [ref(c),i-pk,property(c.rated-current-pk)],
            fail-message =         "Capacitor %_ peak current %_A is not compatible with the rated peak current %_A" % [ref(c),i-pk,property(c.rated-current-pk)],
            locators =             [c]
          )

          #CHECK(
            condition =            i-rms <= PWL(property(c.rated-current-rms))[temp],
            name =                 "Capacitor checks"
            description =          "Check capacitor component properties"
            category =             "component-check"
            subcheck-description = "Check manganese-dioxide tantalum capacitor rms current matches the rated rms current",
            pass-message =         "Capacitor %_ rms current %_A is compatible with the rated rms current %_A" % [ref(c),i-rms,PWL(property(c.rated-current-rms))[temp]],
            fail-message =         "Capacitor %_ rms current %_A is not compatible with the rated rms current %_A" % [ref(c),i-rms,PWL(property(c.rated-current-rms))[temp]],
            locators =             [c]
          )

          #CHECK(
            condition =            vpk[0]  >= 0.0,
            name =                 "Capacitor checks"
            description =          "Check capacitor component properties"
            category =             "component-check"
            subcheck-description = "Check manganese-dioxide tantalum capacitor has min peak voltage greater than 0V",
            pass-message =         "Capacitor %_ min peak voltage %_V is greater than or equal to 0V" % [ref(c),vpk[0]],
            fail-message =         "Capacitor %_ min peak voltage %_V is less than 0V" % [ref(c),vpk[0]],
            locators =             [c]
          )

          val vpk-derate-wc = PWL(DERATE-CAPACITOR-ETANTMNO2-VPK-WC)[temp]
          val vpk-derate-nom = PWL(DERATE-CAPACITOR-ETANTMNO2-VPK-NOM)[temp]
          if i-pk <= 2.0 :
            #CHECK(
              condition =            vpk[1]  <= (vpk-derate-wc * property(c.rated-voltage)),
              name =                 "Capacitor checks"
              description =          "Check capacitor component properties"
              category =             "component-check"
              subcheck-description = "Check capacitor voltage derating matches the wc operating-point voltage",
              pass-message =         "Capacitor %_ voltage derating %_V is compatible with the wc design constraint %_V" % [ref(c),vpk[1],(vpk-derate-wc * property(c.rated-voltage))],
              fail-message =         "Capacitor %_ voltage derating %_V is not compatible with the wc design constraint %_V" % [ref(c),vpk[1],(vpk-derate-wc * property(c.rated-voltage))],
              locators =             [c]
            )

            #CHECK(
              condition =            vpk[1]  <= (vpk-derate-nom * property(c.rated-voltage)),
              name =                 "Capacitor checks"
              description =          "Check capacitor component properties"
              category =             "component-check"
              subcheck-description = "Check capacitor voltage derating matches the operating-point voltage",
              pass-message =         "Capacitor %_ voltage derating %_V is compatible with the nominal design constraint %_V" % [ref(c),vpk[1],(vpk-derate-nom * property(c.rated-voltage))],
              fail-message =         "Capacitor %_ voltage derating %_V is not compatible with the nominal design constraint %_V" % [ref(c),vpk[1],(vpk-derate-nom * property(c.rated-voltage))],
              locators =             [c]
            )

            #CHECK(
              condition =            temp <= min-value(DERATE-CAPACITOR-ETANTMNO2-TEMP-NOM, max-temp),
              name =                 "Capacitor checks"
              description =          "Check capacitor component properties"
              category =             "component-check"
              subcheck-description = "Check capacitor de-rated nominal temperature operating point versus design constraints",
              pass-message =         "Capacitor %_ operating temp %_C satisfies the nominal temperature derating spec of %_C" % [ref(c),temp,min-value(DERATE-CAPACITOR-ETANTMNO2-TEMP-NOM, max-temp)],
              fail-message =         "Capacitor %_ operating temp %_C does not satisfy the nominal temperature derating spec of %_C" % [ref(c),temp,min-value(DERATE-CAPACITOR-ETANTMNO2-TEMP-NOM, max-temp)],
              locators =             [c]
            )

            #CHECK(
              condition =            temp <= min-value(DERATE-CAPACITOR-ETANTMNO2-TEMP-WC, max-temp),
              name =                 "Capacitor checks"
              description =          "Check capacitor component properties"
              category =             "component-check"
              subcheck-description = "Check capacitor de-rated wc temperature operating point versus design constraints",
              pass-message =         "Capacitor %_ operating temp %_C satisfies the wc temperature derating spec of %_C" % [ref(c),temp,min-value(DERATE-CAPACITOR-ETANTMNO2-TEMP-WC, max-temp)],
              fail-message =         "Capacitor %_ operating temp %_C does not satisfy the wc temperature derating spec of %_C" % [ref(c),temp,min-value(DERATE-CAPACITOR-ETANTMNO2-TEMP-WC, max-temp)],
              locators =             [c]
            )

          else if i-pk > 2.0 :
            #CHECK(
              condition =            vpk[1]  <= (DERATE-CAPACITOR-ETANTMNO2-VPK * property(c.rated-voltage)),
              name =                 "Capacitor checks"
              description =          "Check capacitor component properties"
              category =             "component-check"
              subcheck-description = "Check capacitor voltage derating matches the wc operating-point voltage",
              pass-message =         "Capacitor %_ voltage derating %_V is compatible with the wc design constraint %_V" % [ref(c),vpk[1],(vpk-derate-wc * property(c.rated-voltage))],
              fail-message =         "Capacitor %_ voltage derating %_V is not compatible with the wc design constraint %_V" % [ref(c),vpk[1],(vpk-derate-wc * property(c.rated-voltage))],
              locators =             [c]
            )


            #CHECK(
              condition =            temp <= min-value(DERATE-CAPACITOR-ETANTMNO2-TEMP-NOM, max-temp),
              name =                 "Capacitor checks"
              description =          "Check capacitor component properties"
              category =             "component-check"
              subcheck-description = "Check capacitor de-rated nominal temperature operating point versus design constraints",
              pass-message =         "Capacitor %_ operating temp %_C satisfies the nominal temperature derating spec of %_C" % [ref(c),temp,min(DERATE-CAPACITOR-ETANTMNO2-TEMP-NOM, max-temp)],
              fail-message =         "Capacitor %_ operating temp %_C does not satisfy the nominal temperature derating spec of %_C" % [ref(c),temp,min(DERATE-CAPACITOR-ETANTMNO2-TEMP-NOM, max-temp)],
              locators =             [c]
            )

        else :
          println("Unhandled electrolytic type for capacitor check on %_" % [c])

      "mica" :
        #CHECK(
          condition =            vpk[0] <= (DERATE-CAPACITOR-MICA-VPK * property(c.rated-voltage)),
          name =                 "Capacitor checks"
          description =          "Check capacitor component properties"
          category =             "component-check"
          subcheck-description = "Check mica capacitor voltage derating matches the operating-point voltage",
          pass-message =         "Capacitor %_ voltage operating point %_V is compatible with the constraint %_V" % [ref(c),vpk[0],(DERATE-CAPACITOR-MICA-VPK * property(c.rated-voltage))],
          fail-message =         "Capacitor %_ voltage operating point %_V is not compatible with the constraint %_V" % [ref(c),vpk[0],(DERATE-CAPACITOR-MICA-VPK * property(c.rated-voltage))],
          locators =             [c]
        )

        #CHECK(
          condition =            vpk[1] <= (DERATE-CAPACITOR-MICA-VPK * property(c.rated-voltage)),
          name =                 "Capacitor checks"
          description =          "Check capacitor component properties"
          category =             "component-check"
          subcheck-description = "Check mica capacitor voltage derating matches the operating-point voltage",
          pass-message =         "Capacitor %_ voltage operating point %_V is compatible with the constraint %_V" % [ref(c),vpk[1],(DERATE-CAPACITOR-MICA-VPK * property(c.rated-voltage))],
          fail-message =         "Capacitor %_ voltage operating point %_V is not compatible with the constraint %_V" % [ref(c),vpk[1],(DERATE-CAPACITOR-MICA-VPK * property(c.rated-voltage))],
          locators =             [c]
        )

        #CHECK(
            condition =            temp <= min-value(DERATE-CAPACITOR-MICA-TEMP, max-temp),
            name =                 "Capacitor checks"
            description =          "Check capacitor component properties"
            category =             "component-check"
            subcheck-description = "Check capacitor de-rated temperature operating point versus design constraints",
            pass-message =         "Capacitor %_ operating temp %_C satisfies the temperature derating spec of %_C" % [ref(c),temp,min-value(DERATE-CAPACITOR-MICA-TEMP, max-temp)],
            fail-message =         "Capacitor %_ operating temp %_C does not satisfy the temperature derating spec of %_C" % [ref(c),temp,min-value(DERATE-CAPACITOR-MICA-TEMP, max-temp)],
            locators =             [c]
          )

      else : println("Unhandled type for capacitor check on %_" % [c])

  #CHECK(
    condition =            OPERATING-TEMPERATURE[0] >= min-value(operating-temperature(property(c.rated-temperature))),
    name =                 "Capacitor checks"
    description =          "Check capacitor component properties"
    category =             "component-check"
    subcheck-description = "Check capacitor operating temperature versus design constraints",
    pass-message =         "Capacitor %_ has an acceptable operating temperature %_C versus design target %_C" % [ref(c), min-value(operating-temperature(property(c.rated-temperature))), OPERATING-TEMPERATURE[0]],
    fail-message =         "Capacitor %_ does not have an acceptable operating temperature %_C versus design target %_C" % [ref(c), min-value(operating-temperature(property(c.rated-temperature))), OPERATING-TEMPERATURE[0]],
    locators =             [c]
  )

; Checks the frequency of an oscillator (o) against an interface on an IC (intf)
public pcb-check resonator-property-check (o:JITXObject) :
  val name = "Crystal resonator checks"
  val description = "Check crystal resonator property"
  val category = "resonator-check"
  ; Check existence of property  
  #CHECK(
    condition =            has-property?(o.crystal-resonator),
    name =                 "Crystal resonator checks"
    description =          "Check crystal resonator property"
    category =             "resonator-check"
    subcheck-description = "Check crystal component has the correct crystal-resonator property",
    pass-message =         "Component %_ has the correct property for a crystal-resonator" % [ref(o)],
    fail-message =         "Component %_ does not have the correct property for a crystal-resonator" % [ref(o)],
    locators =             [o]
  )

; Checks the frequency of an oscillator (o) against an interface on an IC (intf)
public pcb-check resonator-frequency-check (o:JITXObject, intf:CrystalOscillator) :
  val name = "Crystal resonator checks"
  val description = "Check crystal resonator frequency"
  val category = "resonator-check"
  ; Check critical gain point to ensure oscillation
  #CHECK(
    condition =            frequency(property(o.crystal-resonator)) == frequency(intf),
    name =                 "Crystal resonator checks"
    description =          "Check crystal resonator frequency"
    category =             "resonator-check"
    subcheck-description = "Check crystal has the correct frequency meeting design specs",
    pass-message =         "Crystal %_ does have the correct frequency %_ to meet design specs %_" % [ref(o),frequency(property(o.crystal-resonator)),frequency(intf)],
    fail-message =         "Crystal %_ does not have the correct frequency %_ to meet design specs %_" % [ref(o),frequency(property(o.crystal-resonator)),frequency(intf)],
    locators =             [o]
  )

; Checks the critical gain of an oscillator (o) against an interface on an IC (intf)
public pcb-check resonator-gain-check (o:JITXObject, intf:CrystalOscillator, load-cap:JITXObject) :
  val name = "Crystal resonator checks"
  val description = "Check crystal resonator gain"
  val category = "resonator-check"
  ; Check critical gain point to ensure oscillation
  val op = property(o.crystal-resonator)
  val gain = 4.0 * ESR(op) * pow(2.0 * PI * frequency(op), 2.0) * pow(shunt-capacitance(op) + load-capacitance(op), 2.0)
  #CHECK(
    condition =            gain < max-critical-gain(intf),
    name =                 "Crystal resonator checks"
    description =          "Check crystal resonator gain"
    category =             "resonator-check"
    subcheck-description = "Check crystal circuit gain meets the design criteria for max-critical-gain",
    pass-message =         "Crystal %_ gain %_ meets the design criteria for max-critical-gain" % [ref(o), gain, max-critical-gain(intf)],
    fail-message =         "Crystal %_ gain %_ does not meet the design criteria for max-critical-gain" % [ref(o), gain, max-critical-gain(intf)],
    locators =             [o]
  )

; Checks the drive level of an oscillator (o) against an interface on an IC (intf)
public pcb-check resonator-drive-check (o:JITXObject, intf:CrystalOscillator, load-cap:JITXObject) :
  val name = "Crystal resonator checks"
  val description = "Check crystal resonator drive level"
  val category = "resonator-check"
  ; Check drive level against crystal maximum
  #CHECK(
    condition =            drive-level(intf) <= max-drive-level(property(o.crystal-resonator)),
    name =                 "Crystal resonator checks"
    description =          "Check crystal resonator drive level"
    category =             "resonator-check"
    subcheck-description = "Check crystal resonator circuit has the correct drive-level property to match crystal",
    pass-message =         "Crystal circuit %_ has the correct drive-level property %_ that matches the crystal spec %_" % [ref(o),drive-level(intf),max-drive-level(property(o.crystal-resonator))],
    fail-message =         "Crystal circuit %_ does not have the correct drive-level property %_ that matches the crystal spec %_" % [ref(o),drive-level(intf),max-drive-level(property(o.crystal-resonator))],
    locators =             [o]
  )

; Check pullability of crystal to ensure accuracy
public pcb-check resonator-pullability-check (o:JITXObject, intf:CrystalOscillator, load-cap:JITXObject) :
  val name = "Crystal resonator checks"
  val description = "Check crystal resonator pullability"
  val category = "resonator-check"
  val op = property(o.crystal-resonator)
  val pullability = motional-capacitance(op) / (2.0 * pow(shunt-capacitance(op) + load-capacitance(op), 2.0))
  #CHECK(
    condition =            has-property?(load-cap.tolerance),
    name =                 "Crystal resonator checks"
    description =          "Check crystal resonator pullability"
    category =             "resonator-check"
    subcheck-description = "Check crystal tuning capacitor has the correct tolerance property",
    pass-message =         "Capacitor %_ has the correct tolerance property for crystal tuning" % [ref(load-cap)],
    fail-message =         "Capacitor %_ does not have the correct tolerance property for crystal tuning" % [ref(load-cap)],
    locators =             [load-cap]
  )
  #CHECK(
    condition =            has-property?(load-cap.capacitance),
    name =                 "Crystal resonator checks"
    description =          "Check crystal resonator pullability"
    category =             "resonator-check"
    subcheck-description = "Check crystal tuning capacitor has the correct capacitance property",
    pass-message =         "Capacitor %_ has the correct capacitance property for crystal tuning" % [ref(load-cap)],
    fail-message =         "Capacitor %_ does not have the correct capacitance property for crystal tuning" % [ref(load-cap)],
    locators =             [load-cap]
  )

  val dC = (property(load-cap.capacitance) as Double) * (property(load-cap.tolerance)[1] as Double)
  val freq-error = (pullability as Double) * (dC as Double) * frequency(op)
  #CHECK(
    condition =            frequency-tolerance(op) + freq-error < frequency-tolerance(intf),
    name =                 "Crystal resonator checks"
    description =          "Check crystal resonator pullability"
    category =             "resonator-check"
    subcheck-description = "Check crystal frequency tolerance with pullability meets the design specification",
    pass-message =         "Crystal %_ has the correct frequency tolerance %_ that meets the design spec %_" % [ref(load-cap),frequency-tolerance(op) + freq-error,frequency-tolerance(intf)],
    fail-message =         "Crystal %_ does not have the correct frequency tolerance %_ that meets the design spec %_" % [ref(load-cap),frequency-tolerance(op) + freq-error,frequency-tolerance(intf)],
    locators =             [load-cap]
  )

public defn check-resonator (o:JITXObject, intf:CrystalOscillator, load-cap:JITXObject) :
  inside pcb-module:
    check resonator-property-check(o)
    if has-property?(o.crystal-resonator) :
      check resonator-frequency-check(o, intf)
      check resonator-gain-check(o, intf, load-cap)
      check resonator-drive-check(o, intf, load-cap)
      check resonator-pullability-check(o, intf, load-cap)

; Extract the copper layer on a given side of a landpattern
; - note: geoms unsupported
defn copper (lp:LandPattern, side:Side) -> Seqable<Shape> :
  for pad in pads(lp) seq?: 
    if /side(pad) == side or pad-type(/pad(pad)) == TH:
      One(pose(pad) * pad-shape(/pad(pad)))
    else:
      None()

; Get the locations of all the pads in a land pattern
defn pad-locs (lp:LandPattern) -> Seqable<Pose> :
  seq(pose, pads(lp))

; Get the minimum pitch of all the pads in a land pattern
defn min-pitch (lp:LandPattern) -> Double :
  min-space(seq(center, pad-locs(lp)))

; Checks that the copper layers on both sides of a landpattern are within the 
; min-copper-copper-space rule.
public pcb-check check-min-copper-copper-space (lp:LandPattern, side:Side) :
  val name = "Layout checks"
  val description = "Check min copper spacing"
  val category = "landpattern-check"

  val copper = to-tuple(copper(lp, side))
  if not empty?(copper) :
    val min-copper-copper-space = clearance(current-rules(), MinCopperCopperSpace)
    val min-space = min-space(copper)
    #CHECK(
      condition =            min-space >= min-copper-copper-space,
      name =                 "Layout checks"
      description =          "Check min copper spacing"
      category =             "landpattern-check"
      subcheck-description = "Check landpattern copper minimum spacing",
      pass-message =         "Landpattern %_ min spacing %_ does not violate min spacing rules %_" % [/name(lp),min-space,min-copper-copper-space],
      fail-message =         "Landpattern %_ min spacing %_ violates min spacing rules %_" % [/name(lp),min-space,min-copper-copper-space],
      locators =             [lp]
    )

; Checks that the copper layers on both sides of a ladnpattern dont' violate 
; the minimum copper width rule
public pcb-check check-min-copper-width (lp:LandPattern, side:Side) :
  val name = "Layout checks"
  val description = "Check min copper width"
  val category = "landpattern-check"
  val copper = to-tuple(copper(lp, side))
  if not empty?(copper) :
    val min-copper-width = clearance(current-rules(), MinCopperCopperSpace)
    val min-width = min-width(copper)
    #CHECK(
      condition =            min-width >= min-copper-width,
      name =                 "Layout checks"
      description =          "Check min copper width"
      category =             "landpattern-check"
      subcheck-description = "Check landpattern copper minimum width",
      pass-message =         "Landpattern %_ min width %_ does not violate min width rules %_" % [/name(lp),min-width,min-copper-width],
      fail-message =         "Landpattern %_ min width %_ violates min width rules %_" % [/name(lp),min-width,min-copper-width],
      locators =             [lp]
    )

; Checks that a BGA landpattern does not violate the min-pitch-bga design rule
public pcb-check check-bga-pitch (lp:LandPattern) :
  val name = "Layout checks"
  val description = "Check bga pad pitch"
  val category = "landpattern-check"
  val min-pitch-bga = clearance(current-rules(), MinPitchBGA)
  #CHECK(
    condition =            min-pitch(lp) >= min-pitch-bga,
    name =                 "Layout checks"
    description =          "Check bga pad pitch"
    category =             "landpattern-check"
    subcheck-description = "Check landpattern bga minimum pitch",
    pass-message =         "Landpattern %_ min bga pitch %_ does not violate min bga pitch rules %_" % [/name(lp),min-pitch(lp),min-pitch-bga],
    fail-message =         "Landpattern %_ min bga pitch %_ violates min bga pitch rules %_" % [/name(lp),min-pitch(lp),min-pitch-bga],
    locators =             [lp]
  )

; Checks that a leaded component does not violate the min-leaded-pitc  design rule
public pcb-check check-leaded-pitch (lp:LandPattern) :
  val name = "Layout checks"
  val description = "Check leaded pad pitch"
  val category = "landpattern-check"
  val min-pitch-leaded = clearance(current-rules(), MinPitchLeaded)
  val min-pitch =  min-pitch(lp)
  #CHECK(
    condition =            min-pitch >= min-pitch-leaded,
    name =                 "Layout checks"
    description =          "Check leaded pad pitch"
    category =             "landpattern-check"
    subcheck-description = "Check landpattern leaded minimum pitch",
    pass-message =         "Landpattern %_ min leaded pitch %_ does not violate min leaded pitch rules %_" % [/name(lp),min-pitch,min-pitch-leaded],
    fail-message =         "Landpattern %_ min leaded pitch %_ violates min leaded pitch rules %_" % [/name(lp),min-pitch,min-pitch-leaded],
    locators =             [lp]
  )

; Checks that the solder mask layers of a land pattern do not violate the minimum
; solder mask sliver
public pcb-check check-min-solder-mask-sliver (lp:LandPattern, shapes:Seqable<Shape>) :
  val name = "Layout checks"
  val description = "Check min soldermask size"
  val category = "layout-check"
  val s = to-tuple(shapes)
  if not empty?(s):
    val min-space = min-space(s)
    val rule-space = clearance(current-rules(), MinSolderMaskBridge)
    #CHECK(
      condition =            min-space >= rule-space,
      name =                 "Layout checks"
      description =          "Check min soldermask size"
      category =             "landpattern-check"
      subcheck-description = "Check landpattern minimum soldermask bridge spacing",
      pass-message =         "Landpattern %_ min soldermask spacing %_ does not violate min rules %_" % [/name(lp),min-space,rule-space],
      fail-message =         "Landpattern %_ min soldermask spacing %_ violates min rules %_" % [/name(lp),min-space,rule-space],
      locators =             [lp]
    )

; Runs all the land pattern checks on either an instance or definition. 
public defn check-landpattern (component:JITXObject|JITXDef) :
  ; extract the land pattern
  val lp = 
    match(component) :
      (landpattern:LandPattern) :
        landpattern
      (d:JITXDef) :
        landpattern(d)
      (i:JITXObject) : 
        landpattern(instance-definition(i))

  ; perform the checks
  inside pcb-module :
    for side in [Top, Bottom] do :
      check check-min-copper-copper-space(lp, side)
      check check-min-copper-width(lp, side)
      check check-min-solder-mask-sliver(lp, layer(lp, SolderMask(side)))

    if has-property?(component.bga) and property(component.bga):
      check check-bga-pitch(lp)

    if has-property?(component.leaded) and property(component.leaded):
      check check-leaded-pitch(lp)

; Runs landpattern checks recursively on all the lands in a module
public defn check-all-landpatterns (module:JITXObject) : 
  inside pcb-module :
    val components = to-tuple(component-instances(module))
    val modules    = filter({not contains?(components, _)}, instances(module))
    for component in components do :
      check-landpattern(component)
    for module in modules do :
      check-all-landpatterns(module)
    
; Runs landpattern checks recursively starting from self.
public defn check-all-landpatterns () : 
  inside pcb-module: 
    check-all-landpatterns(self)



doc: "Helper to force power-states property to propagate through \
      components in a design. Currently, the property may only   \
      be shared along components with the power-supply-component \
      property set `true`."
public defn propagate-power-states (module:JITXObject) : 
  ; Collect all the pins in the design
  val all-pins = all-populated-pins(module)
  ; println("pins: %," % [seq(ref,all-pins)])

  ; Find the pins with the power-states property
  val roots =
    for pin in all-pins filter :
      has-property?(pin.power-states)
  
  ; DFS walk of the netlist, to update power-states of 
  ; connected power-pins 
  val visited = HashSet<JITXObject>()
  defn visit-pins (pin:JITXObject, power-states-tuple:Tuple<PowerState>) :
    if not visited[pin] :
      add(visited, pin)
      if not has-property?(pin.power-states) :
        set-property(pin, `power-states, power-states-tuple)
        
      if has-property?(pin.power-pin) or
         has-property?(pin.power-supply-pin) :
        do(visit-pins{_, power-states-tuple}, connected-pins(pin))

  defn visit-power-supply-components (pin:JITXObject, power-states-tuple:Tuple<PowerState>) :
    val instance = containing-instance!(pin)
    if has-property?(instance.power-supply-component) and
        property(instance.power-supply-component) : 
      do(visit-pins{_, power-states-tuple}, pins(instance))

  ; propagate the power-states to connected power-pins
  do(visit-pins{_0, property(_0.power-states)}, roots)
  do(visit-power-supply-components{_0, property(_0.power-states)}, roots)

  ; propagate from power pins to io-pins
  for io-pin in filter(is-digital-pin?, all-pins) do :
    val vdd-pin = 
      if has-property?(io-pin.digital-input) : 
        vdd-pin(property(io-pin.digital-input))
      else if has-property?(io-pin.digital-output) : 
        vdd-pin(property(io-pin.digital-output))
      else if has-property?(io-pin.digital-io) : 
        vdd-pin(property(io-pin.digital-io))
      else : 
        fatal("Expected a digital io pin.")
    if has-property?(vdd-pin.power-states) and 
       (not has-property?(io-pin.power-states)): 
      set-property(io-pin, `power-states, property(vdd-pin.power-states))

defn check-has-power-states (p:JITXObject) :
  #CHECK(condition = has-property?(p.power-states)
         name        = "Check Power States"
         description = "Checks that all i/o pins have power states"
         category    = "power-states"
         subcheck-description = "Check that a pin has power states"
         pass-message = "%_ has a valid .power-states property" % [ref(p)]
         fail-message = "%_ is missing the .power-states property" % [ref(p)]
         locators = [p])

doc: "This check will make sure that components connected to each other \
      over digital-io have matching power states, that is to say if a   \
      component has the same named power state as something it is       \
      connected to, this checks that they are both powered on or off.   \
                                                                        \
      - module: the module to check."
public pcb-check power-states (module:JITXObject) :

  for connected-group in populated-connected-groups(module) do :
    val pin-categories = categorize-digital-pins(connected-group)
    val digital-pins = to-tuple $ cat-all([inputs(pin-categories),
                                           outputs(pin-categories),
                                           ios(pin-categories)])

    for digital-pin in digital-pins do :
      check-has-power-states $ pin(digital-pin)

    val condition? = all-equal? $
      for digital-pin in digital-pins seq :
        property(pin(digital-pin).power-states)

    #CHECK(condition    = condition?
            name        = "Power States"
            description = "Checks that all components have matching power states."
            category    = "power-states"
            subcheck-description = "Checking power states match on connected pins"
            pass-message = "Connected pins %, have matching power states" % [pin-refs(digital-pins)]
            fail-message = "Connected pins %_ and %_ do not have matching power states"  % [pin-refs(digital-pins)]
            locators = to-jitx-pins(digital-pins))
