#use-added-syntax(jitx)
defpackage ocdb/stm-to-jitx:
  import core
  import collections
  import lang-utils
  import json
  import reader
  import jitx
  import jitx/commands

  import ocdb/stm
  import ocdb/scripts/cubemx-importer-utils

  import ocdb/bundles
  import ocdb/property-structs

;=========================================
;============== STM to JITX ==============
;=========================================

defn stm-to-jitx (generic-pin:STMGenericPin) -> GenericPin :
  GenericPin(stm-to-jitx(max-voltage(generic-pin)), rated-esd(generic-pin))

defn stm-to-jitx (power-pin:STMPowerPin) -> PowerPin :
  PowerPin(stm-to-jitx(recommended-voltage(power-pin)))

defn stm-to-jitx (voltage-limits:STMVoltageLimits) -> Interval :
  Interval(min-val(voltage-limits), max-val(voltage-limits), false)

;Convert a Stanza representation of an STM part to JITX.
public defn stm-to-jitx (stm:STM) -> Instantiable :
  ;__________________________________
  ;============ Bundles =============
  ;‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
  ;Generate all bundles and store them in a table indexed by name.
  val bundle-table = HashTable<String, Bundle>()
  for bundle-name in map(name, bundles(stm)) do :
    pcb-bundle b :
      name = bundle-name
      pin p
    bundle-table[bundle-name] = b

  ;Generate the component that includes pin-properties and support statements.
  pcb-component component :
    ;__________________________________
    ;========= Pin Properties =========
    ;‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
    ;Grab the pins defined for the pin properties.
    val pin-properties = pin-properties(stm)
    val generic-props = stm-to-jitx $ generic-pin(pin-properties)
    val power-props = stm-to-jitx $ power-pin(pin-properties)
    
    ;Are the pads numeric (Double -> Int) or named (Ref -> String)?
    val numeric-pads? = any?({pad(_) is Double}, rows(pin-properties))
    val named-pads? = any?({pad(_) is String}, rows(pin-properties))
    
    ;If the pads are neither or both, then we are using malformed data.
    if numeric-pads? and named-pads? :
      fatal("Generated a micro-controller with both Int and Ref pads.") 
    if not numeric-pads? and not named-pads? :
      fatal("Generated a micro-controller without pads.") 
    
    ;Generate the pin-properties.
    ;Cases are split between Int and Ref pads, and across generic and power properties usages.
    if numeric-pads? :
      pin-properties :
        [pin:Ref | pads:Int ... | side:Dir | generic-pin:GenericPin | power-pin:PowerPin]
        for row in rows(pin-properties) do :
          val pin-ref = ref-ify(pin(row))
          val pad-name = to-int(pad(row) as Double)
          match(generic-props?(row), power-props?(row)) :
            (g:True, p:True)   : [(pin-ref) | pad-name | side(row) | generic-props | power-props]
            (g:True, p:False)  : [(pin-ref) | pad-name | side(row) | generic-props |      -     ]
            (g:False, p:True)  : [(pin-ref) | pad-name | side(row) |       -       | power-props]
            (g:False, p:False) : [(pin-ref) | pad-name | side(row) |       -       |      -     ]
    else :
      pin-properties :
        [pin:Ref | pads:Ref ... | side:Dir | generic-pin:GenericPin | power-pin:PowerPin]
        for row in rows(pin-properties) do :
          val pin-ref = ref-ify(pin(row))
          val pad-name = ref-ify(pad(row) as String)
          match(generic-props?(row), power-props?(row)) :
            (g:True, p:True)   : [(pin-ref) | pad-name | side(row) | generic-props | power-props]
            (g:True, p:False)  : [(pin-ref) | pad-name | side(row) | generic-props |      -     ]
            (g:False, p:True)  : [(pin-ref) | pad-name | side(row) |       -       | power-props]
            (g:False, p:False) : [(pin-ref) | pad-name | side(row) |       -       |      -     ]
    ;__________________________________
    ;============ Supports ============
    ;‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
    defn generate-mapped-ref (mapping:STMSupportMapping) -> JITXObject :
      inside pcb-module :
        match(require(mapping)) :
          (req:String) :
            val req-bundle = bundle-table[req]
            require p0 : req-bundle
            dot(p0, ref-ify(pin(mapping)))
          (req:False) :
            dot(self, ref-ify(pin(mapping)))
    
    defn generate-support (b:Bundle, mappings:Tuple<STMSupportMapping>) :
      inside pcb-component :
        supports b :
          for mapping in mappings do :
            val key = dot(b, ref-ify(bundle-pin(mapping)))
            val value = generate-mapped-ref(mapping)
            key => value
      
    for support in supports(stm) do :
      val supported-bundle = bundle(support)
      val bundle-name = name(supported-bundle)
      val mappings = mappings(support)
      match(get?(bundle-table, bundle-name)) :
        (b:Bundle) :
          generate-support(b, mappings)
        (f:False) :
          switch(bundle-name) :
            "gpio" :
              generate-support(gpio, mappings)
            "adc" :
              generate-support(adc, mappings)
            "dac" :
              generate-support(dac, mappings)
            "timer" :
              generate-support(timer, mappings)
            "swd" :
              generate-support(swd, mappings)
            ; "low-freq-oscillator" :
            ;   supports low-freq-oscillator :
            ;     require in-pin: #
            ;     require out-pin: #
            ;     low-freq-oscillator.in => in-pin.#
            ;     low-freq-oscillator.out => out-pin.#
            ; "high-freq-oscillator" :
            ;   supports high-freq-oscillator :
            ;     require in-pin: #
            ;     require out-pin: #
            ;     high-freq-oscillator.in => in-pin.#
            ;     high-freq-oscillator.out => out-pin.#
            ; "can-interface" :
            ;   supports can-interface :
            ;     require rx-pin: #
            ;     require tx-pin: #
            ;     can-interface.rx => rx-pin.#
            ;     can-interface.tx => tx-pin.#
            ; "i2c" :
            ;   supports i2c :
            ;     require sda-pin: #
            ;     require scl-pin: #
            ;     i2c.sda => sda-pin.#
            ;     i2c.scl => scl-pin.#
            ; "jtag" :
            ;   val jtag-options =
            ;     for option in options(supported-bundle) map :
            ;       switch(option) :
            ;         "JTAG-TRSTN" : JTAG-TRSTN
            ;   val jtag-bundle = jtag(jtag-options)
            ;   supports jtag-bundle :
            ;     jtag-bundle.tck => #
            ;     jtag-bundle.tdi => #
            ;     jtag-bundle.tdo => #
            ;     jtag-bundle.tms => #
            ;     if contains?(usart-options, UART-TRSTN) :
            ;       jtag-bundle.trstn => #
            ; "i2s" :
            ;   val i2s-options =
            ;     for options in options(supported-bundle) map :
            ;       switch(option) :
            ;         "I2S-MCK" : I2S-MCK
            ;         "I2S-SDMI" : I2S-SDMI
            ;   val i2s-bundle = i2s(i2s-options)
            ;   supports i2s-bundle :
            ;     require ws-pin: #
            ;     require ck-pin: #
            ;     require sdmo-pin: #
            ;     i2s-bundle.ws => ws-pin.p
            ;     i2s-bundle.ck => ck-pin.p
            ;     i2s-bundle.sdmo => sdmo-pin.p
            ;     if contains?(i2s-options, I2S-MCK) :
            ;       require mck-pin: #
            ;       i2s-bundle.mck => mck-pin.p
            ;     if contains?(i2s-options, I2S-SDMI) :
            ;       require sdmi-pin: #
            ;       i2s-bundle.sdmi => sdmi-pin.p
            ; "uart" :
            ;   val uart-options =
            ;     for option in options(supported-bundle) map :
            ;       switch(option) :
            ;         "UART-DTR" : UART-DTR
            ;         "UART-CTS" : UART-CTS
            ;         "UART-DCD" : UART-DCD
            ;         "UART-RI" : UART-RI
            ;         "UART-DST" : UART-DST
            ;         "UART-RTS" : UART-RTS
            ;         "UART-CK" : UART-CK
            ;         "UART-DE" : UART-DE
            ;         "UART-CS" : UART-CS
            ;   val uart-bundle = uart(uart-options)
            ;   supports uart-bundle :
            ;     require tx-pin: #
            ;     require rx-pin: #
            ;     if contains?(uart-options, UART-DTR) :
            ;       require dtr-pin: #
            ;       uart-bundle.dtr => dtr-pin.p
            ;     if contains?(uart-options, UART-CTS) :
            ;       require cts-pin: #
            ;       uart-bundle.cts => cts-pin.p
            ;     if contains?(uart-options, UART-DCD) :
            ;       require dcd-pin: #
            ;       uart-bundle.dcd => dcd-pin.p
            ;     if contains?(uart-options, UART-RI) :
            ;       require ri-pin: #
            ;       uart-bundle.ri => ri-pin.p
            ;     if contains?(uart-options, UART-DST) :
            ;       require dst-pin: #
            ;       uart-bundle.dst => dst-pin.p
            ;     if contains?(uart-options, UART-RTS) :
            ;       require rts-pin: #
            ;       uart-bundle.rts => rts-pin.p
            ;     if contains?(uart-options, UART-CK) :
            ;       require ck-pin: #
            ;       uart-bundle.ck => ck-pin.p
            ;     if contains?(uart-options, UART-DE) :
            ;       require de-pin: #
            ;       uart-bundle.de => de-pin.p
            ;     if contains?(uart-options, UART-NSS) :
            ;       require cs-pin: #
            ;       uart-bundle.cs => cs-pin.p
            ; "usart" :
            ;   val usart-options =
            ;     for option in options(supported-bundle) map :
            ;       switch(option) :
            ;         "UART-DTR" : UART-DTR
            ;         "UART-CTS" : UART-CTS
            ;         "UART-DCD" : UART-DCD
            ;         "UART-RI" : UART-RI
            ;         "UART-DST" : UART-DST
            ;         "UART-RTS" : UART-RTS
            ;         "UART-CK" : UART-CK
            ;         "UART-DE" : UART-DE
            ;         "UART-CS" : UART-CS
            ;   val usart-bundle = usart(usart-options)
            ;   supports usart-bundle :
            ;     require tx-pin: #
            ;     require rx-pin: #
            ;     if contains?(usart-options, UART-DTR) :
            ;       require dtr-pin: #
            ;       usart-bundle.dtr => dtr-pin.p
            ;     if contains?(usart-options, UART-CTS) :
            ;       require cts-pin: #
            ;       usart-bundle.cts => cts-pin.p
            ;     if contains?(usart-options, UART-DCD) :
            ;       require dcd-pin: #
            ;       usart-bundle.dcd => dcd-pin.p
            ;     if contains?(usart-options, UART-RI) :
            ;       require ri-pin: #
            ;       usart-bundle.ri => ri-pin.p
            ;     if contains?(usart-options, UART-DST) :
            ;       require dst-pin: #
            ;       usart-bundle.dst => dst-pin.p
            ;     if contains?(usart-options, UART-RTS) :
            ;       require rts-pin: #
            ;       usart-bundle.rts => rts-pin.p
            ;     if contains?(usart-options, UART-CK) :
            ;       require ck-pin: #
            ;       usart-bundle.ck => ck-pin.p
            ;     if contains?(usart-options, UART-DE) :
            ;       require de-pin: #
            ;       usart-bundle.de => de-pin.p
            ;     if contains?(usart-options, UART-NSS) :
            ;       require cs-pin: #
            ;       usart-bundle.cs => cs-pin.p
    ;         "spi" :
    ;           val spi-options =
    ;             for option in options(supported-bundle) map :
    ;               switch(option) :
    ;                 "SPI-SDO" : SPI-SDO
    ;                 "SPI-SDI" : SPI-SDI
    ;                 "SPI-CS" : SPI-CS
    ;                 "SPI-CIPO" : SPI-CIPO
    ;                 "SPI-COPI" : SPI-COPI
    ;                 "SPI-SDIO" : SPI-SDIO
    ;           val spi-bundle = spi
              
    ; defn generate-mapped-ref (mapping:STMSupportMapping) -> JITXObject :
    ;   inside pcb-module :
    ;     require mygpio:gpio
    ;     match(require(mapping)) :
    ;       (req:String) :
    ;         val req-bundle = bundle-table[req]
    ;         require p0 : req-bundle
    ;         dot(p0, ref-ify(pin(mapping)))
    ;       (req:False) :
    ;         dot(self, ref-ify(pin(mapping)))
    
    ; defn generate-mappings (b:Bundle, mappings:Tuple<STMSupportMapping>) :
    ;   inside pcb-component :
    ;     for mapping in mappings do :
    ;       val key = dot(b, ref-ify(bundle-pin(mapping)))
    ;       val value = generate-mapped-ref(mapping)
    ;       key => value
    
    ; defn generate-support (b:Bundle, mappings:Tuple<STMSupportMapping>) :
    ;   inside pcb-component :
    ;     supports b :
    ;       generate-mappings(b, mappings)


    ;           supports spi-bundle :
    ;             for mapping in mappings do :
    ;               switch(bundle-pin(mapping)) :
    ;                 "sck" :
    ;                   val req-bundle = bundle-table[req]
    ;                   require sck-pin: req-bundle
    ;                   dot(sck-pin, ref-ify(pin(mapping)))
    ;                   spi-bundle.sck => sck-pin.p
    ;             if contains?(spi-options, SPI-SDO) :
    ;               require sdo-pin: #
    ;               spi-bundle.sdo => sdo-pin.p
    ;             if contains?(spi-options, SPI-SDI) :
    ;               require sdi-pin: #
    ;               spi-bundle.sdi => sdi-pin.p
    ;             if contains?(spi-options, SPI-CS) :
    ;               require cs-pin: #
    ;               spi-bundle.cs => cs-pin.p
    ;             if contains?(spi-options, SPI-CIPO) :
    ;               require cipo-pin: #
    ;               spi-bundle.cipo => cipo-pin.p
    ;             if contains?(spi-options, SPI-COPI) :
    ;               require copi-pin: #
    ;               spi-bundle.copi => copi-pin.p
    ;             if contains?(spi-options, SPI-SDIO) :
    ;               require sdio-pin: #
    ;               spi-bundle.sdio => sdio-pin.p
            ; "spi-controller" :
            ;   val spi-controller-bundle = spi-controller()
            ;   supports spi-controller-bundle :
            ;     require sdo-pin: #
            ;     require sdi-pin: #
            ;     require sck-pin: #
            ;     require cs-pin: #
            ;     spi-controller-bundle.cipo => sdo-pin.#
            ;     spi-controller-bundle.copi => sdi-pin.#
            ;     spi-controller-bundle.sck => sck-pin.#
            ;     spi-controller-bundle.cs => cs-pin.#
            else :
              fatal("Bundle '%_' is not supported." % [bundle-name])
  component

; val mcu = create-mcu-struct("stm-spi.json")
; val mcu = create-mcu-struct("stm-test-gpio.json")
; val mcu = create-mcu-struct("stm-test-adc.json")
; val mcu = create-mcu-struct("stm-test-dac-timer.json")
val mcu = create-mcu-struct("stm-test-swd.json")
val component = stm-to-jitx(mcu)
print-def(component)