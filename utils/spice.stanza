#use-added-syntax(jitx)
defpackage ocdb/spice:
  import core
  import collections
  import jitx
  import jitx/commands
  import ocdb/defaults
  import ocdb/symbols
  import ocdb/land-patterns
  import ocdb/box-symbol
  import ocdb/generic-components
  
public pcb-struct ocdb/des :
  references:Tuple<String>
  library-part:Instantiable|Tuple<KeyValue<String, ?>>

defn find-component-from-list (name:String, mappings:Tuple<des>) -> Instantiable|False :
  var part = None
  for m in mappings do :
    if contains?(references(m), name):
      part = library-part(m)
  if part is Instantiable :
    part as Instantiable
  else:
    false

defn remove-duplicate-keys (hs:Seqable<Seqable<KeyValue<String, ?>>>) -> Tuple<KeyValue<String, ?>> :
  to-tuple $ to-hashtable<String, ?>(cat-all(hs))
public pcb-struct ocdb/imported-spice-component :
  reference:String
  element:String
  model:String
  ; has-value:True|False
  nets:List
  pins:List
  comp-val:Double|False
  parameters:List
  parameter-values:List

public pcb-struct ocdb/spice-element-properties:
  nodes:List
  pins:Int
  has-value:True|False
  parameters:List

; public defn get-pin-list (obj:JITXObject, pin-id:?) :
;   val pin-name = to-string(pin-id)
;   val result = to-tuple $ for p in pins(obj) filter :
;     if substring?(to-string(ref(p)), pin-name) :
;       match-pin?(ref(p), pin-name)
;   result
; JITXObject

; pin-properties
public defn introspect-pins (obj:Instantiable) : 
  println("got here")
  println("pins: %_" % [pins(obj)])
  inside pcb-component :
    println("got here 2")
    ; pad is a keyword in landpattern contexts
    println("pins list: %_" % [pins(self)])
    for pin* in pins(self) do :
      println("pin: %_:" % [pin*])

    ; println("pins list: %_" % [pin-properties(self)])
    ; for pin* in pin-properties(self) do :
    ;   println("pin: %_:" % [pin*])

; defn introspect () : 
;   inside pcb-landpattern :
;     ; pad is a keyword in landpattern contexts
;     for pad* in pads(self) do :
;       println(pose(pad*))

public defn get-spice-element-properties (prefix:String) :
  switch {prefix[0] == _} :
    'R' :
      val result = spice-element-properties(List("1", "2"),
        2, true,
        to-list(["ac","m","scale","temp","dtemp","tc1","tc2","noisy"]) )
      result
    'L' : 
      val result = spice-element-properties(List("p", "n"),
        2, true,
        to-list(["mname","nt", "m","scale","temp","dtemp","tc1","tc2","ic"]) )
      result
    'D' : 
      val result = spice-element-properties(List("a", "c"),
        2, true,
        to-list(["mname", "m", "l", "w", "ad", "as", "pd", "ps", "nrd", "nrs", "off", "ic-vds-vgs-vbs", "temp"]) )
      result
    'M' : 
      val result = spice-element-properties(List("d", "g", "s", "s"),
        4, false,
        to-list(["mname","area", "m","pj", "off", "ic", "temp", "dtemp", "lm", "wm", "lp" "wp"]) )
      result
    'C' : ; C
      val result = spice-element-properties(List("a", "c"),
        2, true,
        to-list(["mname","m","scale","temp","dtemp","tc1","tc2","ic"]) )
      result


    'Q' : ; Bipolar junction transistor (BJT)  
      val result = spice-element-properties(List("c", "b", "e"),
        3, true,
        to-list(["mname","m","scale","temp","dtemp","tc1","tc2","ic"]) )
      result
    'J' : ; Junction field effect transistor (JFET) 
      val result = spice-element-properties(List("a", "c"),
        2, true,
        to-list(["mname","m","scale","temp","dtemp","tc1","tc2","ic"]) )
      result
    'I' : ; Current source  
      val result = spice-element-properties(List("a", "c"),
        2, true,
        to-list(["mname","m","scale","temp","dtemp","tc1","tc2","ic"]) )
      result
    'V' : ; Voltage source  
      val result = spice-element-properties(List("a", "c"),
        2, true,
        to-list(["mname","m","scale","temp","dtemp","tc1","tc2","ic"]) )
      result
    else : ; ??? default to C
      val result = spice-element-properties(List("a", "c"),
        2, true,
        to-list(["mname","m","scale","temp","dtemp","tc1","tc2","ic"]) )
      result
  




public defn spice-to-double (spice:String) -> Double|False :
  val lower-case-spice = lower-case(spice)
  var multiplier:Double|False
  val number = to-string{"%*", % [_]} $
    for ch in lower-case-spice take-while : 
      contains?("0123456789.", ch)
    val suffix =
      if length(number) != length(lower-case-spice) : 
        lower-case-spice[length(number) to false]
      else : 
        ""
  switch {suffix == _} :
    "t":
      multiplier = 1.0e12
    "g":
      multiplier = 1.0e9
    "meg":
      multiplier = 1.0e6
    "k":
      multiplier = 1.0e3
    "mil":
      multiplier = 25.4e-6
    "m":
      multiplier = 1.0e-3
    "u":
      multiplier = 1.0e-6
    "n":
      multiplier = 1.0e-9
    "p":
      multiplier = 1.0e-12
    "f":
      multiplier = 1.0e-15
    "":
      multiplier = 1.0
    else:
      multiplier = false
  println("number %_ suffix: %_ multiplier %_" % [number suffix multiplier])
  var return-val:Double|False = false
  match(to-double(number),multiplier ) :
    (return:Double, multiplier:Double) :
      return-val = return * multiplier
    (return:False, multiplier) : return-val = false
    (return, multiplier:False) : return-val = false
  return-val
    
defn to-pin-name (raw:String) : 
  if to-int(raw) is Int:
    Ref("p")[to-int(raw) as Int]
  else :
    Ref(raw)

defn to-net-name (raw:String) : 
  if to-int(raw) is Int:
    to-string("%_" % [raw])
  else :
    raw

public defn ListTable<K,V> () : HashTable<K,List<V>>(List())
public defn add<?K,?V> (table:Table<?K,List<?V>>, k:K, v:V) : update(table, cons{v, _}, k)

defn clean-net-name (net-in:String) -> String:
  var net-out = net-in
  if digit?(net-in[0] ) : ; add underscore to nets starting with digits
    net-out = string-join(["_", net-in ])
  net-out
; Assumptions: 
; - generated spice has already been processed with a syntax checker
; - line continuation is not used '+'
; - ignore commands, items in models (user can specify the component at the top level)
; - there is no more than 1 space between each item
public defn import-spice-netlist (path:String, use-part-database?:True|False, mappings:Tuple<des>,ground-nets:List<String>,power-nets:List<String>) :
  val raw = (to-tuple $ split(slurp(path), "\n"))

  val raw-nets = Vector<String>()
  val components = Vector<imported-spice-component>()

  for (r in raw, i in 1 to false) do :
  ; does line start with a component we support?
    var valid-line:True|False = false
    var unique-part:True|False = false
    println("r: %_" % [r])
    
    if length(r) > 3 :
      ; if contains?("rRcClLdDmM", r[0]) : ; line starts with: R C L D M
      if contains?("rRcClLdD", r[0]) : ; line starts with: R C L D M
        valid-line = true
      else if letter?(r[0]): ; if other letter, look up instance with reference designator and populate element props
        valid-line = true
        unique-part = true
        println("other letter") 
      else: valid-line = false
      ; (match-r:False) :
      ;   valid-line = false
    ; println("contains: %_ valid? %_" % [contains?("rRcClLdDmM", r[0]) valid-line])
    if valid-line :
      val input = to-tuple(split(lower-case(r), " "))
      val line = to-tuple(split(lower-case(r), " "))
      var line-length = length(line)
      var ref-des:String = line[0]
      val char:Char = upper-case(ref-des[0])
      ref-des = string-join([char,ref-des[1 to false]])
      ; ref-des[0] = 'R'
      ; ref-des[0] = upper-case(ref-des[0])
      println("ref-des %_" % [ref-des])
      var element-props = get-spice-element-properties("C")
        if unique-part :
          val component-from-list = find-component-from-list(input[line-length - 1], mappings)
          match(component-from-list) : 
            (obj:Instantiable) :
              val pin-list = map(to-string, map(ref, pins(obj)))
              element-props = spice-element-properties(to-list(pin-list ), length(pins(obj)), false,to-list([]))
            (obj:False) :
              fatal("SPICE line with reference designator %_ has no matching component." % [input[0]])
        else:
          element-props = get-spice-element-properties(ref-des)
      val net-input = Vector<String>()
      if line-length > pins(element-props) + 1: ; Line length >= _XXXX <nets> value model params
        for n in 1 through pins(element-props) do :
          ; println("n= %_ line[n]= %_" % [n line[n] ]) ; DEBUG
          ; println("line = %_" % [line[n]])
          val name-net = clean-net-name(line[n]) ; add underscore to nets starting with digits
          add(net-input, name-net )
          add(raw-nets, name-net )
        val prefix = to-string(ref-des[0])
        var model-input = prefix
        ; println("part 1 prefix: %_ model: %_" % [prefix model-input] )
        ; println(ref-des) ; DEBUG
        var line-position = 1 + pins(element-props)
        ; println("linpos 1: %_" % [line-position])
        ; get value, if component type has value
        var comp-val:Double|False = false
        if has-value(element-props) :
          ; (match spice-to-double(line[line-position])
          ; println("line[linepos]: %_ " % [(line[line-position]) ])  
          comp-val = spice-to-double(line[line-position])
          line-position = line-position + 1
        ; println("linpos 1: %_ comp-val: %_" % [line-position comp-val])
        ; next is the model name
        if line-position < line-length : ; still more stuff to parse
          match(index-of-char(line[line-position],'=')) :
            (equal-index:False) :
              model-input = line[line-position]
            (equal-index:Int) :
              println("parameter: %_" % [line] )
        if unique-part :
          model-input = input[line-length - 1]
          ; code for handling parameters (later)
        ; println("part 2 prefix: %_ model: %_" % [prefix model-input] )
        println("component prefix: %_ model: %_ ref-des: %_ nets %_ pins %_ value %_" % [prefix ref-des model-input to-list(net-input) nodes(element-props) comp-val])
        add(components, imported-spice-component(
          ref-des, ; reference:String
          prefix, ; element:String
          model-input,; model:String
          to-list(net-input), ; nets:List()
          ; to-list([net1, net2]), ; nets:List()
          nodes(element-props), ; pins:List()
          ; to-list([ "p[1]","p[2]" ]), ; pins:List()
          comp-val, ;   comp-val:Double
          to-list([]), ;   parameters:List()
          to-list([]) ; parameter-values
        ))
  val nets* = unique(raw-nets)
  println("nets") ; DEBUG
  println(nets*) ; DEBUG
  println("components %_" % [components]) ; DEBUG

; M1 intb in 5V 0 pmos
; M1 intb in 5V 0 
; if part has a model, and model is in mappings, use that model
; otherwise match part on prefix, look up Tupple from mappings, and add that to part
  inside pcb-module:
  ; instantiate nets
    for n in nets* do:
      make-net(to-symbol(to-net-name(n)) [], true)
      ; println(n) ; DEBUG

    defn get-net (name:String) :
      find!({ref(_) == Ref(to-net-name(name))}, nets(self))    
    defn find-instantiable (c:imported-spice-component, mappings:Tuple<des>) -> Instantiable|False :
      val name = lower-case(model(c))
      println("model %_" % [name])
      var part = None
      for m in mappings do :
        if contains?(references(m), name ):
          match(library-part(m)):
            (part-props:Instantiable) :
              println("instnatiable")
              part = part-props
            (part-props:Tuple<KeyValue>) :
              println("tuple")
              ; val params = remove-duplicate-keys $ [["type" => "ceramic" ]
              ;                           "resistance" => 1.0e3]
              match(comp-val(c)) :
                (comp-val-double:Double) :
                  println("element(c) %_" % [element(c)])
                  switch {element(c)[0] == _} :
                    'R' : part = chip-resistor(to-tuple(cat-all([["resistance" => closest-std-val(comp-val-double,0.1)], part-props])))
                    'C' : part = tantalum-cap(to-tuple(cat-all([["capacitance" => closest-std-val(comp-val-double,10.0)], part-props])))
                (uh-oh:False) :
                  fatal("You found an error I didn't anticipate. Likely caused by malformed SPICE input.")
                ; 'r' : part = chip-resistor(params)
                ; 'r' : part = chip-resistor(to-tuple(cat-all(["resistance" => 1.0e3, part-props])))
      if part is Instantiable :
        part as Instantiable
      else:
        false
  ; instantiate components
    for c in components do :
      val inst* = find-instantiable(c, mappings)
      println("in c") ; DEBUG
      println(inst*) ; DEBUG
      match(inst*:Instantiable) :  
        inst part : inst*
        println(part) ; DEBUG
        reference-designator(part) = reference(c)
        ; get pin list length
        ; val pin-length = length(pins(c))
        ; from 0 to #pins, net pin to net
        for (pin* in pins(c), net* in nets(c) ) do :
          ; println("got here") ; DEBUG
          println("net: %_ pin: %_" % [net* pin*]) ; DEBUG
          net (get-net(net*) part.(to-pin-name(pin*)))
    ; Add power and ground objects
    val raw-ground-nets = Vector<String>()
    for ground-net in ground-nets do :
      add(raw-ground-nets, lower-case(clean-net-name(ground-net) ) )
    val unique-ground-nets = unique(raw-ground-nets)
    for ground-net in unique-ground-nets do :
      symbol(get-net(ground-net)) = ocdb/symbols/ground-sym
    val raw-power-nets = Vector<String>()
    for power-net in power-nets do :
      add(raw-power-nets, lower-case(clean-net-name(power-net) ) )
    val unique-power-nets = unique(raw-power-nets)
    for power-net in unique-power-nets do :
      symbol(get-net(power-net)) = ocdb/symbols/supply-sym

    ; for n in ground-nets* do:
    ;   symbol(to-net-name(n) ) = ocdb/symbols/ground-sym
    ; for ground-net in ground-nets do :
    ; for i in 0 to length(ground-nets) do :
    ;   symbol(lower-case(clean-net-name(ground-nets[i]) ) ) = ocdb/symbols/ground-sym
    ; for i in 0 to length(power-nets) do :
    ;   symbol(lower-case(clean-net-name(power-nets[i]) ) ) = ocdb/symbols/supply-sym

      ; else :
      ;   inst part : non-library-part(pins(c))
      ;   reference-designator(part) = reference(c)
      ;   for pin* in pins(c) do :
      ;     net (get-net(pin*[1]) part.(to-pin-name(pin*[0])))
  ; add component pins to nets - assume p1 and p2 for now



; Show the Schematic and PCB for the design


; deftype Settings
; defmulti entries (s:Settings) -> Tuple<KeyValue<Symbol,?>>
; defmulti set (s:Settings, k:Symbol, value) -> False
; defmulti get (s:Settings, k:Symbol) -> ?
; defn Settings (initial-entries:Tuple<KeyValue<Symbol,?>>) :
;   val table = to-hashtable<Symbol,?>(initial-entries)
;   new Settings :
;     defmethod entries (this) :
;       val sorted-keys = qsort(keys(table))
;       to-tuple $ for k in sorted-keys seq :
;         k => table[k]
;     defmethod set (this, k:Symbol, v) :
;       table[k] = v
;     defmethod get (this, k:Symbol) :
;       table[k]

; val DEFAULT-PART-SETTINGS = [
;     `mpn => ""
;     `manufacturer => ""
;     `capacitance => 100.0e-6
;     `tolerance => 20.0
;     `max-voltage => 10.0
;     `temperature-coefficient => "X7R"
;     `inductance => 10.0e-3
;     `max-current => 1.0
;     `forward-current => 1.0
;     `forward-voltage => 1.0
;     `max-current => 1.0
;     `max-reverse-voltage => 1.0
;     `resistance => 100.0
;     `max-power => 0.125
;        ]

; public defn capacitor (options:Tuple<KeyValue<Symbol,?>>) :
;   ;Overwrite with users options
;   val settings = Settings(DEFAULT-PART-SETTINGS)
;   for entry in options do :
;     settings[key(entry)] = value(entry)
;   capacitor(settings[`mpn], settings[`manufacturer], settings[`capacitance], settings[`tolerance], settings[`max-voltage], settings[`temperature-coefficient])
  
; pcb-component capacitor (mpn:String, manufacturer:String, capacitance:Double, tolerance:Double, max-voltage:Double, temperature-coefficient:String) :
;   port p : pin[[1 2]]
;   emodel = Capacitor(capacitance, tolerance, max-voltage, false, false, temperature-coefficient, "Ceramic")
;   val sym = capacitor-sym(CapacitorNonPolarized)
;   symbol = sym(p[1] => sym.p[1], p[2] => sym.p[2])
;   val land = dummy-landpattern(2, [1.0 1.0])
;   landpattern = land(p[1] => land.p[1], p[2] => land.p[2])
;   reference-prefix = "C"
;   manufacturer = manufacturer
;   mpn = mpn

; public defn resistor (options:Tuple<KeyValue<Symbol,?>>) :
;   ;Overwrite with users options
;   val settings = Settings(DEFAULT-PART-SETTINGS)
;   for entry in options do :
;     settings[key(entry)] = value(entry)
;   resistor(settings[`mpn], settings[`manufacturer], settings[`resistance], settings[`tolerance], settings[`max-power])

; pcb-component resistor (mpn:String, manufacturer:String, resistance:Double, tolerance:Double, max-power:Double) :
;   port p : pin[[1 2]]
;   emodel = Resistor(resistance, tolerance, max-power)
;   val sym = resistor-sym(ResistorStd)
;   symbol = sym(p[1] => sym.p[1], p[2] => sym.p[2])
;   val land = dummy-landpattern(2, [1.0 1.0])
;   landpattern = land(p[1] => land.p[1], p[2] => land.p[2])
;   reference-prefix = "R"
;   manufacturer = manufacturer
;   mpn = mpn

