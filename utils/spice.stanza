#use-added-syntax(jitx)
defpackage ocdb/spice:
  import core
  import collections
  import jitx
  import jitx/commands
  import ocdb/defaults
  import ocdb/symbols
  import ocdb/land-patterns
  import ocdb/box-symbol

public pcb-struct ocdb/des :
  references:Tuple<String>
  library-part:Instantiable

public pcb-struct ocdb/imported-spice-component :
  reference:String
  element:String
  nets:List
  pins:List
  comp-val:Double
  parameters:List
  parameter-values:List

public pcb-struct ocdb/spice-element-properties:
  nodes:List
  pins:Int
  parameters:List

public defn get-spice-element-properties (prefix:String) :
  switch {prefix[0] == _} :
    'R' :
      val result = spice-element-properties(List("p", "n"),
        2,
        to-list(["ac","m","scale","temp","dtemp","tc1","tc2","noisy"]) )
      result
    else : ; C
      val result = spice-element-properties(List("p", "n"),
        2,
        to-list(["mname","m","scale","temp","dtemp","tc1","tc2","ic"]) )
      result
  

defn to-pin-name (raw:String) : 
  if to-int(raw) is Int:
    Ref("p")[to-int(raw) as Int]
  else :
    Ref(raw)

defn to-net-name (raw:String) : 
  if to-int(raw) is Int:
    to-string("%_" % [raw])
  else :
    raw

public defn ListTable<K,V> () : HashTable<K,List<V>>(List())
public defn add<?K,?V> (table:Table<?K,List<?V>>, k:K, v:V) : update(table, cons{v, _}, k)

public defn import-spice-netlist (path:String, mappings:Tuple<des>) :
  val raw = (to-tuple $ split(slurp(path), "\n"))
  val ref-to-pins = ListTable<String, [String, String, String]>()

  val raw-nets = Vector<String>()
  val components = Vector<imported-spice-component>()

; read in each line, save it in form <refdes:String>, [<prefix:String>, net, net]
; Example: Rload, [R, 1, GND]
; refdes is key
; add each net to raw-nets
  for (r in raw, i in 1 to false) do :
    val line = to-tuple(split(r, " "))
    var line-length = length(line)
    ; if all?(matches?(" "), line[line-length - 1]) :
    ;   line-length = line-length - 1
    ; if length(line) != 3 :
    ;   fatal("Malformed netlist at line %_" % [i])
    val ref = line[0]
    val element-props = get-spice-element-properties(ref)
    val net-input = Vector<String>()
    ; println("props %_" % [parameters(element-props)] )
    ; add(net-input, "blah")
    ; println(to-string(net-input[0]))
    for n in 1 through pins(element-props) do :
      ; println("n= %_ line[n]= %_" % [n line[n] ]) ; DEBUG
      println("line = %_" % [line[n]])
      if digit?(line[n][0] ) : ; add underscore to nets starting with digits
        val number-net = string-join(["_", line[n] ])
        add(net-input, number-net )
        add(raw-nets, number-net )
      else:
        add(net-input, line[n] )
        add(raw-nets, line[n] )
    val prefix = to-string(ref[0])
    ; println(ref) ; DEBUG
    add(components, imported-spice-component(ref, ; reference:String
      prefix, ; element:String
      to-list(net-input), ; nets:List()
      ; to-list([net1, net2]), ; nets:List()
      to-list([ "1","2" ]), ; pins:List()
      ; to-list([ "p[1]","p[2]" ]), ; pins:List()
      1.0, ;   comp-val:Double
      to-list([]), ;   parameters:List()
      to-list([]) ; parameter-values
    ))
  val nets* = unique(raw-nets)
  println("nets") ; DEBUG
  println(nets*) ; DEBUG

  inside pcb-module:
  ; instantiate nets
    for n in nets* do:
      make-net(to-symbol(to-net-name(n)) [], true)
      ; println(n) ; DEBUG

    defn get-net (name:String) :
      find!({ref(_) == Ref(to-net-name(name))}, nets(self))    
    defn find-instantiable (name:String, mappings:Tuple<des>) -> Instantiable|False :
      var part = None
      for m in mappings do :
        if contains?(references(m), name):
          part = library-part(m)
      if part is Instantiable :
        part as Instantiable
      else:
        false
  ; instantiate components
    for c in components do :
      val inst* = find-instantiable(element(c), mappings)
      ; println("in c") ; DEBUG
      ; println(inst*) ; DEBUG
      match(inst*:Instantiable) :  
        inst part : inst*
        println(part) ; DEBUG
        reference-designator(part) = reference(c)
        ; get pin list length
        ; val pin-length = length(pins(c))
        ; from 0 to #pins, net pin to net
        for (pin* in pins(c), net* in nets(c) ) do :
          ; println("got here") ; DEBUG
          println("net: %_ pin: %_" % [net* pin*]) ; DEBUG
          net (get-net(net*) part.(to-pin-name(pin*)))
; view-schematic()
      ; else :
      ;   inst part : non-library-part(pins(c))
      ;   reference-designator(part) = reference(c)
      ;   for pin* in pins(c) do :
      ;     net (get-net(pin*[1]) part.(to-pin-name(pin*[0])))
  ; add component pins to nets - assume p1 and p2 for now



; Show the Schematic and PCB for the design


; deftype Settings
; defmulti entries (s:Settings) -> Tuple<KeyValue<Symbol,?>>
; defmulti set (s:Settings, k:Symbol, value) -> False
; defmulti get (s:Settings, k:Symbol) -> ?
; defn Settings (initial-entries:Tuple<KeyValue<Symbol,?>>) :
;   val table = to-hashtable<Symbol,?>(initial-entries)
;   new Settings :
;     defmethod entries (this) :
;       val sorted-keys = qsort(keys(table))
;       to-tuple $ for k in sorted-keys seq :
;         k => table[k]
;     defmethod set (this, k:Symbol, v) :
;       table[k] = v
;     defmethod get (this, k:Symbol) :
;       table[k]

; val DEFAULT-PART-SETTINGS = [
;     `mpn => ""
;     `manufacturer => ""
;     `capacitance => 100.0e-6
;     `tolerance => 20.0
;     `max-voltage => 10.0
;     `temperature-coefficient => "X7R"
;     `inductance => 10.0e-3
;     `max-current => 1.0
;     `forward-current => 1.0
;     `forward-voltage => 1.0
;     `max-current => 1.0
;     `max-reverse-voltage => 1.0
;     `resistance => 100.0
;     `max-power => 0.125
;        ]

; public defn capacitor (options:Tuple<KeyValue<Symbol,?>>) :
;   ;Overwrite with users options
;   val settings = Settings(DEFAULT-PART-SETTINGS)
;   for entry in options do :
;     settings[key(entry)] = value(entry)
;   capacitor(settings[`mpn], settings[`manufacturer], settings[`capacitance], settings[`tolerance], settings[`max-voltage], settings[`temperature-coefficient])
  
; pcb-component capacitor (mpn:String, manufacturer:String, capacitance:Double, tolerance:Double, max-voltage:Double, temperature-coefficient:String) :
;   port p : pin[[1 2]]
;   emodel = Capacitor(capacitance, tolerance, max-voltage, false, false, temperature-coefficient, "Ceramic")
;   val sym = capacitor-sym(CapacitorNonPolarized)
;   symbol = sym(p[1] => sym.p[1], p[2] => sym.p[2])
;   val land = dummy-landpattern(2, [1.0 1.0])
;   landpattern = land(p[1] => land.p[1], p[2] => land.p[2])
;   reference-prefix = "C"
;   manufacturer = manufacturer
;   mpn = mpn

; public defn resistor (options:Tuple<KeyValue<Symbol,?>>) :
;   ;Overwrite with users options
;   val settings = Settings(DEFAULT-PART-SETTINGS)
;   for entry in options do :
;     settings[key(entry)] = value(entry)
;   resistor(settings[`mpn], settings[`manufacturer], settings[`resistance], settings[`tolerance], settings[`max-power])

; pcb-component resistor (mpn:String, manufacturer:String, resistance:Double, tolerance:Double, max-power:Double) :
;   port p : pin[[1 2]]
;   emodel = Resistor(resistance, tolerance, max-power)
;   val sym = resistor-sym(ResistorStd)
;   symbol = sym(p[1] => sym.p[1], p[2] => sym.p[2])
;   val land = dummy-landpattern(2, [1.0 1.0])
;   landpattern = land(p[1] => land.p[1], p[2] => land.p[2])
;   reference-prefix = "R"
;   manufacturer = manufacturer
;   mpn = mpn

