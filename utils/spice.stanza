#use-added-syntax(jitx)
defpackage ocdb/spice:
  import core
  import collections
  import jitx
  import jitx/commands
  import ocdb/defaults
  import ocdb/symbols
  import ocdb/land-patterns
  import ocdb/box-symbol
  import ocdb/generic-components
  
public pcb-struct ocdb/des :
  references:Tuple<String>
  library-part:Instantiable|Tuple<KeyValue<String, ?>>

defn remove-duplicate-keys (hs:Seqable<Seqable<KeyValue<String, ?>>>) -> Tuple<KeyValue<String, ?>> :
  to-tuple $ to-hashtable<String, ?>(cat-all(hs))
public pcb-struct ocdb/imported-spice-component :
  reference:String
  element:String
  model:String
  ; has-value:True|False
  nets:List
  pins:List
  comp-val:Double|False
  parameters:List
  parameter-values:List

public pcb-struct ocdb/spice-element-properties:
  nodes:List
  pins:Int
  has-value:True|False
  parameters:List

public defn get-spice-element-properties (prefix:String) :
  switch {prefix[0] == _} :
    'R' :
      val result = spice-element-properties(List("1", "2"),
        2, true,
        to-list(["ac","m","scale","temp","dtemp","tc1","tc2","noisy"]) )
      result
    'L' : 
      val result = spice-element-properties(List("p", "n"),
        2, true,
        to-list(["mname","nt", "m","scale","temp","dtemp","tc1","tc2","ic"]) )
      result
    'D' : 
      val result = spice-element-properties(List("a", "c"),
        2, true,
        to-list(["mname", "m", "l", "w", "ad", "as", "pd", "ps", "nrd", "nrs", "off", "ic-vds-vgs-vbs", "temp"]) )
      result
    'M' : 
      val result = spice-element-properties(List("d", "g", "s", "s"),
        4, false,
        to-list(["mname","area", "m","pj", "off", "ic", "temp", "dtemp", "lm", "wm", "lp" "wp"]) )
      result
    else : ; C
      val result = spice-element-properties(List("a", "c"),
        2, true,
        to-list(["mname","m","scale","temp","dtemp","tc1","tc2","ic"]) )
      result
  




public defn spice-to-double (spice:String) -> Double|False :
  val lower-case-spice = lower-case(spice)
  var multiplier:Double|False
  val number = to-string{"%*", % [_]} $
    for ch in lower-case-spice take-while : 
      contains?("0123456789.", ch)
    val suffix =
      if length(number) != length(lower-case-spice) : 
        lower-case-spice[length(number) to false]
      else : 
        ""
  switch {suffix == _} :
    "t":
      multiplier = 1.0e12
    "g":
      multiplier = 1.0e9
    "meg":
      multiplier = 1.0e6
    "k":
      multiplier = 1.0e3
    "mil":
      multiplier = 25.4e-6
    "m":
      multiplier = 1.0e-3
    "u":
      multiplier = 1.0e-6
    "n":
      multiplier = 1.0e-9
    "p":
      multiplier = 1.0e-12
    "f":
      multiplier = 1.0e-15
    "":
      multiplier = 1.0
    else:
      multiplier = false
  println("number %_ suffix: %_ multiplier %_" % [number suffix multiplier])
  var return-val:Double|False = false
  match(to-double(number),multiplier ) :
    (return:Double, multiplier:Double) :
      return-val = return * multiplier
    (return:False, multiplier) : return-val = false
    (return, multiplier:False) : return-val = false
  return-val
    
defn to-pin-name (raw:String) : 
  if to-int(raw) is Int:
    Ref("p")[to-int(raw) as Int]
  else :
    Ref(raw)

defn to-net-name (raw:String) : 
  if to-int(raw) is Int:
    to-string("%_" % [raw])
  else :
    raw

public defn ListTable<K,V> () : HashTable<K,List<V>>(List())
public defn add<?K,?V> (table:Table<?K,List<?V>>, k:K, v:V) : update(table, cons{v, _}, k)


; Assumptions: 
; - generated spice has already been processed with a syntax checker
; - line continuation is not used '+'
; - ignore commands, items in models (user can specify the component at the top level)
; - there is no more than 1 space between each item
public defn import-spice-netlist (path:String, use-part-database?:True|False, mappings:Tuple<des>) :
  val raw = (to-tuple $ split(slurp(path), "\n"))

  val raw-nets = Vector<String>()
  val components = Vector<imported-spice-component>()

  for (r in raw, i in 1 to false) do :
  ; does line start with a component we support?
    var valid-line:True|False = false
    println("r: %_" % [r])
    
    if length(r) > 3 :
      if contains?("rRcClLdDmM", r[0]) : ; line starts with: R C L D M
        valid-line = true
      else: valid-line = false
      ; (match-r:False) :
      ;   valid-line = false
    ; println("contains: %_ valid? %_" % [contains?("rRcClLdDmM", r[0]) valid-line])
    if valid-line :
      val line = to-tuple(split(lower-case(r), " "))
      var line-length = length(line)
      var ref:String = line[0]
      val char:Char = upper-case(ref[0])
      ref = string-join([char,ref[1 to false]])
      ; ref[0] = 'R'
      ; ref[0] = upper-case(ref[0])
      println("ref %_" % [ref])
      val element-props = get-spice-element-properties(ref)
      val net-input = Vector<String>()
      if line-length > pins(element-props) + 1: ; Line length >= _XXXX <nets> value model params
        for n in 1 through pins(element-props) do :
          ; println("n= %_ line[n]= %_" % [n line[n] ]) ; DEBUG
          ; println("line = %_" % [line[n]])
          if digit?(line[n][0] ) : ; add underscore to nets starting with digits
            val number-net = string-join(["_", line[n] ])
            add(net-input, number-net )
            add(raw-nets, number-net )
          else:
            add(net-input, line[n] )
            add(raw-nets, line[n] )
        val prefix = to-string(ref[0])
        var model-input = prefix
        ; println("part 1 prefix: %_ model: %_" % [prefix model-input] )
        ; println(ref) ; DEBUG
        var line-position = 1 + pins(element-props)
        ; println("linpos 1: %_" % [line-position])
        ; get value, if component type has value
        var comp-val:Double|False = false
        if has-value(element-props) :
          ; (match spice-to-double(line[line-position])
          ; println("line[linepos]: %_ " % [(line[line-position]) ])  
          comp-val = spice-to-double(line[line-position])
          line-position = line-position + 1
        ; println("linpos 1: %_ comp-val: %_" % [line-position comp-val])
        ; next is the model name
        if line-position < line-length : ; still more stuff to parse
          match(index-of-char(line[line-position],'=')) :
            (equal-index:False) :
              model-input = line[line-position]
            (equal-index:Int) :
              println("parameter: %_" % [line] )
          ; code for handling parameters (later)
        ; println("part 2 prefix: %_ model: %_" % [prefix model-input] )
        println("component prefix: %_ model: %_ ref: %_ nets %_ pins %_ value %_" % [prefix ref model-input to-list(net-input) nodes(element-props) comp-val])
        add(components, imported-spice-component(
          ref, ; reference:String
          prefix, ; element:String
          model-input,; model:String
          to-list(net-input), ; nets:List()
          ; to-list([net1, net2]), ; nets:List()
          nodes(element-props), ; pins:List()
          ; to-list([ "p[1]","p[2]" ]), ; pins:List()
          comp-val, ;   comp-val:Double
          to-list([]), ;   parameters:List()
          to-list([]) ; parameter-values
        ))
  val nets* = unique(raw-nets)
  println("nets") ; DEBUG
  println(nets*) ; DEBUG
  println("components %_" % [components]) ; DEBUG

; M1 intb in 5V 0 pmos
; M1 intb in 5V 0 
; if part has a model, and model is in mappings, use that model
; otherwise match part on prefix, look up Tupple from mappings, and add that to part
  inside pcb-module:
  ; instantiate nets
    for n in nets* do:
      make-net(to-symbol(to-net-name(n)) [], true)
      ; println(n) ; DEBUG

    defn get-net (name:String) :
      find!({ref(_) == Ref(to-net-name(name))}, nets(self))    
    defn find-instantiable (c:imported-spice-component, mappings:Tuple<des>) -> Instantiable|False :
      val name = lower-case(model(c))
      println("model %_" % [name])
      var part = None
      for m in mappings do :
        if contains?(references(m), name ):
          match(library-part(m)):
            (part-props:Instantiable) :
              println("instnatiable")
              part = part-props
            (part-props:Tuple<KeyValue>) :
              println("tuple")
              ; val params = remove-duplicate-keys $ [["type" => "ceramic" ]
              ;                           "resistance" => 1.0e3]
              println("element(c) %_" % [element(c)])
              switch {element(c)[0] == _} :
                'R' : part = chip-resistor(to-tuple(cat-all([["resistance" => comp-val(c)], part-props])))
                'C' : part = tantalum-cap(to-tuple(cat-all([["capacitance" => comp-val(c)], part-props])))
                ; 'r' : part = chip-resistor(params)
                ; 'r' : part = chip-resistor(to-tuple(cat-all(["resistance" => 1.0e3, part-props])))
      if part is Instantiable :
        part as Instantiable
      else:
        false
  ; instantiate components
    for c in components do :
      val inst* = find-instantiable(c, mappings)
      println("in c") ; DEBUG
      println(inst*) ; DEBUG
      match(inst*:Instantiable) :  
        inst part : inst*
        println(part) ; DEBUG
        reference-designator(part) = reference(c)
        ; get pin list length
        ; val pin-length = length(pins(c))
        ; from 0 to #pins, net pin to net
        for (pin* in pins(c), net* in nets(c) ) do :
          ; println("got here") ; DEBUG
          println("net: %_ pin: %_" % [net* pin*]) ; DEBUG
          net (get-net(net*) part.(to-pin-name(pin*)))
      ; else :
      ;   inst part : non-library-part(pins(c))
      ;   reference-designator(part) = reference(c)
      ;   for pin* in pins(c) do :
      ;     net (get-net(pin*[1]) part.(to-pin-name(pin*[0])))
  ; add component pins to nets - assume p1 and p2 for now



; Show the Schematic and PCB for the design


; deftype Settings
; defmulti entries (s:Settings) -> Tuple<KeyValue<Symbol,?>>
; defmulti set (s:Settings, k:Symbol, value) -> False
; defmulti get (s:Settings, k:Symbol) -> ?
; defn Settings (initial-entries:Tuple<KeyValue<Symbol,?>>) :
;   val table = to-hashtable<Symbol,?>(initial-entries)
;   new Settings :
;     defmethod entries (this) :
;       val sorted-keys = qsort(keys(table))
;       to-tuple $ for k in sorted-keys seq :
;         k => table[k]
;     defmethod set (this, k:Symbol, v) :
;       table[k] = v
;     defmethod get (this, k:Symbol) :
;       table[k]

; val DEFAULT-PART-SETTINGS = [
;     `mpn => ""
;     `manufacturer => ""
;     `capacitance => 100.0e-6
;     `tolerance => 20.0
;     `max-voltage => 10.0
;     `temperature-coefficient => "X7R"
;     `inductance => 10.0e-3
;     `max-current => 1.0
;     `forward-current => 1.0
;     `forward-voltage => 1.0
;     `max-current => 1.0
;     `max-reverse-voltage => 1.0
;     `resistance => 100.0
;     `max-power => 0.125
;        ]

; public defn capacitor (options:Tuple<KeyValue<Symbol,?>>) :
;   ;Overwrite with users options
;   val settings = Settings(DEFAULT-PART-SETTINGS)
;   for entry in options do :
;     settings[key(entry)] = value(entry)
;   capacitor(settings[`mpn], settings[`manufacturer], settings[`capacitance], settings[`tolerance], settings[`max-voltage], settings[`temperature-coefficient])
  
; pcb-component capacitor (mpn:String, manufacturer:String, capacitance:Double, tolerance:Double, max-voltage:Double, temperature-coefficient:String) :
;   port p : pin[[1 2]]
;   emodel = Capacitor(capacitance, tolerance, max-voltage, false, false, temperature-coefficient, "Ceramic")
;   val sym = capacitor-sym(CapacitorNonPolarized)
;   symbol = sym(p[1] => sym.p[1], p[2] => sym.p[2])
;   val land = dummy-landpattern(2, [1.0 1.0])
;   landpattern = land(p[1] => land.p[1], p[2] => land.p[2])
;   reference-prefix = "C"
;   manufacturer = manufacturer
;   mpn = mpn

; public defn resistor (options:Tuple<KeyValue<Symbol,?>>) :
;   ;Overwrite with users options
;   val settings = Settings(DEFAULT-PART-SETTINGS)
;   for entry in options do :
;     settings[key(entry)] = value(entry)
;   resistor(settings[`mpn], settings[`manufacturer], settings[`resistance], settings[`tolerance], settings[`max-power])

; pcb-component resistor (mpn:String, manufacturer:String, resistance:Double, tolerance:Double, max-power:Double) :
;   port p : pin[[1 2]]
;   emodel = Resistor(resistance, tolerance, max-power)
;   val sym = resistor-sym(ResistorStd)
;   symbol = sym(p[1] => sym.p[1], p[2] => sym.p[2])
;   val land = dummy-landpattern(2, [1.0 1.0])
;   landpattern = land(p[1] => land.p[1], p[2] => land.p[2])
;   reference-prefix = "R"
;   manufacturer = manufacturer
;   mpn = mpn

