#use-added-syntax(esir)
defpackage ocdb/ipc-footprint-generator :
  import core
  import collections
  import math
  import esir
  import esir/utils
  import esir/gen
  import esir/fonts
  import esir/repl-lib
  import ocdb/generator-utils
  import ocdb/land-patterns
  import ocdb/jedec-utils

; The IPC footprint generator is a utility to rapidly generate footprints for 
; IPC components from a standard set of parameters. Best effort has been made 
; to comprenhensively capture all properties associated with each type of 
; component footprint. The utility is architected around structs which can be 
; passed between helper functions. Each struct is defined with a constructor 
; function which takes in a HashTable of key value pairs and generally a 
; specific package type. The HashTable has required and optional pairs which 
; are defined above each respective struct. 

; The following package types are supported:
; DFN
; CHIP Array
; PSON
; SOIC
; SOJ
; SON
; SOP
; CAPAE
; CHIP
; MELF
; MOLDED
; SODFL
; WIREWOUND
; PQFP

; The following package types are unsupported yet;
; CFP
; BQFP
; CQPF
; LCC
; PLCC
; PQFN
; QFN
; QFN-2ROW
; BGA
; LGA
; DPAK
; SOT143/343
; SOT223
; SOT23
; SOT89
; SOTFL

; EXAMPLE USAGE OF CONSTRUCTOR
public pcb-package gen-chip-pkg (size:String, density:String, type:String, 
                                 courtyard?:True|False) :
  val fields = HashTable<String, ?>()
  val [l-min, l-max, w-min, w-max, t-min, t-max, h] = switch(size) :
    
    "0402" : [0.95, 1.05, 0.45, 0.55, 0.15, 0.35, 0.35]
    "0603" : [1.5, 1.7, 0.75, 0.95, 0.1, 0.5, 0.45]
    "0805" : [1.85, 2.15, 1.1, 1.4, 0.2, 0.6, 0.55]
    "1206" : [3.0, 3.3, 1.45, 1.75, 0.25, 0.75, 0.55]
  ; TODO Find source of truth for remaining popular packages
  fields["L-min"] = l-min
  fields["L-max"] = l-max
  fields["W-min"] = w-min
  fields["W-max"] = w-max
  fields["T-min"] = t-min
  fields["T-max"] = t-max
  fields["H"] = h 
  fields["Type"] = type 
  fields["Density"] = density 
  val chip = make-two-pin-struct(fields, "CHIP")
  if courtyard? :
    make-two-pads(X(chip), Y(chip), Center(chip), V1(chip), V2(chip))
  else :
    make-two-pads(X(chip), Y(chip), Center(chip))
  name = Name(chip)
  description = Description(chip)
  ref-label()

public pcb-package gen-chip-pkg (f-list:Tuple<Tuple<?>>) :
  gen-two-pin-pkg(f-list, "CHIP")

public pcb-package gen-molded-pkg (f-list:Tuple<Tuple<?>>) :
  gen-two-pin-pkg(f-list, "MOLDED")

public pcb-package gen-wirewound-pkg (f-list:Tuple<Tuple<?>>) :
  gen-two-pin-pkg(f-list, "WIREWOUND")

public pcb-package gen-melf-pkg (f-list:Tuple<Tuple<?>>) :
  gen-two-pin-pkg(f-list, "MELF")

public pcb-package gen-sodfl-pkg (f-list:Tuple<Tuple<?>>) :
  gen-two-pin-pkg(f-list, "SODFL")

public pcb-package gen-capae-pkg (f-list:Tuple<Tuple<?>>) :
  gen-two-pin-pkg(f-list, "CAPAE")

public pcb-package gen-soic-pkg (f-list:Tuple<Tuple<?>>) :
  gen-two-sided-pkg(f-list, "SOIC")

public pcb-package gen-sop-pkg (f-list:Tuple<Tuple<?>>) :
  gen-two-sided-pkg(f-list, "SOP")

public pcb-package gen-son-pkg (f-list:Tuple<Tuple<?>>) :
  gen-two-sided-pkg(f-list, "SON")

public pcb-package gen-pson-pkg (f-list:Tuple<Tuple<?>>) :
  gen-two-sided-pkg(f-list, "PSON")

;TODO add support for CFP, unsure how to calculate lead span and range, 
;     from side, top, bottom exit and foot configurations

public pcb-package gen-soj-pkg (f-list:Tuple<Tuple<?>>) :
  gen-two-sided-pkg(f-list, "SOJ")

public pcb-package gen-chip-array-pkg (f-list:Tuple<Tuple<?>>) :
  gen-two-sided-pkg(f-list, "CHIP-ARRAY")

public pcb-package gen-pqfp-pkg (f-list:Tuple<Tuple<?>>) :
  gen-four-sided-pkg(f-list, "PQFP")

public pcb-package gen-dfn-pkg (f-list:Tuple<Tuple<?>>) :
  val fields = HashTable<String, ?>()
  for f in f-list do :
    fields[f[0]] = f[1]
  val cmp = make-dfn-struct(fields)
  switch(Type(cmp)) :
    2 : make-two-pads-offset(X1(cmp), Y1(cmp), C1(cmp), C1-o(cmp), V1(cmp), 
                             V2(cmp))
    3 : make-three-pads-offset(X1(cmp), X2(cmp), Y1(cmp), Y2(cmp), C1(cmp),
                               C1-o(cmp), C2(cmp), V1(cmp), V2(cmp))
    4 : make-four-pads-offset(["Top", "Left"], "a-clock", X1(cmp), Y1(cmp),
                              C1(cmp), C1-o(cmp), C2(cmp), V1(cmp), V2(cmp))
    ; TODO make silkscreen
  name = Name(cmp)
  description = Description(cmp)
  ref-label()

public defn gen-two-pin-pkg (f-list:Tuple<Tuple<?>>, pkg:String) :
  inside pcb-package :
    val fields = HashTable<String, ?>()
    for f in f-list do :
      fields[f[0]] = f[1]
    val cmp = make-two-pin-struct(fields, pkg)
    make-two-pads(X(cmp), Y(cmp), Center(cmp), V1(cmp), 
                  V2(cmp))
    ; TODO make silkscreen
    name = Name(cmp)
    description = Description(cmp)
    ref-label()

public defn gen-two-sided-pkg (f-list:Tuple<Tuple<?>>, pkg:String) :
  inside pcb-package :
    val fields = HashTable<String, ?>()
    for f in f-list do :
      fields[f[0]] = f[1]
    val cmp = make-two-sided-struct(fields, pkg)
    switch([pkg, Hull-type(cmp)]) :
      ["CHIP-ARRAY", "convexS"] :
        make-convex-e-pads(Pin-n(cmp), X1(cmp), X2(cmp), Y1(cmp), 
                           Center(cmp), Pitch(cmp), Cmp-body-W(cmp), V1(cmp),
                           V2(cmp))
      else :
        make-two-sided-pads(["Top", "Left"], Pin-n(cmp), X1(cmp), Y1(cmp), 
                            Center(cmp), Pitch(cmp), V1(cmp), V2(cmp))
    if THL(cmp) > 0.0 :
      pad p[Pin-n(cmp) + 1] : {smd-pad(THL(cmp), THW(cmp))} at loc(0.0, 0.0)
    ; TODO make silkscreen
    ; TODO add support for rounded pads
    name = Name(cmp)
    description = Description(cmp)
    ref-label()

public defn gen-four-sided-pkg (f-list:Tuple<Tuple<?>>, pkg:String) :
  inside pcb-package :
    val fields = HashTable<String, ?>()
    for f in f-list do :
      fields[f[0]] = f[1]
    val cmp = make-four-sided-struct(fields, pkg)
    val start = switch(Pin1-loc(cmp)) :
      "topleft" : ["Top", "Left"]
      "topcenter" : ["Top", "Center"]
    make-four-sided-pads(start, Pins-m(cmp), Pins-n(cmp), X(cmp), Y(cmp), 
                         C1(cmp), C2(cmp), Pitch(cmp), V1(cmp), V2(cmp))
    if THL(cmp) > 0.0 :
      val n = 2 * (Pins-m(cmp) + Pins-n(cmp))
      pad p[n + 1] : {smd-pad(THL(cmp), THW(cmp))} at loc(0.0, 0.0)
    ; TODO make silkscreen
    ; TODO add support for rounded pads
    name = Name(cmp)
    description = Description(cmp)
    ref-label()
  
defn two-pin-fillet-values (pkg:String, predicate:Double, density:String) 
                                                          -> [?, ?, ?, ?] :
  println("predicate: %_" % [predicate])
  switch(pkg) :
    "CHIP" :
      if predicate > 4.75 :
        switch(density) :
          "least" : [0.4, 0.0, -0.05, 0.1]
          "nominal" : [0.5, 0.0, 0.0, 0.2]
          "most" : [0.6, 0.0, 0.05, 0.4]
      else if predicate > 3.85 :
        switch(density) :
          "least" : [0.3, 0.0, -0.05, 0.1]
          "nominal" : [0.4, 0.0, 0.0, 0.2]
          "most" : [0.5, 0.0, 0.05, 0.4]
      else if predicate > 2.85 :
        switch(density) :
          "least" : [0.25, 0.0, -0.05, 0.1]
          "nominal" : [0.35, 0.0, 0.0, 0.2]
          "most" : [0.45, 0.0, 0.05, 0.4]
      else if predicate > 1.3 :
        switch(density) :
          "least" : [0.2, 0.0, -0.05, 0.1]
          "nominal" : [0.3, 0.0, 0.0, 0.2]
          "most" : [0.4, 0.0, 0.05, 0.4]
      else if predicate > 0.75 :
        switch(density) :
          "least" : [0.15, -0.02, -0.02, 0.1]
          "nominal" : [0.2, -0.01, -0.01, 0.15]
          "most" : [0.25, 0.0, 0.0, 0.2]
      else if predicate > 0.5 :
        switch(density) :
          "least" : [0.08, -0.03, -0.03, 0.1]
          "nominal" : [0.1, -0.02, -0.02, 0.15]
          "most" : [0.12, -0.01, -0.01, 0.2]
      else :
        switch(density) :
          "least" : [0.04, -0.04, -0.04, 0.1]
          "nominal" : [0.05, -0.03, -0.03, 0.15]
          "most" : [0.06, -0.02, -0.02, 0.2]
    "MOLDED" :
      if predicate > 4.2 :
        switch(density) :
          "least" : [0.15, 0.5, -0.05, 0.1]
          "nominal" : [0.2, 0.6, 0.0, 0.2]
          "most" : [0.25, 0.7, 0.05, 0.4]
      else if predicate > 3.2 :
        switch(density) :
          "least" : [0.1, 0.45, -0.05, 0.1]
          "nominal" : [0.15, 0.55, 0.0, 0.2]
          "most" : [0.2, 0.65, 0.05, 0.4]
      else if predicate > 2.2 :
        switch(density) :
          "least" : [0.05, 0.4, -0.05, 0.1]
          "nominal" : [0.1, 0.5, 0.0, 0.2]
          "most" : [0.15, 0.6, 0.05, 0.4]
      else if predicate > 1.2 :
        switch(density) :
          "least" : [0.0, 0.35, -0.05, 0.1]
          "nominal" : [0.05, 0.45, 0.0, 0.2]
          "most" : [0.1, 0.55, 0.05, 0.4]
      else :
        switch(density) :
          "least" : [-0.05, 0.3, -0.05, 0.1]
          "nominal" : [0.0, 0.4, 0.0, 0.2]
          "most" : [0.05, 0.5, 0.05, 0.4]
    "WIREWOUND" :
      if predicate > 4.2 :
        switch(density) :
          "least" : [0.15, 0.5, -0.05, 0.1]
          "nominal" : [0.2, 0.6, 0.0, 0.2]
          "most" : [0.25, 0.7, 0.05, 0.4]
      else if predicate > 3.2 :
        switch(density) :
          "least" : [0.1, 0.45, -0.05, 0.1]
          "nominal" : [0.15, 0.55, 0.0, 0.2]
          "most" : [0.2, 0.65, 0.05, 0.4]
      else if predicate > 2.2 :
        switch(density) :
          "least" : [0.05, 0.4, -0.05, 0.1]
          "nominal" : [0.1, 0.5, 0.0, 0.2]
          "most" : [0.15, 0.6, 0.05, 0.4]
      else if predicate > 1.2 :
        switch(density) :
          "least" : [0.0, 0.35, -0.05, 0.1]
          "nominal" : [0.05, 0.45, 0.0, 0.2]
          "most" : [0.1, 0.55, 0.05, 0.4]
      else :
        switch(density) :
          "least" : [-0.05, 0.3, -0.05, 0.1]
          "nominal" : [0.0, 0.4, 0.0, 0.2]
          "most" : [0.05, 0.5, 0.05, 0.4]
    "MELF" :
      switch(density) :
        "least" : [0.2, 0.02, 0.01, 0.1]
        "nominal" : [0.4, 0.1, 0.05, 0.2]
        "most" : [0.6, 0.2, 0.1, 0.4]
    "SODFL" :
      switch(density) :
        "least" : [0.1, 0.0, -0.05, 0.1]
        "nominal" : [0.2, 0.0, 0.0, 0.2]
        "most" : [0.3, 0.0, 0.05, 0.4]
    "CAPAE" :
      if predicate > 10.0 :
        switch(density) :
          "least" : [0.4, -0.05, 0.4, 0.2]
          "nominal" : [0.7, 0.0, 0.5, 0.4]
          "most" : [1.0, 0.1, 0.6, 0.8]
      else: 
        switch(density) :
          "least" : [0.3, -0.1, 0.3, 0.1]
          "nominal" : [0.5, 0.0, 0.4, 0.2]
          "most" : [0.7, 0.05, 0.5, 0.4]

defn sop-qfp-fillet-values (pitch:Double, density:String) -> [?, ?, ?, ?] :
  if pitch > 1.0 :
    switch(density) :
      "least" : [0.3, 0.4, 0.05, 0.1]
      "nominal" : [0.35, 0.45, 0.06, 0.2]
      "most" : [0.4, 0.5, 0.07, 0.4]
  else if pitch > 0.8 :
    switch(density) :
      "least" : [0.25, 0.35, 0.04, 0.1]
      "nominal" : [0.3, 0.4, 0.05, 0.2]
      "most" : [0.35, 0.45, 0.06, 0.4]
  else if pitch > 0.65 :
    switch(density) :
      "least" : [0.2, 0.3, 0.03, 0.1]
      "nominal" : [0.25, 0.35, 0.04, 0.2]
      "most" : [0.3, 0.4, 0.05, 0.4]
  else if pitch > 0.5 :
    switch(density) :
      "least" : [0.15, 0.25, 0.01, 0.1]
      "nominal" : [0.2, 0.3, 0.02, 0.2]
      "most" : [0.25, 0.35, 0.03, 0.4]
  else if pitch > 0.4 :
    switch(density) :
      "least" : [0.1, 0.2, -0.02, 0.1]
      "nominal" : [0.15, 0.25, -0.01, 0.2]
      "most" : [0.2, 0.3, 0.0, 0.4]
  else :
    switch(density) :
      "least" : [0.1, 0.2, -0.03, 0.1]
      "nominal" : [0.15, 0.25, -0.02, 0.2]
      "most" : [0.2, 0.3, -0.01, 0.4]

defn soj-plcc-fillet-values (density:String) -> [?, ?, ?, ?] :
  switch(density) :
    "least" : [0.15, 0.0, 0.01, 0.1]
    "nominal" : [0.35, 0.0, 0.03, 0.2]
    "most" : [0.55, 0.1, 0.05, 0.4]

defn son-qfn-fillet-values (density:String) -> [?, ?, ?, ?] :
  switch(density) :
    "least" : [0.1, 0.0, -0.04, 0.1]
    "nominal" : [0.2, 0.0, -0.04, 0.2]
    "most" : [0.3, 0.0, -0.04, 0.4]

defn pson-pqfn-fillet-values (density:String) :
  switch(density) :
    "least" : [-0.05, -0.05, -0.05, 0.1]
    "nominal" : [0.0, 0.0, 0.0, 0.2]
    "most" : [0.05, 0.05, 0.05, 0.4]

defn chip-array-fillet-values (density:String, pitch:Double) :
  if pitch > 2.54 :
    switch(density) :
      "least" : [0.45, 0.02, -0.04, 0.1]
      "nominal" : [0.55, 0.04, -0.01, 0.2]
      "most" : [0.65, 0.06, 0.01, 0.4]
  else if pitch > 1.27 :
    switch(density) :
      "least" : [0.4, 0.0, -0.04, 0.1]
      "nominal" : [0.5, 0.02, -0.02, 0.2]
      "most" : [0.6, 0.04, 0.0, 0.4]
  if pitch > 0.8 :
    switch(density) :
      "least" : [0.35, -0.02, -0.05, 0.1]
      "nominal" : [0.45, 0.0, -0.03, 0.2]
      "most" : [0.55, 0.02, -0.01, 0.4]
  else if pitch > 0.65 :
    switch(density) :
      "least" : [0.25, -0.04, -0.06, 0.1]
      "nominal" : [0.35, -0.02, -0.04, 0.2]
      "most" : [0.45, 0.0, -0.02, 0.4]
  else if pitch > 0.5 :
    switch(density) :
      "least" : [0.2, -0.05, -0.07, 0.1]
      "nominal" : [0.3, -0.03, -0.05, 0.2]
      "most" : [0.4, -0.01, -0.03, 0.4]
  if pitch > 0.4 :
    switch(density) :
      "least" : [0.15, -0.06, -0.07, 0.1]
      "nominal" : [0.25, -0.04, -0.05, 0.2]
      "most" : [0.35, -0.02, -0.03, 0.4]
  else :
    switch(density) :
      "least" : [0.1, -0.07, -0.07, 0.1]
      "nominal" : [0.2, -0.05, -0.05, 0.2]
      "most" : [0.3, -0.03, -0.03, 0.4]

defn calc-pad-size (l:Double, fillet:Double, l-tol:Double, fab-tol:Double,
                    placement-tol:Double, subtract?:True|False) -> Double :
  if subtract? :
    l - (2.0 * fillet) - sqrt(pow(l-tol, 2.0) +
                              pow(fab-tol, 2.0) +
                              pow(placement-tol, 2.0))
  else :
    l + (2.0 * fillet) + sqrt(pow(l-tol, 2.0) +
                              pow(fab-tol, 2.0) +
                              pow(placement-tol, 2.0))

public defn make-two-pin-struct (fields:HashTable<String, ?>, pkg:String) 
                                                         -> TWO-PIN-STRUCT :
  if not contains?(["CHIP", "MOLDED", "WIREWOUND", "MELF", "SODFL", "CAPAE"]
                   , pkg) :
    fatal("Component type not supported")

; assign required values
  val required = ["L-min", "L-max", "W-min", "W-max", "T-min", "T-max", 
                  "H", "Density"]
  for k in required do :
    if not key?(fields, k) :
      fatal("%_ field is required." % [k])
  val [l-min, l-max, w-min, w-max, t-min, t-max, h, density] = 
      map({fields[_]}, required) as ?
  val [tw-min, tw-max] = 
    if contains?(["MOLDED", "WIREWOUND", "SODFL", "CAPAE"], pkg) :
      for k in ["TW-min", "TW-max"] do :
        if not key?(fields, k) :
          fatal("%_ field is required." % [k])
      [fields["TW-min"], fields["TW-max"]]
    else :
      [w-min, w-max]
  val [e-min, e-max] =
    if contains?(["SODFL", "CAPAE"], pkg) :
      for k in ["E-min", "E-max"] do :
        if not key?(fields, k) :
          fatal("%_ field is required." % [k])
      [fields["E-min"], fields["E-max"]]
    else :
      [l-min, l-max]
  val [d-min, d-max] =
    if contains?(["CAPAE"], pkg) :
      for k in ["D-min", "D-max"] do :
        if not key?(fields, k) :
          fatal("%_ field is required." % [k])
      [fields["D-min"], fields["D-max"]]
    else :
      [l-min, l-max]
  val type =
    if contains?(["CHIP", "MOLDED", "MELF"], pkg) :
      if not key?(fields, "Type") :
        fatal("Type field is required.")
      else :
        fields["Type"]
    else :
      ""

; input checks
  if not contains?(["least", "nominal", "most"], density) :
    fatal("Component Density Level not supported")
  if contains?(["CHIP", "MOLDED"], pkg) :
    if not contains?(["cap", "ind", "res", "dio"], type) :
      fatal("Component Type not supported")
  else if pkg == "MELF" :
    if not contains?(["res", "dio"], type) :
      fatal("Component Type not supported")

; assign optional values for polarity, tolerances, and spacing
  val polarity-pin = switch(key?(fields, "Polarity-pin")) :
    true : fields["Polarity-pin"]
    false : false
  val [l-tol, w-tol, t-tol] = switch([key?(fields, "L-tol"),
                                     key?(fields, "W-tol")
                                     key?(fields, "T-tol")]) :
    [true, true, true] : [fields["L-tol"], fields["W-tol"], fields["T-tol"]]
    else : 
      [(l-max - l-min), (w-max - w-min), (t-max - t-min)]
  val tw-tol =
    if contains?(["MOLDED", "WIREWOUND", "SODFL", "CAPAE"], pkg) :
      if key?(fields, "TW-tol") :
        fields["TW-tol"]
      else :
        tw-max - tw-min
    else :
      0.0
  val e-tol =
    if contains?(["SODFL", "CAPAE"], pkg) :
      if key?(fields, "E-tol") :
        fields["E-tol"]
      else :
        e-max - e-min
    else :
      0.0
  val s-tol =
    if key?(fields, "S-tol") :
      fields["S-tol"]
    else :
      if contains?(["SODFL", "CAPAE"], pkg) :
        sqrt(pow(e-tol, 2.0) + (2.0 * pow(t-tol, 2.0)))
      else :
        sqrt(pow(l-tol, 2.0) + (2.0 * pow(t-tol, 2.0)))
  val [s-min, s-max] =
    if key?(fields, "S-min") and key?(fields, "S-max") :
      [fields["S-min"], fields["S-max"]]
    else :
      if contains?(["SODFL", "CAPAE"], pkg) :
        [(e-min - (2.0 * t-max)), (e-min - (2.0 * t-max)) + s-tol]
      else : [(l-min - (2.0 * t-max)), (l-min - (2.0 * t-max)) + s-tol] 

; assign optional values for fillets and courtyard excess  
  val fillet-fields = ["JT-min", "JH-min", "JS-min", "Courtyard-excess"]
  val predicate = switch(pkg) :
    ; predicate is average component length
    "CHIP" : (l-min + l-max) / 2.0
    ; predicate is component height
    "MOLDED" : h
    ; predicate is component height
    "WIREWOUND" : h
    ; no predicate for MELF components
    "MELF" : 0.0
    ; no predicate for SODFL components
    "SODFL" : 0.0
    ; predicate is courtyard length 
    "CAPAE" : (l-min + l-max) / 2.0
  val [jt-min, jh-min, js-min, courtyard-excess] = 
    if all?(key?{fields, _}, fillet-fields) : 
      [fields["JT-min"], fields["JH-min"], fields["JS-min"], 
       fields["Courtyard-excess"]]
    else :
      two-pin-fillet-values(pkg, predicate, density)
  println("%_ %_ %_ %_" % [jt-min, jh-min, js-min, courtyard-excess])

; assign optional values for fab and placement tolerances
  val [fab-tol, placement-tol] = switch([key?(fields, "Fab-tol"),
                                         key?(fields, "Placement-tol")]) :
    [true, true] : [fields["Fab-tol"], fields["Placement-tol"]]
    else : [0.1, 0.15]

; calculate and assign geometry values
  val z-max = 
    if contains?(["SODFL", "CAPAE"], pkg) :
      calc-pad-size(e-min, jt-min, e-tol, fab-tol, placement-tol, false)
    else :
      calc-pad-size(l-min, jt-min, l-tol, fab-tol, placement-tol, false)
  val g-min = calc-pad-size(s-max, jh-min, s-tol, fab-tol, placement-tol, 
                            true)
  val x-max =
    if contains?(["MOLDED", "WIREWOUND", "SODFL", "CAPAE"], pkg) :
      calc-pad-size(tw-min, js-min, tw-tol, fab-tol, placement-tol, false)
    else : 
      calc-pad-size(w-min, js-min, w-tol, fab-tol, placement-tol, false)
  val geometry-fields = ["X", "Y", "Center"]
  val [x, y, center] =
    if all?(key?{fields, _}, geometry-fields) :
      map({fields[_]}, geometry-fields) as ?
    else : [x-max, (z-max - g-min) / 2.0 , (z-max + g-min) / 2.0]
  println("Z-max: %_" % [z-max])
  println("G-min: %_" % [g-min])
  println("X-max: %_" % [x-max])
  println("C: %_" % [center])
  println("x: %_" % [x])
  println("y: %_" % [y])
  
; assign values for width of silkscreen courtyard and assembly lines
  val line-width-fields = ["Sl-W", "Cl-W", "Al-W"]
  val [sl-W, cl-W, al-W] = 
    if all?(key?{fields, _}, line-width-fields) :
      map({fields[_]}, line-width-fields) as ?
    else : [0.2, 0.5, 0.1]

; assign values for silkscreen, courtyard, and assembly dimensions
  val [r1, r2] =
    if key?(fields, "R1") and key?(fields, "R2") :
      [fields["R1"], fields["R2"]]
    else if contains?(["MOLDED", "WIREWOUND", "SODFL", "CAPAE"], pkg) :
      [l-max, w-max]
    else : [g-min - (2.0 * sl-W), x-max - sl-W]
  val [v1, v2] =
    if key?(fields, "V1") and key?(fields, "V2") :
      [fields["V1"], fields["V2"]]
    else if contains?(["MOLDED", "WIREWOUND", "SODFL", "CAPAE"], pkg) :
      [z-max + (2.0 * courtyard-excess),
       w-max + (2.0 * courtyard-excess)]
    else :
      [z-max + (2.0 * courtyard-excess), 
       x-max + (2.0 * courtyard-excess)]
  val [a, b] =
    if key?(fields, "A") and key?(fields, "B") :
      [fields["A"], fields["B"]]
    else :
      [l-max, w-max]
  val [cmp-body-W, cmp-body-L] = switch([key?(fields, "Cmp-body-W"),
                                         key?(fields, "Cmp-body-L")]) :
    [true, true] : [fields["Cmp-body-W"], fields["Cmp-body-L"]]
    else : [w-max, l-max]

; assign name and description
  val [type-str, type-abbr] = switch(type) :
    "cap" : ["Capacitor", "CAP"]
    "ind" : ["Inductor", "IND"]
    "res" : ["Resistor", "RES"]
    "dio" : ["Diode", "DIO"]
    else : ["", ""]
  val [pkg-str, pkg-abbr] = switch(pkg) :
    "CHIP" : ["Chip", "C"]
    "MOLDED" : ["Molded", "M"]
    "MELF" : ["MELF", "MELF"]
    "SODFL" : ["SODFL", "SODFL"]
    "CAPAE" : ["CAPAE", "CAPAE"]
    "WIREWOUND" : ["Precision Wire Wound Inductor", "INDP"]
  val [pol-str, pol-abbr] = 
    if not polarity-pin or pkg == "WIREWOUND" :
      ["", ""]
    else :
      ["Polarized", "P"]
  val size-str = to-string("%_%_X%_" % 
                           [to-int((l-max + l-min) / 2.0 * 100.0), 
                            to-int((w-max + w-min) / 2.0 * 100.0),
                            to-int(h * 10.0)])
  val [density-str, density-abbr] = switch(density) :
    "least" : ["Least", "L"]
    "nominal" : ["Nominal", "N"]
    "most" : ["Most", "M"]
  val name = switch(key?(fields, "Name")) :
    true : fields["Name"]
    else : to-string("%_%_%_%_%_" % [type-abbr, pkg-abbr, pol-abbr, 
                                     size-str, density-abbr])
  println("Name: %_" % [name])
  val size-l-str = to-string((l-max + l-min) / 2.0)
  val size-w-str = to-string((w-max + w-min) / 2.0)
  val description = switch(key?(fields, "Description")) :
    true : fields["Description"]
    else : to-string("%_ %_, 2-Leads, Body %_x%_mm, IPC %_ Density" % 
                     [pkg-str, type-str, size-l-str, size-w-str, 
                      density-str])
  println("Description: %_" % [description])

  TWO-PIN-STRUCT(l-min, l-max, w-min, w-max, t-min, t-max, tw-min, tw-max,
                 e-min, e-max, d-min, d-max, h, type, density, polarity-pin,
                 s-min, s-max, jt-min, jh-min, js-min, l-tol, s-tol, w-tol,
                 t-tol, tw-tol, e-tol, fab-tol, placement-tol, 
                 courtyard-excess, x, y, center, sl-W, r1, r2, v1, v2, cl-W,
                 a, b, al-W, cmp-body-W, cmp-body-L, name, description)

public defn make-dfn-struct (fields:HashTable<String, ?>) -> DFN-STRUCT :
; assign required values
  val required = ["L-min", "L-max", "W-min", "W-max", "T1-min", "T1-max",
                  "TW1-min", "TW1-max", "H", "H-s", "Type", "Density", "S1",
                  "S1-o"]
  for k in required do :
    if not key?(fields, k) :
      fatal("%_ field is required." % [k])
  val [l-min, l-max, w-min, w-max, t1-min, t1-max, tw1-min, tw1-max, h, h-s,
       type, density, s1, s1-o] = map({fields[_]}, required) as ?
  val s2 =
    if contains?([3, 4], type) :
      if not key?(fields, "S2") :
        fatal("S2 field is required.")
      fields["S2"]
    else :
      0.0
  val [t2-min, t2-max, tw2-min, tw2-max] = 
    if type == 3 :
      val f-list = ["T2-min", "T2-max", "TW2-min", "TW2-max"]
      for k in f-list do :
        if not key?(fields, k) :
          fatal("%_ field is required." % [k])
      map({fields[_]}, f-list) as ?
    else :
      [0.0, 0.0, 0.0, 0.0]

; input checks
  if not contains?(["least", "nominal", "most"], density) :
    fatal("Component Density Level not supported")
  if not contains?([2, 3, 4], type) :
    fatal("Component Type not supported")

; assign optional values for tolerances
  val tol-fields = ["L-tol", "W-tol", "T1-tol", "TW1-tol"]
  val [l-tol, w-tol, t1-tol, tw1-tol] = 
    if all?(key?{fields, _}, tol-fields) :
      map({fields[_]}, tol-fields) as ?
    else :
      [(l-max - l-min), (w-max - w-min), (t1-max - t1-min), 
       (tw1-max - tw1-min)]
  val [t2-tol, tw2-tol] =
    if type == 3 :
      if key?(fields, "T2-tol") and key?(fields, "TW2-tol") :
        [fields["T2-tol"], fields["TW2-tol"]]
      else :
        [(t2-max - t2-min), (tw2-max - tw2-min)]
    else :
      [0.0, 0.0]

; assign optional values for fillet and courtyard excess
  val [jp-min, courtyard-excess] =
    if key?(fields, "JP-min") and key?(fields, "Courtyard-excess") :
      [fields["JP-min"], fields["Courtyard-excess"]]
    else :
      if l-max > 1.6 :
        switch(density) :
          "least" : [-0.05, 0.1]
          "nominal" : [0.0, 0.2]
          "most" : [0.05, 0.4]
      else :
        switch(density) :
          "least" : [-0.04, 0.1]
          "nominal" : [-0.04, 0.15]
          "most" : [-0.04, 0.2]

; assign optional values for fab and placement tolerances
  val [fab-tol, placement-tol] = switch([key?(fields, "Fab-tol"),
                                         key?(fields, "Placement-tol")]) :
    [true, true] : [fields["Fab-tol"], fields["Placement-tol"]]
    else : [0.1, 0.15]

; calculate and assign geometry values
  val all-geometry-fields = ["X1", "Y1", "C1", "C1-o"]
  val [x1, y1, c1, c1-o] = 
    if all?(key?{fields, _}, all-geometry-fields) :
      map({fields[_]}, all-geometry-fields) as ?
    else :
      [calc-pad-size(tw1-min, jp-min, tw1-tol, fab-tol, placement-tol, 
                     false), 
       calc-pad-size(t1-min, jp-min, t1-tol, fab-tol, placement-tol, false),
       s1, s1-o]
  val [x2, y2] =
    if type == 3 :
      if key?(fields, "X2") and key?(fields, "Y2") :
        [fields["X2"], fields["Y2"]]
      else :
        [calc-pad-size(tw2-min, jp-min, tw2-tol, fab-tol, placement-tol, 
                       false),
         calc-pad-size(t2-min, jp-min, t2-tol, fab-tol, placement-tol, 
                       false)]
    else :
      [0.0, 0.0]
  val c2 =
    if contains?([3, 4], type) :
      if key?(fields, "C2") :
        fields["C2"]
      else :
        s2
    else :
      0.0

; assign values for width of silkscreen courtyard and assembly lines
  val line-width-fields = ["Sl-W", "Cl-W", "Al-W"]
  val [sl-W, cl-W, al-W] = 
    if all?(key?{fields, _}, line-width-fields) :
      map({fields[_]}, line-width-fields) as ?
    else : [0.2, 0.5, 0.1]
    ; TODO check whether this is even needed

; assign values for silkscreen, courtyard, and assembly dimensions
  val [r1, r2] =
    if key?(fields, "R1") and key?(fields, "R2") :
      [fields["R1"], fields["R2"]]
    else :
      [l-max, w-max]
  val [v1, v2] =
    if key?(fields, "V1") and key?(fields, "V2") :
      [fields["V1"], fields["V2"]]
    else :
      [l-max + (2.0 * courtyard-excess), w-max + (2.0 * courtyard-excess)]
  val [a, b] =
    if key?(fields, "A") and key?(fields, "B") :
      [fields["A"], fields["B"]]
    else :
      [l-max, w-max]
  val [cmp-body-W, cmp-body-L] =
    if key?(fields, "Cmp-body-W") and key?(fields, "Cmp-body-L") :
      [fields["Cmp-body-W"], fields["Cmp-body-L"]]
    else :
      [w-max, l-max]

; assign name and description
  val size-str = to-string("%_X%_X%_" % 
                           [to-int((l-max + l-min) / 2.0 * 100.0), 
                            to-int((w-max + w-min) / 2.0 * 100.0), 
                            to-int(h * 100.0)])
  val [density-str, density-abbr] = switch(density) :
    "least" : ["Least", "L"]
    "nominal" : ["Nominal", "N"]
    "most" : ["Most", "M"]
  val name = switch(key?(fields, "Name")) :
    true : fields["Name"]
    else : to-string("DFN%_-%_%_" % [size-str, to-string(type), 
                                     density-abbr])
  val size-l-str = to-string((l-max + l-min) / 2.0)
  val size-w-str = to-string((w-max + w-min) / 2.0)
  val size-h-str = to-string(h)
  val description = switch(key?(fields, "Description")) :
    true : fields["Description"]
    else : to-string("DFN, %_-Leads, Body %_x%_x%_mm, IPC %_ Density" % 
                     [to-string(type), size-l-str, size-w-str, size-h-str, 
                      density-str])
  println("Name: %_" % [name])
  println("Description: %_" % [description])

  DFN-STRUCT(l-min, l-max, w-min, w-max, t1-min, t1-max, tw1-min, tw1-max,
             t2-min, t2-max, tw2-min, tw2-max, h, h-s, type, density, 
             s1, s1-o, s2, jp-min, l-tol, w-tol, t1-tol, tw1-tol, t2-tol, 
             tw2-tol, fab-tol, placement-tol, courtyard-excess, x1, x2, y1,
             y2, c1, c1-o, c2, sl-W, r1, r2, v1, v2, cl-W, a, b, al-W, 
             cmp-body-W, cmp-body-L, name, description)
  
public defn make-two-sided-struct (fields:HashTable<String, ?>, pkg:String) 
                                                       -> TWO-SIDED-STRUCT :
  if not contains?(["SOIC", "SOP", "SOJ", "SON", "PSON", "CHIP-ARRAY"], 
                   pkg) :
    fatal("Component type not supported")
; assign required values
  val required = ["L-min", "L-max", "W-min", "W-max", "T1-min", "T1-max",
                  "TW1-min", "TW1-max", "H", "Pin-n", "Density"]
  for k in required do :
    if not key?(fields, k) :
      fatal("%_ field is required." % [k])
  val [l-min, l-max, w-min, w-max, t1-min, t1-max, tw1-min, tw1-max, h,             pin-n, density] = 
    map({fields[_]}, required) as ?
  val h-s =
    if contains?(["SOIC", "SOP", "SOJ", "SON", "PSON"], pkg) :
      if key?(fields, "H-s") :
        fields["H-s"]
      else :
        fatal("H-s field required")
    else :
      0.0
  val pad-shape =
    if contains?(["SOIC", "SOP", "SOJ", "CHIP-ARRAY"], pkg) :
      if key?(fields, "Pad-shape") :
        fields["Pad-shape"]
      else :
        fatal("Pad-shape field required")
    else :
      "rectangular"
  val [tpb1-min, tpb1-max] =
    if contains?(["PSON"], pkg) :
      if key?(fields, "TPB1-min") and key?(fields, "TPB1-max") :
        [fields["TPB1-min"], fields["TPB1-max"]]
      else :
        fatal("TPB1-min and TPB1-max fields required")
    else :
      [0.0, 0.0]
  val hull-type = 
    if pkg == "CHIP-ARRAY" :
      if key?(fields, "Hull-type") :
        if contains?(["flat", "concave", "convexE", "convexS"], 
                     fields["Hull-type"]) :
          fields["Hull-type"]
        else :
          fatal("Chip array hull type not supported")
      else :
        fatal("Hull-type field required")
    else :
      "n-a"
  val [e-min, e-max] = 
    if contains?(["SOIC", "SOP", "SOJ"], pkg) :
      if key?(fields, "E-min") and key?(fields, "E-max") :
        [fields["E-min"], fields["E-max"]]
      else :
        fatal("E-min and E-max fields required")
    else :
      [l-min - (2.0 * tpb1-max), l-max - (2.0 * tpb1-min)]
  val pitch = 
    if pkg == "SOIC" :
      1.27
    else if contains?(["SOP", "SOJ", "SON", "PSON", "CHIP-ARRAY"], pkg) :
      if key?(fields, "Pitch") :
        fields["Pitch"]
      else :
        fatal("Pitch field is required.") 
    else : 
      0.0
  val [th1-min, th1-max] =
    if contains?(["SON"], pkg) :
      if key?(fields, "TH1-min") and key?(fields, "TH1-max") :
        [fields["TH1-min"], fields["TH1-max"]]
      else :
        fatal("TH1-min and TH1-max fields required")
    else :
      [0.0, 0.0]
  val lead-fields = ["TW2-min", "TW2-max"]
  val [tw2-min, tw2-max] =
    if pkg == "CHIP-ARRAY" and hull-type == "convexS" :
      if all?(key?{fields, _}, lead-fields) :
        map({fields[_]}, lead-fields) as ?
      else :
        fatal("TW2-min and TW2-max fields required")
    else :
      [0.0, 0.0]
  
; input checks
  if not contains?(["least", "nominal", "most"], density) :
    fatal("Component Density Level not supported")
  if not contains?(["rounded", "rectangular"], pad-shape) :
    fatal("Pad Shape not supported")

; assign optional values for thermal pad
  val therm-fields = ["THW-min", "THW-max", "THL-min", "THL-max"]
  val [thw-min, thw-max, thl-min, thl-max] = 
    if contains?(["SOIC", "SOP", "SON", "PSON"], pkg) :
      if all?(key?{fields, _}, therm-fields) :
        map({fields[_]}, therm-fields) as ?
      else :
        [0.0, 0.0, 0.0, 0.0]
    else :
      [0.0, 0.0, 0.0, 0.0]

; assign optional values for geometry tolerances
  val tol-fields = ["L-tol", "W-tol", "T1-tol", "TW1-tol", "E-tol"]
  val [l-tol, w-tol, t1-tol, tw1-tol, e-tol] = 
    if all?(key?{fields, _}, tol-fields) :
      map({fields[_]}, tol-fields) as ?
    else :
      [(l-max - l-min), (w-max - w-min), (t1-max - t1-min), 
       (tw1-max - tw1-min), (e-max - e-min)]
  val tw2-tol =
    if key?(fields, "TW2-tol") :
      fields["TW2-tol"]
    else :
      tw2-max - tw2-min
  val s-tol = 
    if key?(fields, "S-tol") :
      fields["S-tol"]
    else :
      sqrt(pow(e-tol, 2.0) + (2.0 * pow(t1-tol, 2.0)))
  val [s-min, s-max] =
    if key?(fields, "S-min") and key?(fields, "S-max") :
      [fields["S-min"], fields["S-max"]]
    else :
      [(e-min - (2.0 * t1-max)), (e-min - (2.0 * t1-max)) + s-tol]
   
; assign optional values for fillets and courtyard excess  
  val fillet-fields = ["JT-min", "JH-min", "JS-min", "Courtyard-excess"]
  val [jt-min, jh-min, js-min, courtyard-excess] = 
    if all?(key?{fields, _}, fillet-fields) : 
      map({fields[_]}, fillet-fields) as ?
    else :
      if pkg == "SOJ" :
        soj-plcc-fillet-values(density) 
      else if pkg == "SON" :
        son-qfn-fillet-values(density)
      else if pkg == "PSON" :
        pson-pqfn-fillet-values(density)
      else if pkg == "CHIP-ARRAY" :
        chip-array-fillet-values(density, pitch)
      else :
        sop-qfp-fillet-values(pitch, density) 

; assign optional values for fab and placement tolerances
  val [fab-tol, placement-tol] = switch([key?(fields, "Fab-tol"),
                                         key?(fields, "Placement-tol")]) :
    [true, true] : [fields["Fab-tol"], fields["Placement-tol"]]
    else : [0.1, 0.15]

; assign optional values for paste fill
  val fill-fields = ["X-paste", "Y-paste", "N-fill-vert", "N-fill-hor", 
                     "Fill-gap"]
  val [x-paste, y-paste, n-fill-vert, n-fill-hor, fill-gap] =
    if contains?(["SON"], pkg) :
      if all?(key?{fields, _}, fill-fields) :
        map({fields[_]}, fill-fields) as ?
      else : 
        ;TODO Figure out default calculations
        [0.0, 0.0, 0, 0, 0.0]
    else :
      [0.0, 0.0, 0, 0, 0.0]

; calculate and assign geometry values
  val z-max = calc-pad-size(e-min, jt-min, e-tol, fab-tol, placement-tol, 
                            false)
  val g-min = calc-pad-size(s-max, jh-min, s-tol, fab-tol, placement-tol, 
                            true)
  val x1-max = calc-pad-size(tw1-min, js-min, tw1-tol, fab-tol, 
                             placement-tol, false)
  val x2-max = calc-pad-size(tw2-min, js-min, tw2-tol, fab-tol,
                             placement-tol, false)
  val geometry-fields = ["X1", "X2", "Y1", "Center"]
  val [x1, x2, y1, center] =
    if all?(key?{fields, _}, geometry-fields) :
      map({fields[_]}, geometry-fields) as ?
    else :
      [x1-max, x2-max, (z-max - g-min) / 2.0, (z-max + g-min) / 2.0]
  ;TODO consider including fillets and tolerances for thermal 
  val [thl, thw] = [thl-max, thw-max] 

; assign values for width of silkscreen courtyard and assembly lines
  val line-width-fields = ["Sl-W", "Cl-W", "Al-W"]
  val [sl-W, cl-W, al-W] = 
    if all?(key?{fields, _}, line-width-fields) :
      map({fields[_]}, line-width-fields) as ?
    else : [0.2, 0.5, 0.1]

; assign values for silkscreen, courtyard, and assembly dimensions
  val [r1, r2] =
    if key?(fields, "R1") and key?(fields, "R2") :
      [fields["R1"], fields["R2"]]
    else :
      [l-max, w-max]
  val [v1, v2] =
    if key?(fields, "V1") and key?(fields, "V2") :
      [fields["V1"], fields["V2"]]
    else if pkg == "PSON" :
      [l-max + (2.0 * courtyard-excess),
       w-max + (2.0 * courtyard-excess)]
    else :
      [z-max + (2.0 * courtyard-excess), 
       w-max + (2.0 * courtyard-excess)]
  val [a, b] =
    if key?(fields, "A") and key?(fields, "B") :
      [fields["A"], fields["B"]]
    else :
      [l-max, w-max]
  val [cmp-body-W, cmp-body-L] = switch([key?(fields, "Cmp-body-W"),
                                         key?(fields, "Cmp-body-L")]) :
    [true, true] : [fields["Cmp-body-W"], fields["Cmp-body-L"]]
    else : [w-max, l-max]
      
; assign name and description
  val [pkg-str, pkg-abbr] = switch(pkg) :
    "SOIC" : ["SOIC", "SOIC"]
    "SOP" : ["SOP", "SOP"]
    "SOJ" : ["SOJ", "SOJ"]
    "SON" : ["SON", "SON"]
    "PSON" : ["PSON", "PSON"]
    "CHIP-ARRAY" : ["Chip Array", "CA"]
  val [hull-str, hull-abbr] =
    if pkg == "CHIP-ARRAY" :
      switch(hull-type) :
        "flat" : ["F-", "Flat, "]
        "concave" : ["C-", "Concave, "]
        "convexE" : ["C-", "ConvexE, "]
        "convexS" : ["C-", "ConvexS, "]
    else : 
      ["", ""]
  val [pitch-str, pitch-abbr] =
    if pitch > 0.0 :
      [to-string("Pitch %_mm, " % [pitch]), 
       to-string("%_P" % [to-int(pitch * 100.0)])]
    else :
      ["", ""]
  val size-str = to-string("%_" % [to-int(e-max * 100.0)])
  val [density-str, density-abbr] = switch(density) :
    "least" : ["Least", "L"]
    "nominal" : ["Nominal", "N"]
    "most" : ["Most", "M"]
  val pins-str = to-string(pin-n)
  val name = switch(key?(fields, "Name")) :
    true : fields["Name"]
    else : to-string("%_%_%_%_-%_%_" % [pkg-abbr, hull-abbr, pitch-abbr, 
                                        size-str, pins-str, density-abbr])
  val size-l-str = to-string(l-max)
  val size-w-str = to-string(w-max)
  val thl-str = to-string(thl-max)
  val thw-str = to-string(thw-max)
  val thermal-str = 
    if thw-max > 0.0 :
      to-string("Thermal Pad %_x%_mm, " % [thl-str, thw-str])
    else :
      ""
  val description = switch(key?(fields, "Description")) :
    true : fields["Description"]
    else : to-string("%_, %_%_-Leads, Body %_x%_mm, %_%_IPC %_ Density"
                     % [pkg-str, hull-str, pins-str, size-l-str, size-w-str, 
                        pitch-str, thermal-str, density-str])
  println("Name: %_" % [name])
  println("Description: %_" % [description])

  TWO-SIDED-STRUCT(l-min, l-max, w-min, w-max, t1-min, t1-max, tw1-min, 
                   tw1-max, th1-min, th1-max, tpb1-min, tpb1-max, e-min, 
                   e-max, h, h-s, pin-n, density, pad-shape, s-min, s-max, 
                   jt-min, jh-min, js-min, l-tol, s-tol, w-tol, t1-tol, 
                   tw1-tol, e-tol, fab-tol, placement-tol, courtyard-excess,
                   x1, y1, center, sl-W, r1, r2, v1, v2, cl-W, a, b, al-W, 
                   cmp-body-W, cmp-body-L, name, description, thw-min, 
                   thw-max, thl-min, thl-max, thw, thl, pitch, x-paste, 
                   y-paste, n-fill-vert, n-fill-hor, fill-gap, hull-type,
                   tw2-min, tw2-max, tw2-tol, x2)

public defn make-four-sided-struct (fields:HashTable<String, ?>, pkg:String) :
  if not contains?(["PQFP"], pkg) :
    fatal("Component type not supported")
; assign required values
  val required = ["L-min", "L-max", "W-min", "W-max", "T1-min", "T1-max",
                  "TW1-min", "TW1-max", "H", "Pins-m", "Pins-n", "Pitch", 
                  "Density"]
  for k in required do :
    if not key?(fields, k) :
      fatal("%_ field is required." % [k])
  val [l-min, l-max, w-min, w-max, t1-min, t1-max, tw1-min, tw1-max, h,             pins-m, pins-n, pitch, density] = 
    map({fields[_]}, required) as ?
  val pin1-loc =
    if contains?(["PQFP"], pkg) :
      if key?(fields, "Pin1-loc") :
        fields["Pin1-loc"]
      else :
        fatal("Pin1-loc field required")
    else :
      "topleft"
  val h-s =
    if contains?(["PQFP"], pkg) :
      if key?(fields, "H-s") :
        fields["H-s"]
      else :
        fatal("H-s field required")
    else :
      0.0
  val pad-shape =
    if contains?(["PQFP"], pkg) :
      if key?(fields, "Pad-shape") :
        fields["Pad-shape"]
      else :
        fatal("Pad-shape field required")
    else :
      "rectangular"
  val [tpb1-min, tpb1-max] =
    if contains?(["PQFN"], pkg) :
      if key?(fields, "TPB1-min") and key?(fields, "TPB1-max") :
        [fields["TPB1-min"], fields["TPB1-max"]]
      else :
        fatal("TPB1-min and TPB1-max fields required")
    else :
      [0.0, 0.0]
  val span-fields = ["E1-min", "E1-max", "E2-min", "E2-max"]
  val [e1-min, e1-max, e2-min, e2-max] = 
    if contains?(["PQFP"], pkg) :
      if all?(key?{fields, _}, span-fields) :
        map({fields[_]}, span-fields) as ?
      else :
        fatal("E1-min, E1-max, E2-min, and E2-max fields required")
    else :
      [l-min - (2.0 * tpb1-max), l-max - (2.0 * tpb1-min),
       w-min - (2.0 * tpb1-max), w-max - (2.0 * tpb1-min)]

; input checks
  if not contains?(["least", "nominal", "most"], density) :
    fatal("Component Density Level not supported")
  if not contains?(["rounded", "rectangular"], pad-shape) :
    fatal("Pad Shape not supported")
  if not contains?(["topleft", "topcenter"], fields["Pin1-loc"]) :
    fatal("Pin 1 Location not supported")
  
; assign optional values for thermal pad
  val therm-fields = ["THW-min", "THW-max", "THL-min", "THL-max"]
  val [thw-min, thw-max, thl-min, thl-max] = 
    if contains?(["SOIC", "SOP", "SON", "PSON"], pkg) :
      if all?(key?{fields, _}, therm-fields) :
        map({fields[_]}, therm-fields) as ?
      else :
        [0.0, 0.0, 0.0, 0.0]
    else :
      [0.0, 0.0, 0.0, 0.0]

; assign optional values for geometry tolerances
  val tol-fields = ["L-tol", "W-tol", "T1-tol", "TW1-tol"]
  val [l-tol, w-tol, t1-tol, tw1-tol] = 
    if all?(key?{fields, _}, tol-fields) :
      map({fields[_]}, tol-fields) as ?
    else :
      [(l-max - l-min), (w-max - w-min), (t1-max - t1-min), 
       (tw1-max - tw1-min)]
  val [e1-tol, e2-tol] =
    if key?(fields, "E1-tol") and key?(fields, "E2-tol") :
      [fields["E1-tol"], fields["E2-tol"]]
    else :
      [e1-max - e1-min, e2-max - e2-min]
  val [s1-tol, s2-tol] =
    if key?(fields, "S1-tol") and key?(fields, "S2-tol") :
      [fields["S1-tol"], fields["S2-tol"]]
    else :
      [sqrt(pow(e1-tol, 2.0) + (2.0 * pow(t1-tol, 2.0))),
       sqrt(pow(e2-tol, 2.0) + (2.0 * pow(t1-tol, 2.0)))]
  val heel-fields = ["S1-min", "S1-max", "S2-min", "S2-max"]
  val [s1-min, s1-max, s2-min, s2-max] = 
    if all?(key?{fields, _}, heel-fields) :
      map({fields[_]}, heel-fields) as ?
    else :
      [(e1-min - (2.0 * t1-max)), (e1-min - (2.0 * t1-max)) + s1-tol,
       (e2-min - (2.0 * t1-max)), (e2-min - (2.0 * t1-max)) + s2-tol]

; assign optional values for fillets and courtyard excess  
  val fillet-fields = ["JT-min", "JH-min", "JS-min", "Courtyard-excess"]
  val [jt-min, jh-min, js-min, courtyard-excess] = 
    if all?(key?{fields, _}, fillet-fields) : 
      map({fields[_]}, fillet-fields) as ?
    else :
      if pkg == "PQFP" :
        sop-qfp-fillet-values(pitch, density)
      else :
        ;TODO this else case is not needed
        [0.0, 0.0, 0.0, 0.0]

; assign optional values for fab and placement tolerances
  val [fab-tol, placement-tol] = switch([key?(fields, "Fab-tol"),
                                         key?(fields, "Placement-tol")]) :
    [true, true] : [fields["Fab-tol"], fields["Placement-tol"]]
    else : [0.1, 0.15]
      
; calculate and assign geometry values
  val z1-max = calc-pad-size(e1-min, jt-min, e1-tol, fab-tol, placement-tol, 
                            false)
  val z2-max = calc-pad-size(e2-min, jt-min, e2-tol, fab-tol, placement-tol, 
                            false)
  val g1-min = calc-pad-size(s1-max, jh-min, s1-tol, fab-tol, placement-tol, 
                            true)
  val g2-min = calc-pad-size(s2-max, jh-min, s2-tol, fab-tol, placement-tol, 
                            true)
  val x-max = calc-pad-size(tw1-min, js-min, tw1-tol, fab-tol, 
                             placement-tol, false)
  val geometry-fields = ["X", "Y", "C1", "C2"]
  val [x, y, c1, c2] =
    if all?(key?{fields, _}, geometry-fields) :
      map({fields[_]}, geometry-fields) as ?
    else :
      [x-max, (z1-max - g1-min) / 2.0, (z1-max + g1-min) / 2.0,
       (z2-max + g2-min) / 2.0]
  ;TODO consider including fillets and tolerances for thermal 
  val [thl, thw] = [thl-max, thw-max] 

; assign values for width of silkscreen courtyard and assembly lines
  val line-width-fields = ["Sl-W", "Cl-W", "Al-W"]
  val [sl-W, cl-W, al-W] = 
    if all?(key?{fields, _}, line-width-fields) :
      map({fields[_]}, line-width-fields) as ?
    else : [0.2, 0.5, 0.1]

; assign values for silkscreen, courtyard, and assembly dimensions
  val [r1, r2] =
    if key?(fields, "R1") and key?(fields, "R2") :
      [fields["R1"], fields["R2"]]
    else :
      [l-max, w-max]
  val [v1, v2] =
    if key?(fields, "V1") and key?(fields, "V2") :
      [fields["V1"], fields["V2"]]
    else :
      [z1-max + (2.0 * courtyard-excess), 
       z2-max + (2.0 * courtyard-excess)]
  val [a, b] =
    if key?(fields, "A") and key?(fields, "B") :
      [fields["A"], fields["B"]]
    else :
      [l-max, w-max]
  val [cmp-body-W, cmp-body-L] = switch([key?(fields, "Cmp-body-W"),
                                         key?(fields, "Cmp-body-L")]) :
    [true, true] : [fields["Cmp-body-W"], fields["Cmp-body-L"]]
    else : [w-max, l-max]
      
; assign name and description
  val [pkg-str, pkg-abbr] = switch(pkg) :
    "PQFP" : ["PQFP", "PQFP"]
  val [pitch-str, pitch-abbr] =
    if pitch > 0.0 :
      [to-string("Pitch %_mm, " % [pitch]), 
       to-string("%_P" % [to-int(pitch * 100.0)])]
    else :
      ["", ""]
  val size-str = to-string("%_X%_" % [to-int(e1-max * 100.0), 
                                      to-int(e2-max * 100.0)])
  val [density-str, density-abbr] = switch(density) :
    "least" : ["Least", "L"]
    "nominal" : ["Nominal", "N"]
    "most" : ["Most", "M"]
  val pins-str = to-string(2 * (pins-m + pins-n))
  val name = switch(key?(fields, "Name")) :
    true : fields["Name"]
    else : to-string("%_%_%_-%_%_" % [pkg-abbr, pitch-abbr,size-str, 
                                        pins-str, density-abbr])
  val size-l-str = to-string(l-max)
  val size-w-str = to-string(w-max)
  val description = switch(key?(fields, "Description")) :
    true : fields["Description"]
    else : to-string("%_, %_-Leads, Body %_x%_mm, %_IPC %_ Density"
                     % [pkg-str, pins-str, size-l-str, size-w-str, 
                        pitch-str, density-str])
  println("Name: %_" % [name])
  println("Description: %_" % [description])

  FOUR-SIDED-STRUCT(l-min, l-max, w-min, w-max, t1-min, t1-max, tw1-min, 
                    tw1-max, h, pins-m, pins-n, pin1-loc, h-s, pitch, 
                    density, pad-shape, s1-min, s1-max, s2-min, s2-max,
                    e1-min, e1-max, e2-min, e2-max, jt-min, jh-min, js-min,
                    l-tol, s1-tol, s2-tol, e1-tol, e2-tol, w-tol, t1-tol,
                    tw1-tol, fab-tol, placement-tol, courtyard-excess, x, y,
                    c1, c2, sl-W, r1, r2, v1, v2, cl-W, a, b, al-W, 
                    cmp-body-W, cmp-body-L, name, description, thw-min, 
                    thw-max, thl-min, thl-max, thw, thl)

; =======================
; REQUIRED - ALL TWO PIN
; =======================
; L-min, L-max - Body Length Range
; W-min, W-max - Body Width Range
; T-min, T-max - Lead Length Range
; H            - Maximum Height
; Density      - Board Density Level - ["least", "nominal", "most"]

; =======================
; OPTIONAL - ALL TWO PIN
; =======================
; Polarity-pin     - Polarity Pin Location
; S-min, S-max     - Heel spacing
; JT-min           - Toe Fillet
; JH-min           - Heel Fillet
; JS-min           - Side Fillet
; L-tol            - Tolerance of overall width of component
; S-tol            - Tolerance inner distance heels of opposing lead rows
; W-tol            - Tolerance of width of component leads
; T-tol            - Tolerance of bandwidth of component leads
; Fab-tol          - Fabrication Tolerance Assumption
; Placement-tol    - Placement Tolerance Assumption
; Courtyard-excess - Courtyard Excess
; X                - Pad dimension X
; Y                - Pad dimension Y
; Center           - Pad spacing
; Sl-W             - Silkscreen Line Width
; R1               - Silkscreen Dimension R1
; R2               - Silkscreen Dimension R2
; V1               - Courtyard Dimension V1
; V2               - Courtyard Dimension V2
; Cl-W             - Courtyard Line Width
; A                - Assembly Information Dimension A
; B                - Assembly Information Dimension B
; Al-W             - Assembly Line Width
; Cmp-body-W       - Component Body Width
; Cmp-body-L       - Component Body Length
; Name             - Footprint Name
; Description      - Footprint Description

; =======================
; REQUIRED - CHIP
; =======================
; Type - Package Type - ["cap", "ind", "res", "dio"]

; =======================
; REQUIRED - MOLDED
; =======================
; Type           - Package Type - ["cap", "ind", "res", "dio"]
; TW-min, TW-max - Lead Width Range

; ========================
; OPTIONAL - MOLDED
; ========================
; TW-tol - Tolerance of width of molded component leads

; =======================
; REQUIRED - WIREWOUND 
; =======================
; TW-min, TW-max - Lead Width Range

; ========================
; OPTIONAL - WIREWOUND 
; ========================
; TW-tol - Tolerance of width of molded component leads

; =======================
; REQUIRED - MELF
; =======================
; Type - Package Type - ["res", "dio"]

; =======================
; REQUIRED - SODFL
; =======================
; E-min, E-max - Lead Span Range
; TW-min, TW-max - Lead Width Range

; ========================
; OPTIONAL - SODFL
; ========================
; E-tol - Tolerance of Lead Span Range
; TW-tol - Tolerance of width of molded component leads

; ========================
; REQUIRED - CAPAE
; ========================
; E-min, E-max - Lead Span Range
; TW-min, TW-max - Lead Width Range
; D-min, D-max - Diameter Range

; ========================
; OPTIONAL - CAPAE 
; ========================
; E-tol - Tolerance of Lead Span Range
; TW-tol - Tolerance of width of molded component leads
public defstruct TWO-PIN-STRUCT :
  L-min: Double|? with: (setter => set-L-min)
  L-max: Double|? with: (setter => set-L-max)
  W-min: Double|? with: (setter => set-W-min) 
  W-max: Double|? with: (setter => set-W-max)
  T-min: Double|? with: (setter => set-T-min)
  T-max: Double|? with: (setter => set-T-max)
  TW-min: Double|? with: (setter => set-TW-min)
  TW-max: Double|? with: (setter => set-TW-max)
  E-min: Double|? with: (setter => set-E-min)
  E-max: Double|? with: (setter => set-E-max)
  D-min: Double|? with: (setter => set-D-min)
  D-max: Double|? with: (setter => set-D-max)
  H: Double|? with: (setter => set-H)
  Type: String|? with: (setter => set-Type)
  Density: String|? with: (setter => set-Density)
  Polarity-pin: Int|False|? with: (setter => set-Polarity-pin)
  S-min: Double|? with: (setter => set-S-min)
  S-max: Double|? with: (setter => set-S-max)
  JT-min: Double|? with: (setter => set-JT-min)
  JH-min: Double|? with: (setter => set-JH-min)
  JS-min: Double|? with: (setter => set-JS-min)
  L-tol: Double|? with: (setter => set-L-tol)
  S-tol: Double|? with: (setter => set-S-tol)
  W-tol: Double|? with: (setter => set-W-tol)
  T-tol: Double|? with: (setter => set-T-tol)
  TW-tol: Double|? with: (setter => set-TW-tol)
  E-tol: Double|? with: (setter => set-E-tol)
  Fab-tol: Double|? with: (setter => set-Fab-tol)
  Placement-tol: Double|? with: (setter => set-Placement-tol)
  Courtyard-excess: Double|? with: (setter => set-Courtyard-excess)
  X: Double|? with: (setter => set-X)
  Y: Double|? with: (setter => set-Y)
  Center: Double|? with: (setter => set-Center)
  Sl-W: Double|? with: (setter => set-Sl-W)
  R1: Double|? with: (setter => set-R1)
  R2: Double|? with: (setter => set-R2)
  V1: Double|? with: (setter => set-V1)
  V2: Double|? with: (setter => set-V2)
  Cl-W: Double|? with: (setter => set-Cl-W)
  A: Double|? with: (setter => set-A)
  B: Double|? with: (setter => set-B)
  Al-W: Double|? with: (setter => set-Al-W)
  Cmp-body-W: Double|? with: (setter => set-Cmp-body-W)
  Cmp-body-L: Double|? with: (setter => set-Cmp-body-L)
  Name: String|? with: (setter => set-Name)
  Description: String|? with: (setter => set-Description)

; =====================
; REQUIRED - ALL DFN
; =====================
; L-min, L-max     - Body Length Range
; W-min, W-max     - Body Width Range
; T1-min, T1-max   - Lead Length Range
; TW1-min, TW1-max - Lead Width Range
; H                - Maximum Height
; H-s              - Minimum Standoff Height
; Type             - Package Type (leads) - [2, 3, 4]
; Density          - Board Density Level - ["least", "nominal", "most"]
; S1               - Horizontal Pitch
; S1-o             - Horizontal offset Pitch from center

; =====================
; OPTIONAL - ALL DFN
; =====================
; JP-min           - Minimum Periphery Fillet
; L-tol            - Tolerance of overall width of component
; W-tol            - Tolerance of width of component leads
; T1-tol            - Tolerance of bandwidth of component leads
; TW1-tol            - Tolerance of bandwidth of component leads
; Fab-tol          - Fabrication Tolerance Assumption
; Placement-tol    - Placement Tolerance Assumption
; Courtyard-excess - Courtyard Excess
; X1               - Pad Dimension X1
; Y1               - Pad Dimension Y1
; C1               - Horizontal Pad Spacing 
; C1-o             - Horizontal Pad Offset from center 
; Sl-W             - Silkscreen Line Width
; R1               - Silkscreen Dimension R1
; R2               - Silkscreen Dimension R2
; V1               - Courtyard Dimension V1
; V2               - Courtyard Dimension V2
; Cl-W             - Courtyard Line Width
; A                - Assembly Information Dimension A
; B                - Assembly Information Dimension B
; Al-W             - Assembly Line Width
; Cmp-body-W       - Component Body Width
; Cmp-body-L       - Component Body Length
; Name             - Footprint Name
; Description      - Footprint Description

; =====================
; REQUIRED - 3 LEAD DFN
; =====================
; S2               - Vertical Pitch
; T2-min, T2-max   - Lead Length Range
; TW2-min, TW2-max - Lead Width Range

; =====================
; OPTIONAL - 3 LEAD DFN
; =====================
; C2               - Vertical Pad Spacing 
; X2               - Pad Dimension X2
; Y2               - Pad Dimension Y2
; T2-tol           - Tolerance of bandwidth of component leads
; TW2-tol          - Tolerance of bandwidth of component leads

; =====================
; REQUIRED - 4 LEAD DFN
; =====================
; S2               - Vertical Pitch

; =====================
; OPTIONAL - 4 LEAD DFN
; =====================
; C2               - Vertical Pad Spacing 
public defstruct DFN-STRUCT :
  L-min: Double|? with: (setter => set-L-min)
  L-max: Double|? with: (setter => set-L-max)
  W-min: Double|? with: (setter => set-W-min) 
  W-max: Double|? with: (setter => set-W-max)
  T1-min: Double|? with: (setter => set-T1-min)
  T1-max: Double|? with: (setter => set-T1-max)
  TW1-min: Double|? with: (setter => set-TW1-min)
  TW1-max: Double|? with: (setter => set-TW1-max)
  T2-min: Double|? with: (setter => set-T2-min)
  T2-max: Double|? with: (setter => set-T2-max)
  TW2-min: Double|? with: (setter => set-TW2-min)
  TW2-max: Double|? with: (setter => set-TW2-max)
  H: Double|? with: (setter => set-H)
  H-s: Double|? with: (setter => set-H-s)
  Type: Int|? with: (setter => set-Type)
  Density: String|? with: (setter => set-Density)
  S1: Double|? with: (setter => set-S1)
  S1-o: Double|? with: (setter => set-S1-o)
  S2: Double|? with: (setter => set-S2)
  JP-min: Double|? with: (setter => set-JP-min)
  L-tol: Double|? with: (setter => set-L-tol)
  W-tol: Double|? with: (setter => set-W-tol)
  T1-tol: Double|? with: (setter => set-T1-tol)
  TW1-tol: Double|? with: (setter => set-TW1-tol)
  T2-tol: Double|? with: (setter => set-T2-tol)
  TW2-tol: Double|? with: (setter => set-TW2-tol)
  Fab-tol: Double|? with: (setter => set-Fab-tol)
  Placement-tol: Double|? with: (setter => set-Placement-tol)
  Courtyard-excess: Double|? with: (setter => set-Courtyard-excess)
  X1: Double|? with: (setter => set-X1)
  X2: Double|? with: (setter => set-X2)
  Y1: Double|? with: (setter => set-Y1)
  Y2: Double|? with: (setter => set-Y2)
  C1: Double|? with: (setter => set-C1)
  C1-o: Double|? with: (setter => set-C1-o)
  C2: Double|? with: (setter => set-C2)
  Sl-W: Double|? with: (setter => set-Sl-W)
  R1: Double|? with: (setter => set-R1)
  R2: Double|? with: (setter => set-R2)
  V1: Double|? with: (setter => set-V1)
  V2: Double|? with: (setter => set-V2)
  Cl-W: Double|? with: (setter => set-Cl-W)
  A: Double|? with: (setter => set-A)
  B: Double|? with: (setter => set-B)
  Al-W: Double|? with: (setter => set-Al-W)
  Cmp-body-W: Double|? with: (setter => set-Cmp-body-W)
  Cmp-body-L: Double|? with: (setter => set-Cmp-body-L)
  Name: String|? with: (setter => set-Name)
  Description: String|? with: (setter => set-Description)

; ========================
; REQUIRED - ALL TWO-SIDED
; ========================
; L-min, L-max     - Body Length Range
; W-min, W-max     - Body Width Range
; T1-min, T1-max   - Lead Length Range
; TW1-min, TW1-max - Lead Width Range
; H                - Maximum Height
; Pin-n            - Number of Pins 
; Density          - Board Density Level - ["least", "nominal", "most"]

; ========================
; OPTIONAL - ALL TWO-SIDED
; ========================
; S-min, S-max     - Heel Spacing
; JT-min           - Toe Fillet
; JH-min           - Heel Fillet
; JS-min           - Side Fillet
; L-tol            - Tolerance of overall width of component
; S-tol            - Tolerance inner distance heels of opposing lead rows
; W-tol            - Tolerance of width of component leads
; T1-tol           - Tolerance of Lead Length of component leads
; TW1-tol          - Tolerance of Lead Width of component leads 
; E-tol            - Tolerance of Lead Span 
; Fab-tol          - Fabrication Tolerance Assumption
; Placement-tol    - Placement Tolerance Assumption
; Courtyard-excess - Courtyard Excess
; X1               - Pad dimension X1
; Y1               - Pad dimension Y1
; Center           - Pad spacing
; Sl-W             - Silkscreen Line Width
; R1               - Silkscreen Dimension R1
; R2               - Silkscreen Dimension R2
; V1               - Courtyard Dimension V1
; V2               - Courtyard Dimension V2
; Cl-W             - Courtyard Line Width
; A                - Assembly Information Dimension A
; B                - Assembly Information Dimension B
; Al-W             - Assembly Line Width
; Cmp-body-W       - Component Body Width
; Cmp-body-L       - Component Body Length
; Name             - Footprint Name
; Description      - Footprint Description

; ========================
; REQUIRED - SOIC 
; ========================
; E-min, E-max     - Lead Span Range
; H-s              - Minimum Standoff Height
; Pad-shape        - Pad Shape - ["rounded", "rectangular"]

; ========================
; OPTIONAL - SOIC 
; ========================
; THW-min, THW-max - Thermal Pad Width Range
; THL-min, THL-max - Thermal Pad Length Range
; THW              - Thermal Pad Width
; THL              - Thermal Pad Length

; ========================
; REQUIRED - SOP 
; ========================
; Pitch            - Pitch between pads
; E-min, E-max     - Lead Span Range
; H-s              - Minimum Standoff Height
; Pad-shape        - Pad Shape - ["rounded", "rectangular"]

; ========================
; OPTIONAL - SOP 
; ========================
; THW-min, THW-max - Thermal Pad Width Range
; THL-min, THL-max - Thermal Pad Length Range
; THW              - Thermal Pad Width
; THL              - Thermal Pad Length

; ========================
; REQUIRED - SOJ 
; ========================
; Pitch            - Pitch between pads
; E-min, E-max     - Lead Span Range
; H-s              - Minimum Standoff Height
; Pad-shape        - Pad Shape - ["rounded", "rectangular"]

; ========================
; REQUIRED - SON 
; ========================
; Pitch            - Pitch between pads
; H-s              - Minimum Standoff Height
; TH1-min, TH1-max - Lead Height Range

; ========================
; OPTIONAL - SON 
; ========================
; THW-min, THW-max - Thermal Pad Width Range
; THL-min, THL-max - Thermal Pad Length Range
; X-paste          - Paste fill dimension X 
; Y-paste          - Paste fill dimension Y 
; N-fill-vert      - Fill count vertical 
; N-fill-hor       - Fill count horizontal 
; Fill-gap         - Fill gap

; ========================
; REQUIRED - PSON 
; ========================
; Pitch              - Pitch between pads
; H-s                - Minimum Standoff Height
; TPB1-min, TPB1-max - Lead Pull Back Range

; ========================
; OPTIONAL - PSON 
; ========================
; THW-min, THW-max - Thermal Pad Width Range
; THL-min, THL-max - Thermal Pad Length Range
; X-paste          - Paste fill dimension X 
; Y-paste          - Paste fill dimension Y 
; N-fill-vert      - Fill count vertical 
; N-fill-hor       - Fill count horizontal 
; Fill-gap         - Fill gap

; ===========================
; REQUIRED - CHIP-ARRAY - ALL 
; ===========================
; Hull-type      - Hull side type - ["flat", "concave", "convexE", "convexS"]
; Pad-shape        - Pad Shape - ["rounded", "rectangular"]

; ===============================
; REQUIRED - CHIP-ARRAY - CONVEXS 
; ===============================
; TW2-min, TW2-max - Lead Width Range

; ===========================
; OPTIONAL - CHIP-ARRAY - ALL
; ===========================
; X2               - Pad dimension X2
; TW2-tol          - Tolerance of Lead Width of component leads 
public defstruct TWO-SIDED-STRUCT :
  L-min: Double|? with: (setter => set-L-min)
  L-max: Double|? with: (setter => set-L-max)
  W-min: Double|? with: (setter => set-W-min) 
  W-max: Double|? with: (setter => set-W-max)
  T1-min: Double|? with: (setter => set-T1-min)
  T1-max: Double|? with: (setter => set-T1-max)
  TW1-min: Double|? with: (setter => set-TW1-min)
  TW1-max: Double|? with: (setter => set-TW1-max)
  TH1-min: Double|? with: (setter => set-TH1-min)
  TH1-max: Double|? with: (setter => set-TH1-max)
  TPB1-min: Double|? with: (setter => set-TPB1-min)
  TPB1-max: Double|? with: (setter => set-TPB1-max)
  E-min: Double|? with: (setter => set-E-min)
  E-max: Double|? with: (setter => set-E-max)
  H: Double|? with: (setter => set-H)
  H-s: Double|? with: (setter => set-H-s)
  Pin-n: Int|? with: (setter => set-Pin-n)
  Density: String|? with: (setter => set-Density)
  Pad-shape: String|? with: (setter => set-Pad-shape)
  S-min: Double|? with: (setter => set-S-min)
  S-max: Double|? with: (setter => set-S-max)
  JT-min: Double|? with: (setter => set-JT-min)
  JH-min: Double|? with: (setter => set-JH-min)
  JS-min: Double|? with: (setter => set-JS-min)
  L-tol: Double|? with: (setter => set-L-tol)
  S-tol: Double|? with: (setter => set-S-tol)
  W-tol: Double|? with: (setter => set-W-tol)
  T1-tol: Double|? with: (setter => set-T1-tol)
  TW1-tol: Double|? with: (setter => set-TW1-tol)
  E-tol: Double|? with: (setter => set-E-tol)
  Fab-tol: Double|? with: (setter => set-Fab-tol)
  Placement-tol: Double|? with: (setter => set-Placement-tol)
  Courtyard-excess: Double|? with: (setter => set-Courtyard-excess)
  X1: Double|? with: (setter => set-X1)
  Y1: Double|? with: (setter => set-Y1)
  Center: Double|? with: (setter => set-Center)
  Sl-W: Double|? with: (setter => set-Sl-W)
  R1: Double|? with: (setter => set-R1)
  R2: Double|? with: (setter => set-R2)
  V1: Double|? with: (setter => set-V1)
  V2: Double|? with: (setter => set-V2)
  Cl-W: Double|? with: (setter => set-Cl-W)
  A: Double|? with: (setter => set-A)
  B: Double|? with: (setter => set-B)
  Al-W: Double|? with: (setter => set-Al-W)
  Cmp-body-W: Double|? with: (setter => set-Cmp-body-W)
  Cmp-body-L: Double|? with: (setter => set-Cmp-body-L)
  Name: String|? with: (setter => set-Name)
  Description: String|? with: (setter => set-Description)
  THW-min: Double|? with: (setter => set-THW-min)
  THW-max: Double|? with: (setter => set-THW-max)
  THL-min: Double|? with: (setter => set-THL-min)
  THL-max: Double|? with: (setter => set-THL-max)
  THW: Double|? with: (setter => set-THW)
  THL: Double|? with: (setter => set-THL)
  Pitch: Double|? with: (setter => set-Pitch)
  X-paste: Double|? with: (setter => set-X-paste)
  Y-paste: Double|? with: (setter => set-Y-paste)
  N-fill-vert: Int|? with: (setter => set-N-fill-vert)
  N-fill-hor: Int|? with: (setter => set-N-fill-hor)
  Fill-gap: Double|? with: (setter => set-Fill-gap)
  Hull-type: String|? with: (setter => set-Hull-type)
  TW2-min: Double|? with: (setter => set-TW2-min)
  TW2-max: Double|? with: (setter => set-TW2-max)
  TW2-tol: Double|? with: (setter => set-TW2-tol)
  X2: Double|? with: (setter => set-X2)

; =========================
; REQUIRED - ALL FOUR-SIDED
; =========================
; L-min, L-max     - Body Length Range
; W-min, W-max     - Body Width Range
; T1-min, T1-max   - Lead Length Range
; TW1-min, TW1-max - Lead Width Range
; H                - Maximum Height
; Pins-m            - Number of Horizontal Pins
; Pins-n            - Number of Vertical Pins 
; Pitch            - Pitch between pads
; Density          - Board Density Level - ["least", "nominal", "most"]

; =========================
; OPTIONAL - ALL FOUR-SIDED
; =========================
; S1-min, S1-max - Horizontal Heel spacing
; S2-min, S2-max - Vertical Heel spacing 
; JT-min           - Toe Fillet
; JH-min           - Heel Fillet
; JS-min           - Side Fillet
; L-tol            - Tolerance of overall width of component, inc. leads
; S1-tol          - Tolerance inner distance heels of opposing lead rows
; S2-tol          - Tolerance inner distance heels of opposing lead rows
; W-tol            - Tolerance of width of component leads
; T1-tol           - Tolerance of Lead Length 
; TW1-tol          - Tolerance of Lead Width 
; Fab-tol          - Fabrication Tolerance Assumption
; Placement-tol    - Placement Tolerance Assumption
; Courtyard-excess - Courtyard Excess
; X                - Pad dimension X
; Y                - Pad dimension Y
; C1               - Horizontal Pad spacing
; C2               - Vertical Pad spacing
; Sl-W             - Silkscreen Line Width
; R1               - Silkscreen Dimension R1
; R2               - Silkscreen Dimension R2
; V1               - Courtyard Dimension V1
; V2               - Courtyard Dimension V2
; Cl-W             - Courtyard Line Width
; A                - Assembly Information Dimension A
; B                - Assembly Information Dimension B
; Al-W             - Assembly Line Width
; Cmp-body-W       - Component Body Width
; Cmp-body-L       - Component Body Length
; Name             - Footprint Name
; Description      - Footprint Description

; =========================
; REQUIRED - PQFP 
; =========================
; Pin1-loc         - Pin 1 Location - ["topleft", "topcenter"]
; H-s              - Minimum Standoff Height
; E1-min, E1-max   - Horizontal Lead Span Range
; E2-min, E2-max   - Vertical Lead Span Range
; Pad-shape        - Pad Shape - ["rounded", "rectangular"]

; =========================
; OPTIONAL - PQFP 
; =========================
; E1-tol           - Tolerance of Horizontal Lead Span 
; E2-tol           - Tolerance of Vertical Lead Span 
; THW-min, THW-max - Thermal Pad Width Range
; THL-min, THL-max - Thermal Pad Length Range
; THW              - Thermal Pad Width
; THL              - Thermal Pad Length
public defstruct FOUR-SIDED-STRUCT :
  L-min: Double|? with: (setter => set-L-min)
  L-max: Double|? with: (setter => set-L-max)
  W-min: Double|? with: (setter => set-W-min) 
  W-max: Double|? with: (setter => set-W-max)
  T1-min: Double|? with: (setter => set-T1-min)
  T1-max: Double|? with: (setter => set-T1-max)
  TW1-min: Double|? with: (setter => set-TW1-min)
  TW1-max: Double|? with: (setter => set-TW1-max)
  H: Double|? with: (setter => set-H)
  Pins-m: Int|? with: (setter => set-Pin-m)
  Pins-n: Int|? with: (setter => set-Pin-n)
  Pin1-loc: Int|? with: (setter => set-Pin1-loc)
  H-s: Double|? with: (setter => set-H-s)
  Pitch: Double|? with: (setter => set-Pitch)
  Density: String|? with: (setter => set-Density)
  Pad-shape: String|? with: (setter => set-Pad-shape)
  S1-min: Double|? with: (setter => set-SE1-min)
  S1-max: Double|? with: (setter => set-SE1-max)
  S2-min: Double|? with: (setter => set-SE2-min)
  S2-max: Double|? with: (setter => set-SE2-max)
  E1-min: Double|? with: (setter => set-E1-min)
  E1-max: Double|? with: (setter => set-E1-max)
  E2-min: Double|? with: (setter => set-E2-min)
  E2-max: Double|? with: (setter => set-E2-max)
  JT-min: Double|? with: (setter => set-JT-min)
  JH-min: Double|? with: (setter => set-JH-min)
  JS-min: Double|? with: (setter => set-JS-min)
  L-tol: Double|? with: (setter => set-L-tol)
  S1-tol: Double|? with: (setter => set-SE1-tol)
  S2-tol: Double|? with: (setter => set-SE2-tol)
  E1-tol: Double|? with: (setter => set-E1-tol)
  E2-tol: Double|? with: (setter => set-E2-tol)
  W-tol: Double|? with: (setter => set-W-tol)
  T1-tol: Double|? with: (setter => set-T1-tol)
  TW1-tol: Double|? with: (setter => set-TW1-tol)
  Fab-tol: Double|? with: (setter => set-Fab-tol)
  Placement-tol: Double|? with: (setter => set-Placement-tol)
  Courtyard-excess: Double|? with: (setter => set-Courtyard-excess)
  X: Double|? with: (setter => set-X)
  Y: Double|? with: (setter => set-Y)
  C1: Double|? with: (setter => set-C1)
  C2: Double|? with: (setter => set-C2)
  Sl-W: Double|? with: (setter => set-Sl-W)
  R1: Double|? with: (setter => set-R1)
  R2: Double|? with: (setter => set-R2)
  V1: Double|? with: (setter => set-V1)
  V2: Double|? with: (setter => set-V2)
  Cl-W: Double|? with: (setter => set-Cl-W)
  A: Double|? with: (setter => set-A)
  B: Double|? with: (setter => set-B)
  Al-W: Double|? with: (setter => set-Al-W)
  Cmp-body-W: Double|? with: (setter => set-Cmp-body-W)
  Cmp-body-L: Double|? with: (setter => set-Cmp-body-L)
  Name: String|? with: (setter => set-Name)
  Description: String|? with: (setter => set-Description)
  THW-min: Double|? with: (setter => set-THW-min)
  THW-max: Double|? with: (setter => set-THW-max)
  THL-min: Double|? with: (setter => set-THL-min)
  THL-max: Double|? with: (setter => set-THL-max)
  THW: Double|? with: (setter => set-THW)
  THL: Double|? with: (setter => set-THL)
