#use-added-syntax(jitx)
defpackage ocdb/land-patterns :
  import core
  import collections
  import math
  import jitx
  import jitx/fonts
  import jitx/commands with:
    prefix(pad) => def-
  import ocdb/design-vars
  import ocdb/land-protrusions
  import ocdb/tolerance

;==============================================================================
;============================== Helpers =======================================
;==============================================================================
; ====== Argument constraint Helpers ===========================================
; Ensure that a value is even and positive.
defn ensure-even-positive! (value: Int, name: String):
  if value < 2 or value % 2 == 1:
    fatal("%_ only supports a positive even number of pins." % [name])

defn ensure-divisible! (value:Int, divisor:Int, name: String):
  if divisor < 2:
    fatal("%_ must be > 2" % [value])
  if (value < divisor) or (value % 2 != 0):
    fatal("%_ must be positive and divisible by %_." % [value])

; ====== Silk screen helpers ===================================================
; Create a reference label at (0, 0)
; ====== Reference Label Helpers ===============================================
; Creates a reference label from pose and anchor
public defn ref-label (pose:Pose, anchor:Anchor):
  inside pcb-landpattern:
    val min-silkscreen-text-height = clearance(current-rules(), MinSilkscreenTextHeight)
    layer(Silkscreen("values", Top)) = Text(">REF", min-silkscreen-text-height, anchor, pose)

; Creates a reference label at a fixed pose
public defn ref-label (pose:Pose):
  ref-label(pose, C)

; DEPRECATED: prefer ref-label(loc(x, y))
; Creates a reference label at an x,y position and anchor
public defn ref-label (x:Double, y:Double, anchor:Anchor):
  ref-label(loc(x, y), anchor)

; DEPRECATED: prefer ref-label(loc(x, y))
; Creates a reference label at an x,y position with default anchor
public defn ref-label (x:Double, y:Double) :
  ref-label(x,y,C)

; Create a default reference label
public defn ref-label () :
  ref-label(loc(0.0, 0.0))

; Helper function to convert an anchor into a point.
defn normalize-to-point (anchor:Anchor) -> Point:
  val [v, h] = components(anchor)
  val dx = match(h):
    (hr:W) :  1.0
    (hr:C) :  0.0
    (hr:E) : -1.0
  val dy = match(v) :
    (vt:S) : 1.0
    (vt:C) : 0.0
    (vt:N) : 1.0
  Point(dx, dy)

; TODO move to internals
defn times (p:Point, d:Dims) -> Point:
  Point(x(p) * x(d), y(p) * y(d))

; Helper function to convert an x/y width to length and width (by convention: longer side 
; is on x axis and shorter side is on y)
defn normalize-rotation (width:Double, height:Double) -> [Double, Double, Double]:
  val rot = 90.0 when height > width else 0.0
  [max(width, height), min(width, height), rot]

; Normalize the position of a shape given an anchor and rotation.
defn normalize-loc (s:Shape, anchor:Anchor, rot:Double):
  val pose = Pose((0.5 * normalize-to-point(anchor)) * dims(s), rot, false)
  pose * s 

; Create a rectangle with normalized rotation and position.
defn rectangle (anchor:Anchor, width:Double, height:Double):
  val [length, width_, rot] = normalize-rotation(width, height)
  normalize-loc(Rectangle(width, height), anchor,rot)

; Create a capsule with normalized rotation and position.
defn capsule (anchor:Anchor, width:Double, height:Double):
  val [length, width_, rot] = normalize-rotation(width, height)
  normalize-loc(Capsule(length, width_), anchor, rot)

; Create a rounded rectangle with normalized rotation and position.
defn round-rect (anchor:Anchor, width:Double, height:Double, r:Double):
  val [length, width_, rot] = normalize-rotation(width, height)
  normalize-loc(RoundedRectangle(length, width_ r), anchor, rot)
  
; Create a chamfered rectangle with normalized rotation and position.
defn chamfered (anchor:Anchor, width:Double, height:Double, r:Double):
  val [length, width_, rot] = normalize-rotation(width, height)
  normalize-loc(ChamferedRectangle(length, width_, r), anchor, rot)

;==============================================================================
;=========================== Geometric Helpers ================================
;==============================================================================
defn shift-locs (x:Double, y:Double, s:Seqable<Pose>):
  seq({loc(x, y) * _}, s)

defn max-distance (p1:Point, p2:Point) -> Point:
  defn radius (p:Point):
    sqrt(x(p) * x(p) + y(p) * y(p))
  if radius(p1) > radius(p2):
    p1
  else:
    p2

; ====== Land pattern utilities ===============================================
; Create a rectangle out of lines
public defn LineRectangle (w:Double, h:Double, xc:Double, yc:Double, line-w:Double) :
  val w2 = w * 0.5
  val h2 = h * 0.5
  Line(line-w, [
    Point(xc - w2, yc - h2)
    Point(xc + w2, yc - h2)
    Point(xc + w2, yc + h2)
    Point(xc - w2, yc + h2)
    Point(xc - w2, yc - h2)])

; Create a rectangle with width, height, center x/y and default line width
public defn LineRectangle (w:Double, h:Double, xc:Double, yc:Double) :
  LineRectangle(w, h, xc, yc, clearance(current-rules(), MinSilkscreenWidth))

; Create a rectangle with width and height and default x/y position
public defn LineRectangle (w:Double, h:Double) :
  LineRectangle(w, h, 0.0, 0.0)

; Create a rectangle from dims structure
public defn LineRectangle (d:Dims): 
  LineRectangle(x(d), y(d))

; Create a rectangle around another shape
public defn outline-bounding-box (s:Shape):
  LineRectangle(dims(s))

; Create a "+" symbol with a fixed length at a center point
public defn PlusSymbol (center:Point, l:Double) -> Shape:
  val min-width = clearance(current-rules(), MinSilkscreenWidth)
  loc(x(center), y(center)) * 
    Union([Line(min-width, [Point(-0.5 * l, 0.0), Point(0.5 * l, 0.0)])
           Line(min-width, [Point(0.0, -0.5 * l), Point(0.0, 0.5 * l)])])

; Create a 1mm x 1mm plus symbol at Point(x, y)
public defn PlusSymbol (x:Double, y:Double) -> Shape:
  PlusSymbol(Point(x, y), 1.0)

;==============================================================================
;================================= Pads =======================================
;==============================================================================
; Apply a shape to the soldermask layer of a pcb-pad. 
public defn apply-soldermask (mask-shape:Shape):
  inside pcb-pad:
    layer(SolderMask(Top)) = mask-shape
    if pad-type(self) == TH:
      layer(SolderMask(Bottom)) = mask-shape

; Create the soldermask layers based on the pad shape, using a fixed factor.
; when expand? is true the soldermask shape is computed with expand(), else it is
; computed with offset()
public defn apply-soldermask (amount:Double):
  val mask-shape = 
    match(pad-shape(self)):
      (s:Rectangle|Circle|RoundedRectangle|Capsule|DShape|ChamferedRectangle):
        expand(s, amount)
      (s:Shape):
        ; FIXME: for other shapes we need an implementation of offset
        s

  inside pcb-landpattern:
    apply-soldermask(mask-shape)

; Apply a default soldermask layer to a pcb-pad, using the solder-mask-registration
; design rule and offset() method.
public defn apply-soldermask ():
  apply-soldermask(clearance(current-rules(), SolderMaskRegistration))

; A "solder mask defined pad" is one where the soldermask opening is smaller than 
; the pad shape. This method takes a pad as an argument and converts it into a 
; soldermask-defined version based on its soldermask layer, if it exists, or the
; pad shape if it does not.
public defn soldermask-defined (p:Pad):
  ; extract the pad data before conversion
  val mask?   = find({specifier(_) is SolderMask}, layers(p))  
  ; special case: the mask is smaller than the shape already
  if (mask? is-not False) and 
     (min-width([pad-shape(p)]) > min-width([shape $ (mask? as LayerShape)])) :
    p
  else :
    val solder-mask-registration = clearance(current-rules(), SolderMaskRegistration)
    pcb-pad SMD-p:
      name  = to-string("%_, SMD" % [name(p)])
      type  = pad-type(p)
      shape = offset(pad-shape(p), solder-mask-registration)
      apply-soldermask(pad-shape(p))
      for layer_ in filter({specifier(_) is-not SolderMask}, layers(p)) do:
        layer(specifier(layer_)) = shape(layer_)
    SMD-p

; Convert a landpattern to solder mask defined. Geoms will be ignored. 
public defn soldermask-defined (lp:LandPattern):
  pcb-landpattern SMD-l:
    name = to-string("%_, soldermask defined" % [name(lp)])
    for pad_ in pads(lp) do:
      pad (ref(pad_)): soldermask-defined(def-pad(pad_)) at pose(pad_)
    for layer_ in layers(lp) do:
      layer(specifier(layer_)) = shape(layer_)

  SMD-l

public pcb-pad smd-pad (s:Shape):
  name  = "SMD Pad"
  type  = SMD
  shape = s
  apply-soldermask()

; Create an rectangular SMD pad 
public defn smd-pad (anchor:Anchor, width:Double, height:Double):
  smd-pad(Rectangle(anchor, width, height))

; Create a rectangular SMD pad 
public defn smd-pad (d:Dims):
  smd-pad(Rectangle(d))

; Create an SMD pad with a given width and height
public defn smd-pad (width:Double, height:Double) :
  smd-pad(C, width, height)

; Create a BGA pad, with circular SMD
public defn bga-pad (diameter:Double) :
  smd-pad(Circle(diameter * 0.5))

; Create a soldermask-defined BGA pad
public pcb-pad soldermask-defined-bga-pad (
  soldermask-opening-diameter:Double ; the diameter of the soldermask opening
  overlap:Double                     ; the amount the soldermask overlaps the pad beneath
):
  val mask-shape = Circle(soldermask-opening-diameter * 0.5)
  name  = "SMD BGA Pad"
  shape = offset(mask-shape, -1. * overlap) as Circle
  type = SMD
  layer(SolderMask(Top)) = mask-shape

; Create an arbitrary testpoint pad
public pcb-pad testpoint-pad (testpoint-shape:Shape):
  name = "Test Point Pad"
  shape = testpoint-shape
  type = SMD
  layer(SolderMask(Top)) = testpoint-shape

; Create a circular test point pad
public defn testpoint-pad (diameter:Double) :
  testpoint-pad(Circle(0.5 * diameter))

public pcb-pad pth-pad (pad-shape:Shape, hole-shape:Shape):
  name = "PTH Pad"
  shape = pad-shape
  type = TH
  apply-soldermask()
  layer(Cutout()) = hole-shape

public defn pth-pad (drill-r:Double, pad-r:Double):
  pth-pad(Circle(pad-r), Circle(drill-r))

; Create a through hole circular pad
public defn pth-pad (anchor:Anchor, drill-radius:Double, pad-radius:Double) :
  pth-pad(Circle(anchor, pad-radius),  Circle(anchor, drill-radius))

; Create a through hole circular pad with drill radius and anchor
public defn pth-pad (anchor:Anchor, drill-radius:Double) :
  val solder-mask-registration = clearance(current-rules(), SolderMaskRegistration)
  pth-pad(anchor, drill-radius, drill-radius + solder-mask-registration)

public defn pth-pad (drill-radius:Double):
  pth-pad(C, drill-radius)

; Create an ovalcut pad, the shape is a Circle with a Capsule shaped hole.
public defn pth-ovalcut-pad (anchor:Anchor, drill-size:Dims, pad-radius:Double, mask-radius:Double):
  pth-pad(Circle(anchor, pad-radius), capsule(anchor, x(drill-size), y(drill-size)))
  
; Create an ocvalcut pad, the shape is a Circle with a Capsule shaped hole.
public defn pth-ovalcut-pad (anchor:Anchor, drill-width:Double, drill-height:Double, pad-radius:Double, mask-radius:Double) :
  pth-ovalcut-pad(anchor, Dims(drill-width, drill-height), pad-radius, mask-radius)

; Create an ovalcut pad with a given drill width, drill height, and mask radius.
public defn pth-ovalcut-pad (drill-w:Double, drill-h:Double, mask-r:Double) :
  pth-ovalcut-pad(C, drill-w, drill-h, mask-r, mask-r)

; Create a capsule shaped SMD pad with an anchor
public defn oval-smd-pad (anchor:Anchor, width:Double, height:Double) :
  smd-pad(capsule(anchor, width, height))  

; Create a capsule shaped SMD pad
public defn oval-smd-pad (w:Double, h:Double) :
  oval-smd-pad(C, w, h)

; Create a capsule shaped TH pad with anchor
public defn oval-pth-pad (anchor:Anchor, drill-w:Double, drill-h:Double, pad-w:Double, pad-h:Double) :
  val shape = capsule(anchor, pad-w, pad-h)
  val hole  = capsule(anchor, drill-w, drill-h)
  pth-pad(shape, hole)

; Create a capsule shaped TH pad with a circular hole
public defn oval-pth-pad (drill-r:Double, pad-w:Double, pad-h:Double) :
  oval-pth-pad(C, 2.0 * drill-r, 2.0 * drill-r, pad-w, pad-h)

; Create a capsule shaped pth pad
public defn oval-pth-pad (drill-w:Double, drill-h:Double, pad-w:Double, pad-h:Double) :
  oval-pth-pad(C, drill-w, drill-h, pad-w, pad-h)

; Create a rectangle pth pad with anchor, width, height, pad width, and pad height
public defn rect-pth-pad (anchor:Anchor, drill-w:Double, drill-h:Double, pad-w:Double, pad-h:Double):
  val shape = rectangle(anchor, pad-w, pad-h)
  val hole  = capsule(anchor, drill-w, drill-h)
  pth-pad(shape, hole)

; Create a rectangle pth pad with drill 
public defn rect-pth-pad (drill-r:Double, pad-w:Double, pad-h:Double) :
  rect-pth-pad(C, 2.0 * drill-r, 2.0 * drill-r, pad-w, pad-h)

public defn rect-pth-pad (drill-w:Double, drill-h:Double, pad-w:Double, pad-h:Double) :
  rect-pth-pad(C, drill-w, drill-h, pad-w, pad-h)

public defn round-rect-pth-pad (anchor:Anchor, drill-w:Double, drill-h:Double, pad-w:Double, pad-h:Double, pad-r:Double) :
  val shape = round-rect(anchor, pad-w, pad-h, pad-r)
  val hole  = capsule(anchor, drill-w, drill-h)
  pth-pad(shape, hole)

public defn round-rect-pth-pad (drill-r:Double, pad-w:Double, pad-h:Double, pad-r:Double) :
  round-rect-pth-pad(C, 2.0 * drill-r, 2.0 * drill-r, pad-w, pad-h, pad-r)

public defn round-rect-smd-pad (anchor:Anchor, w:Double, h:Double, r:Double) :
  smd-pad(round-rect(anchor, w, h, r))

public defn round-rect-smd-pad (w:Double, h:Double, r:Double) :
  round-rect-smd-pad(C, w, h, r)

public defn chamfered-rect-pth-pad (anchor:Anchor, drill-w:Double, drill-h:Double, pad-w:Double, pad-h:Double, pad-r:Double) :
  val shape = chamfered(anchor, pad-w, pad-h, pad-r)
  val hole  = capsule(anchor, drill-w, drill-h)
  pth-pad(shape, hole)

public defn chamfered-rect-pth-pad (drill-r:Double, pad-w:Double, pad-h:Double, pad-r:Double) :
  chamfered-rect-pth-pad(C, 2.0 * drill-r, 2.0 * drill-r, pad-w, pad-h, pad-r)

public defn chamfered-rect-pth-pad (drill-w:Double, drill-h:Double, pad-w:Double, pad-h:Double, pad-r:Double) :
  chamfered-rect-pth-pad(C, drill-w, drill-h, pad-w, pad-h, pad-r)

public defn chamfered-rect-smd-pad (anchor:Anchor, w:Double, h:Double, r:Double) :
  smd-pad(chamfered(anchor, w, h, r))

public defn chamfered-rect-smd-pad (w:Double, h:Double, r:Double):
  chamfered-rect-smd-pad(C, w, h, r)

public defn dshape-pth-pad (anchor:Anchor, drill-w:Double, drill-h:Double, pad-w:Double, pad-h:Double, pad-r:Double) : 
  val shape = DShape(anchor, pad-w, pad-h, pad-r)
  val hole  = capsule(anchor drill-w, drill-h)
  pth-pad(shape, hole)

public defn dshape-pth-pad (drill-w:Double, drill-h:Double, w:Double, h:Double, r:Double) : 
  dshape-pth-pad(C, drill-w, drill-h, w, h, r)

public defn dshape-smd-pad (anchor:Anchor, w:Double, h:Double, r:Double) :
  smd-pad(DShape(anchor, w, h, r))

public defn dshape-smd-pad (w:Double, h:Double, r:Double) : 
  dshape-smd-pad(C, w, h, r)

public defn general-round-rect-pth-pad (anchor:Anchor, drill-w:Double, drill-h:Double, pad-w:Double, pad-h:Double, pad-r:Tuple<Double>) :
  val shape = GeneralRoundedRectangle(anchor, pad-w, pad-h, pad-r)
  val hole  = capsule(anchor, drill-w, drill-h)
  pth-pad(shape, hole)
 
public defn general-round-rect-pth-pad (drill-r:Double, pad-w:Double, pad-h:Double, pad-r:Tuple<Double>) :
  general-round-rect-pth-pad(C, 2.0 * drill-r, 2.0 * drill-r, pad-w, pad-h, pad-r)

public defn general-round-rect-smd-pad (anchor:Anchor, w:Double, h:Double, r:Tuple<Double>) :
  smd-pad(GeneralRoundedRectangle(anchor, w, h, r))

public defn general-round-rect-smd-pad (w:Double, h:Double, r:Tuple<Double>) :
  general-round-rect-smd-pad(C, w, h, r)

public defn general-round-rect-pth-pad (anchor:Anchor, drill-w:Double, drill-h:Double, pad-w:Double, pad-h:Double, pad-r:Double, cm:CornerModifier) :
  val shape = GeneralRoundedRectangle(anchor, pad-w, pad-h, pad-r, cm)
  val hole  = capsule(anchor, drill-w, drill-h)
  pth-pad(shape, hole)

public defn general-round-rect-pth-pad (drill-r:Double, pad-w:Double, pad-h:Double, pad-r:Double, cm:CornerModifier) :
  general-round-rect-pth-pad(C, 2.0 * drill-r, 2.0 * drill-r, pad-w, pad-h, pad-r, cm)

public defn general-round-rect-smd-pad (anchor:Anchor, w:Double, h:Double, r:Double, cm:CornerModifier) :
  smd-pad(GeneralRoundedRectangle(anchor, w, h, r, cm))

public defn general-round-rect-smd-pad (w:Double, h:Double, r:Double, cm:CornerModifier) :
  general-round-rect-smd-pad(C, w, h, r, cm)

public defn general-chamfered-rect-pth-pad (anchor:Anchor, drill-w:Double, drill-h:Double, pad-w:Double, pad-h:Double, pad-r:Tuple<Double>) :
  val shape = GeneralChamferedRectangle(anchor, pad-w, pad-h, pad-r)
  val hole  = capsule(anchor, drill-w, drill-h)
  pth-pad(shape, hole)

public defn general-chamfered-rect-pth-pad (drill-r:Double, pad-w:Double, pad-h:Double, pad-r:Tuple<Double>) :
  general-chamfered-rect-pth-pad(C, 2.0 * drill-r, 2.0 * drill-r, pad-w, pad-h, pad-r)

public defn general-chamfered-rect-smd-pad (anchor:Anchor, w:Double, h:Double, r:Tuple<Double>) :
  smd-pad(GeneralChamferedRectangle(anchor, w, h, r))

public defn general-chamfered-rect-smd-pad (w:Double, h:Double, r:Tuple<Double>) :
  general-chamfered-rect-smd-pad(C, w, h, r)

public defn general-chamfered-rect-pth-pad (anchor:Anchor, drill-w:Double, drill-h:Double, pad-w:Double, pad-h:Double, pad-r:Double, cm:CornerModifier) :
  val shape = GeneralChamferedRectangle(anchor, pad-w, pad-h, pad-r, cm)
  val hole  = capsule(anchor, drill-w, drill-h)
  pth-pad(shape, hole)

public defn general-chamfered-rect-pth-pad (drill-r:Double, pad-w:Double, pad-h:Double, pad-r:Double, cm:CornerModifier) :
  general-chamfered-rect-pth-pad(C, 2.0 * drill-r, 2.0 * drill-r, pad-w, pad-h, pad-r, cm)

public defn general-chamfered-rect-smd-pad (anchor:Anchor, w:Double, h:Double, r:Double, cm:CornerModifier) :
  smd-pad(GeneralChamferedRectangle(anchor, w, h, r, cm))

public defn general-chamfered-rect-smd-pad (w:Double, h:Double, r:Double, cm:CornerModifier) :
  general-chamfered-rect-smd-pad(C, w, h, r, cm)

;==============================================================================
;========================= Land Patterns ======================================
;==============================================================================
; Create a non-plated hole of arbitrary shape for hole and mask
public pcb-landpattern non-plated-hole-landpattern (hole:Shape, mask:Shape):
  layer(Cutout())           = hole
  layer(SolderMask(Top))    = mask
  layer(SolderMask(Bottom)) = mask
  val d = dims(hole)
  layer(Courtyard(Top))    = Rectangle(x(d), y(d))
  layer(Courtyard(Bottom)) = Rectangle(x(d), y(d))

; Create a non-plated hole landpattern with a hole shape
public defn non-plated-hole-landpattern (hole:Shape):
  val solder-mask-registration = clearance(current-rules(), SolderMaskRegistration)
  non-plated-hole-landpattern(hole, offset(hole,  solder-mask-registration))

; Create a circular non-plated hole landpattern with given drill radius and mask radius
public defn non-plated-hole-landpattern (drill-r:Double, mask-r:Double) :
  non-plated-hole-landpattern(Circle(drill-r), Circle(mask-r))

; Create a non-plated hole landpattern with a given drill radius.
public defn non-plated-hole-landpattern (drill-r:Double) :
  non-plated-hole-landpattern(drill-r, drill-r)

;==============================================================================
;========================== Land Pattern Generators ===========================
;==============================================================================

;==============================================================================
;========================== Pose Arrangement Helpers ==========================
;==============================================================================
; PinPadMapping is a not-yet-placed pad, with assigned name, pad, and pose
public pcb-struct ocdb/land-patterns/PinPadMapping:
  pad-name:  Ref,  ; the name of the pad
  pad-shape: JITXDef, ; the corresponding pcb-pad
  pose:      Pose,    ; the pose of the pad

; A generic landpattern created from a sequence of PinPadMappings
public defn make-generic-landpattern (pads:Seqable<PinPadMapping>):
  inside pcb-landpattern:
    for p in pads do:
      pad (pad-name(p)): (pad-shape(p) as Pad) at pose(p)

; Create a generic landpattern with a uniform pad
public defn make-generic-landpattern (pad-names:Seqable<Ref>,
                                      poses:Seqable<Pose>,
                                      pad-shape:JITXDef):
  val pads = 
    for (pn in pad-names, pp in poses) seq:
      PinPadMapping(pn, pad-shape, pp) 
  make-generic-landpattern(to-tuple(pads))

; Naming for a 2-column arrangment of pins 
public defn soic-naming-convention (row:Int, column:Int, num-pins:Int) -> Ref:
  if (column < 0) or (column > 1): 
    fatal("soic naming convention supports a maximum of 2 columns")
  switch(column):
    0: IndexRef(Ref("p"), row + 1)
    1: IndexRef(Ref("p"), num-pins - row)
  
; Create a two-column landpattern
public defn make-two-column-landpattern (count: Int,    ; number of pads in the column
                                         pitch: Double, ; pitch of the column
                                         naming-convention: (Int, Int) -> Ref, ; naming convention
                                         pad-convention: (Int, Int) -> JITXDef,
                                         spacing:Double) :
  val locs = grid-locs(count, 2, spacing, pitch)
  val rcs  = 
    for row in 0 to count seq-cat:
      for col in 0 to 2 seq:
        [row, col]

  val mapping = to-tuple $ 
    for (pose in locs, rc in rcs) seq:
      val [row, col] = rc
      PinPadMapping(naming-convention(row, col), pad-convention(row, col), pose)

  make-generic-landpattern(mapping)

public defn make-grid-landpattern (num-rows:Int,
                                   num-cols:Int,
                                   row-pitch:Double,
                                   col-pitch:Double,
                                   naming-convention: (Int, Int) -> Ref,
                                   pad-convention: (Int, Int) -> JITXDef):
  make-grid-landpattern(num-rows, num-cols, row-pitch, col-pitch, naming-convention, pad-convention, fn (r, c): true)

; Create a grid landpattern
public defn make-grid-landpattern (num-rows:Int,
                                   num-cols:Int,
                                   row-pitch:Double,
                                   col-pitch:Double,
                                   naming-convention: (Int, Int) -> Ref,
                                   pad-convention: (Int, Int) -> JITXDef,
                                   ignore?: (Int, Int) -> True|False):
  val rcs = 
    for r in 0 to num-rows seq-cat:
      for c in 0 to num-cols seq:
        [r, c]
  val mapping = to-tuple $ 
    for (coord in rcs, pose in grid-locs(num-rows, num-cols, row-pitch, col-pitch)) seq?:
      val [c, r] = coord
      if not ignore?(r, c):
        One(PinPadMapping(naming-convention(r, c), pad-convention(r, c), pose))
      else:
        None()
  make-generic-landpattern(mapping)

; 2D array of pins
public defn make-pin-grid (n-pin:Int, n-row:Int, pin-pitch:Double, row-pitch:Double, pad-ref, offset-x:Double, offset-y:Double) :
  defn normalize (i:Int):
    0.5 * to-double(i - 1)
  
  inside pcb-landpattern:
    val n-col  = to-int(ceil(to-double(n-pin) / to-double(n-row)))
    val origin = loc(offset-x, offset-y) * loc(
      (normalize(n-row) * row-pitch), ; x
      (normalize(n-col) * pin-pitch)  ; y
    )

    for i in 0 to n-col do :
      for j in 0 to n-row do :
        val idx = n-row * i + j + 1
        val x = to-double(j) * row-pitch
        val y = -1.0 * to-double(i) * pin-pitch
        pad p[idx] : pad-ref at origin * loc(x, y)
    
public defn make-pin-grid (n-pin:Int, n-row:Int, pin-pitch:Double, row-pitch:Double, pad-ref:JITXDef) :
  make-pin-grid(n-pin, n-row, pin-pitch, row-pitch, pad-ref, 0.0, 0.0)

public defn make-pin-grid (n-pin:Int, n-row:Int, pin-pitch:Double, row-pitch:Double) :
  make-pin-grid(n-pin, n-row, pin-pitch, row-pitch, pth-pad(0.5), 0.0, 0.0)

public defn make-pin-grid (n-pin:Int) :
  make-pin-grid(n-pin, 1, 2.54, 2.54, pth-pad(0.5), 0.0, 0.0)

;==================================================================================
; Create a testpad
public pcb-landpattern testpad (d:Double) :
  pad tp : testpoint-pad(d) at loc(0.0,0.0)

; ====== Package Family Generators ================================================
; TODO: Unify These.
public pcb-landpattern dummy-landpattern (n:Int, courtyard:[Double,Double]):
  val r = (max(courtyard[0], courtyard[1]) - 0.2) / 2.0
  for i in 0 to n do :
    var theta = (2.0 * PI / to-double(n)) * to-double(i) + PI
    pad p[i + 1] : bga-pad(0.05) at loc(r * cos(theta), r * sin(theta))

  layer(Courtyard(Top)) = Rectangle(courtyard[0], courtyard[1])
  layer(Silkscreen("f-silk", Top)) = LineRectangle(courtyard[0], courtyard[1])
  ref-label()

; from IPC-SM-782 spec
; Z - width between outer pad edges
; G - width between inner pad edges
; X - pad height
; w, h - width and height of courtyard in mm
public defn make-two-pin-landpattern (Z:Double, G:Double, X:Double, w:Double, h:Double, courtyard?:True|False, polarized?:True|False) :
  inside pcb-landpattern :
    val Y = (Z - G) / 2.0 ; width of pad
    val C2 = (G + Y) / 2.0 ; distance between pad center and package centerline
    if polarized? :
      pad c : smd-pad(Y,X) at loc((- C2), 0.0)
      pad a : smd-pad(Y,X) at loc(C2, 0.0)
      val he = h / 2.0 + 0.25
      val we = w / 2.0 + 0.3
      layer(Silkscreen("pol", Top)) = Line(0.12, [Point(w / 2.0, (- he)) Point((- we), (- he))])
      layer(Silkscreen("pol", Top)) = Line(0.12, [Point((- we), he) Point(w / 2.0, he) ])
      layer(Silkscreen("pol", Top)) = Line(0.30, [Point((- we), (- he)) Point((- we), he)])
    else:
      pad p[1] : smd-pad(Y,X) at loc((- C2), 0.0)
      pad p[2] : smd-pad(Y,X) at loc(C2, 0.0)
    if courtyard? : 
      layer(Courtyard(Top)) = Rectangle(w, h)

public defn make-two-pin-landpattern (Z:Double, G:Double, X:Double, w:Double, h:Double):
  make-two-pin-landpattern(Z,G,X,w,h,true,false)

public pcb-landpattern two-pin-landpattern (Z:Double, G:Double, X:Double, w:Double, h:Double):
  make-two-pin-landpattern(Z,G,X,w,h,true,false)

public pcb-landpattern two-pin-polarized-landpattern (Z:Double, G:Double, X:Double, w:Double, h:Double):
  make-two-pin-landpattern(Z,G,X,w,h,true,true)

public defn make-ipc-two-pin-landpattern (part-name:String, courtyard?:True|False, polarized?:True|False):
  inside pcb-landpattern :
    val [Z, G, X, nr, nc] = switch(part-name) :
      "008004":[0.35, 0.10, 0.14, 0.35, 0.14]
      "01005": [0.56, 0.20, 0.23, 0.56, 0.23]
      "0201" : [1.12, 0.20, 0.42, 1.12, 0.42]
      "0402" : [1.53, 0.39, 0.62, 1.53, 0.62]
      "0603" : [2.55, 0.65, 1.00, 2.55, 1.00]
      "0805" : [2.90, 0.90, 2.00, 2.90, 2.00]
      "1206" : [4.05, 1.65, 1.80, 4.60, 2.30]
      "1210" : [4.40, 1.20, 2.70, 5.00, 3.00]
      "2010" : [6.20, 2.60, 2.70, 7.00, 3.00]
      "2512" : [7.35, 4.85, 3.40, 3.90, 7.90]
      "2920" : [9.70, 5.10, 5.60, 10.0, 6.00]
      else : 
        val [l w] = switch(length(part-name)):
          4 : [2 2]
          5 : [2 3]
          6 : [3 3]
        val len = (to-double(part-name[0 to l]) as Double )* 25.4 / (pow(10.0, to-double(l)))
        val width = (to-double(part-name[l to (l + w)]) as Double )* 25.4 / (pow(10.0, to-double(w)))
        val Z = len + 2.0 * (0.084 * len - 0.00543)
        val G = len * 0.465 - 0.222
        val X = width
        val nr = Z
        val nc = X
        [Z, G, X, nr, nc]
    make-two-pin-landpattern(Z, G, X, nr, nc, courtyard?, polarized?)
    external-names = ([part-name])
    ref-label()

public defn make-ipc-two-pin-landpattern (part-name:String) :
  make-ipc-two-pin-landpattern(part-name, true, false)

; last 3 are made up
;<test>
part-name: "01005" "008004" "006003" "01007" "5040"
<test>
public pcb-landpattern ipc-two-pin-landpattern (part-name:String) :
  make-ipc-two-pin-landpattern(part-name, true, false)
  ref-label()

public pcb-landpattern ipc-two-pin-landpattern (part-name:String, pol?:True|False) :
  make-ipc-two-pin-landpattern(part-name, true, pol?)
  ref-label()

;<test>
part-name: "1210"
<test>
public pcb-landpattern ipc-two-pin-pol-landpattern (part-name:String) :
  make-ipc-two-pin-landpattern(part-name, true, true)
  ref-label()

public defn make-soic127p-landpattern (n:Int, lead-span:Double) :
  ensure-even-positive!(n, "make-soic127p-landpattern")

  inside pcb-landpattern :  

    val pin-pitch = 1.27

    val x0 = (- ((lead-span / 2.0) - 0.5))
    val y0 = (to-double((n / 2) - 1) * pin-pitch) / 2.0
    val l0 = loc(x0, y0, -90.0)
    val l1 = loc((- x0), (- y0), 90.0)
    
    val pin-row = to-list(row-locs(W, n / 2, pin-pitch))

    for (i in 0 to (n / 2), l in pin-row) do :
      pad p[i + 1] : smd-pad(0.6, 1.5) at l0 * l
    
    for (i in (n / 2) to n, l in pin-row) do :
      pad p[i + 1] : smd-pad(0.6, 1.5) at l1 * l
    
    val pkg-height = to-double((n / 2) - 1) * pin-pitch + 1.1
    val c-w = lead-span + 1.5
    val c-h = pkg-height
    
    layer(Courtyard(Top)) = Rectangle(c-w, c-h)

    ; layer(Silkscreen("f-silk", Top)) = LineRectangle(c-w, c-h)
    layer(Silkscreen("pol", Top)) = Circle(x0 - 2.0, y0, 0.2)
    ref-label()

public defn make-soic127p-landpattern (n:Int) :
  make-soic127p-landpattern(n, 6.0)

;<test>
n: even positive
<test>
public pcb-landpattern soic127p-landpattern (n:Int) :
  make-soic127p-landpattern(n, 6.0)

public pcb-landpattern soic127p-landpattern (n:Int, hs:[Double, Double]) :
  make-soic127p-landpattern(n, 6.0)
  pad p[n + 1] : smd-pad(hs[0], hs[1]) at loc(0.0, 0.0)

; See SOP_JEDEC_MO-153F.pdf for reference
public defn make-sop65-landpattern (n:Int, lead-span:Double) :
  ensure-even-positive!(n, "make-sop65-landpattern")

  inside pcb-landpattern :

    val pin-pitch = 0.65

    val x0 = (- ((lead-span / 2.0) - 0.5))
    val y0 = (to-double((n / 2) - 1) * pin-pitch) / 2.0
    val l0 = loc(x0, y0, -90.0)
    val l1 = loc((- x0), (- y0), 90.0)
    
    val pin-row = to-list(row-locs(W, n / 2, pin-pitch))

    for (i in 1 through (n / 2), l in pin-row) do :
      pad p[i] : smd-pad(0.39, 1.4) at l0 * l
    
    for (i in (n / 2 + 1) through n, l in pin-row) do :
      pad p[i] : smd-pad(0.39, 1.4) at l1 * l
    
    val pkg-height = to-double((n / 2) - 1) * pin-pitch + 0.4
    
    val c-w = lead-span + 0.45
    val c-h = pkg-height
    layer(Courtyard(Top)) = Rectangle(c-w, c-h)

    name = to-string("SOP65 with %_ pins." % [n])
    layer(Silkscreen("pol", Top)) = Circle(x0 - 1.0, y0, 0.2)
    ref-label()

public pcb-landpattern sop65-landpattern (n:Int, lead-span:Double) :
  make-sop65-landpattern(n, lead-span)

;<test>
n: even positive
<test>
public pcb-landpattern sop65-landpattern (n:Int) :
  make-sop65-landpattern(n, 6.4)

public defn make-qfn-landpattern (pin-pitch:Double, lead-span:Double, n-pins:Int, pad-width:Double, pad-length:Double, corner-pads:[Pad,Pad]|False) :
  inside pcb-landpattern :
    var n = -1
    if n-pins % 4 == 0 :
      n = n-pins / 4
    else :
      fatal("make-qfn-landpattern is only for symmetric 4-sided qfns.")

    val x0 = (- (lead-span / 2.0 + 0.3))
    val y0 = (to-double(n - 1) * pin-pitch) / 2.0
    val l0 = loc(x0, y0, -90.0)
    val row-pos = to-list(row-locs(W, n, pin-pitch))

    val pin-pad = smd-pad(S, pad-width, pad-length + 0.3)

    defn place-pads (pose:Pose, i:Int, ub:Int, lb:Int) :
      match(corner-pads:[Pad,Pad]):
        if i == lb:
          pad p[i + 1] : corner-pads[0] at pose
        else if i == ub:
          pad p[i + 1] : corner-pads[1] at pose
        else:
          pad p[i + 1] : pin-pad at pose
      else:
        pad p[i + 1] : pin-pad at pose

    for (i in 0 to n, l in row-pos) do :
      place-pads(loc(x0, y0, -90.0) * l, i, 0, n - 1)
    for (i in n to (n * 2), l in row-pos) do :
      place-pads(loc((- y0), x0, 0.0) * l, i, n, n * 2 - 1)
    for (i in (n * 2) to (n * 3), l in row-pos) do :
      place-pads(loc((- x0), (- y0), 90.0) * l, i, n * 2, n * 3 - 1)
    for (i in (n * 3) to (n * 4), l in row-pos) do :
      place-pads(loc((y0), (- x0), 180.0) * l, i, n * 3, n * 4 - 1)

    layer(Courtyard(Top)) = Rectangle(lead-span, lead-span)
    layer(Silkscreen("pol",Top)) = Circle((lead-span / -2.0) - 1.0, y0, 0.2)
    ref-label()

public pcb-landpattern qfn-landpattern (pin-pitch:Double, lead-span:Double, n-pins:Int, pad-width:Double, pad-length:Double) :
  make-qfn-landpattern(pin-pitch, lead-span, n-pins, pad-width, pad-length, false)

public pcb-landpattern qfn-landpattern (pin-pitch:Double, lead-span:Double, n-pins:Int, pad-width:Double, pad-length:Double, corner-pads:[Pad,Pad]|False) :
  make-qfn-landpattern(pin-pitch, lead-span, n-pins, pad-width, pad-length, corner-pads)

public pcb-landpattern qfn-landpattern (pin-pitch:Double, lead-span:Double, n-pins:Int, pad-width:Double, pad-length:Double, hs:[Double,Double]) :
  make-qfn-landpattern(pin-pitch, lead-span, n-pins, pad-width, pad-length, false)
  pad p[n-pins + 1] : smd-pad(hs[0],hs[1]) at loc(0.0, 0.0)  

public defn make-qfp-landpattern (pin-pitch:Double, lead-span:Double, n-pins:Int, pad-width:Double, pad-length:Double) :
  inside pcb-landpattern :
    var n = -1
    
    if n-pins % 4 == 0 :
      n = n-pins / 4
    else :
      fatal("make-qfp-package is only for symmetric 4-sided qfps.")
    
    val pin-pad = smd-pad(S, pad-width, (pad-length + 0.3))
    
    val x0 = (- ((lead-span / 2.0) + 0.3))
    val y0 = (to-double(n - 1) * pin-pitch) / 2.0
    val l0 = loc(x0, y0, -90.0)
    val row-pos = to-list(row-locs(W, n, pin-pitch))

    for (i in 0 to n, l in row-pos) do :
      pad p[i + 1] : pin-pad at loc(x0, y0, -90.0) * l

    for (i in n to (n * 2), l in row-pos) do :
      pad p[i + 1] : pin-pad at loc((- y0), x0, 0.0) * l

    for (i in (n * 2) to (n * 3), l in row-pos) do :
      pad p[i + 1] : pin-pad at loc((- x0), (- y0), 90.0) * l

    for (i in (n * 3) to (n * 4), l in row-pos) do :
      pad p[i + 1] : pin-pad at loc((y0), (- x0), 180.0) * l

    
    layer(Courtyard(Top)) = Rectangle(lead-span, lead-span)
    layer(Silkscreen("pol",Top)) = Circle((lead-span / -2.0) - 1.0, y0, 0.2)

public pcb-landpattern qfp-landpattern (pin-pitch:Double, lead-span:Double, n-pins:Int, pad-width:Double, pad-length:Double) :
  make-qfp-landpattern(pin-pitch, lead-span, n-pins, pad-width, pad-length)

public defn make-dfn-landpattern (
  n-pad:Int
  pad-pitch:Double
  pad-dims:[Double,Double]
  pad-x0:Double
  body-dims:[Double,Double]
) :
  val [pad-w, pad-h] = pad-dims
  val [body-w, body-h] = body-dims

  inside pcb-landpattern :
    val pin-pad = smd-pad(pad-w, pad-h)

    val n-side = n-pad / 2
    val pad-y0 = to-double(n-side - 1) * pad-pitch / 2.0
    val l0 = loc(pad-x0, pad-y0, -90.0)
    val ln2 = loc((- pad-x0), (- pad-y0), 90.0)
    val pin-row = to-list(row-locs(W, n-side, pad-pitch))

    for (i in 0 to n-side, l in pin-row) do :
      pad p[i + 1] : pin-pad at l0 * l

    for (i in n-side to n-pad, l in pin-row) do :
      pad p[i + 1] : pin-pad at ln2 * l

    val pad-x0-abs = abs(pad-x0)
    val pad-x0-dir = pad-x0 / pad-x0-abs
    val pol-x = pad-x0-dir * (pad-x0-abs + (pad-h / 2.0) + 0.5)

    val courtyard-w = max(body-w, 2.0 * pad-x0-abs + pad-h)
    val courtyard-h = max(body-h, 2.0 * abs(pad-y0) + pad-w)

    layer(Courtyard(Top)) = Rectangle(courtyard-w, courtyard-h)
    layer(Silkscreen("f-silk",Top)) = LineRectangle(body-w, body-h)
    layer(Silkscreen("pol",Top)) = Circle(pol-x, pad-y0, 0.254)
    ref-label()

public pcb-landpattern dfn-landpattern ( n-pad:Int, pad-pitch:Double, pad-dims:[Double,Double], pad-x0:Double, body-dims:[Double,Double]) :
  make-dfn-landpattern(n-pad,pad-pitch,pad-dims,pad-x0,body-dims)

public pcb-landpattern dfn-landpattern ( n-pad:Int, pad-pitch:Double, pad-dims:[Double,Double], pad-x0:Double, body-dims:[Double,Double], hs:[Double,Double]) :
  make-dfn-landpattern(n-pad,pad-pitch,pad-dims,pad-x0,body-dims)
  pad p[n-pad + 1] : smd-pad(hs[0],hs[1]) at loc(0.0, 0.0)  

; Returns the name of a row given its index and a list of omitted
; characters.
; 
; The algorithm is a realization of this description from JEDEC JC-11:
;
; > When a package is viewed ... with the A1 corner in the upper left position, 
; > terminal rows are lettered from top to bottom starting with A and 
; > terminal columns are numbered from left to right starting with 1. 
; > ... For packages with greater than 20 rows (i.e.,  following rows W and Y),  
; > the 21st row is designated AA and subsequent rows are designated AB, AC, etc.
;
; The modification is we abstract over the omitted characters to support non-
; standard naming conventions. 
;
public defn bga-row-name (idx:Int, omitted:String) -> Ref:
  val table = to-tuple $
    for ch in "ABCDEFGHIJKLMNOPQRSTUVWXYZ" filter:
      not contains?(upper-case(omitted), ch)
  val buf = StringBuffer()
  let loop (row: Int = idx):
    if row >= length(table):
      print(buf, table[row / length(table) - 1])
      loop(row / length(table))
  print(buf, table[idx % length(table)])
  Ref(to-string(buf))

; for backwards compat
public defn red-alph-letter (r:Int):
  to-string(bga-row-name(r, "IOQSXZ"))

public defn bga-pin-name (row:Int, column:Int, omitted?:String|False) -> Ref:
  val omitted = match(omitted?):
    (_:False): "IOQSXZ"
    (s:String): s
  bga-row-name(row, omitted)[column + 1]

public defn bga-pin-name (row:Int, column:Int) -> Ref:
  bga-pin-name(row, column, false)

public defn make-bga-pkg (pitch:Double, pad-diam:Double, n-pads:[Int Int], courtyard:[Double Double], omit-pads:Tuple<Ref>|False) :
  inside pcb-landpattern :
    val pin-pad = bga-pad(pad-diam)
    val pad-names = bga-pad-names(n-pads[0], n-pads[1], false)
    defn make-pad (r:Int, c:Int) :
      val x = ((to-double(n-pads[0]) - 1.0) / -2.0 + to-double(c)) * pitch
      val y = ((to-double(n-pads[1]) - 1.0) / 2.0 - to-double(r)) * pitch
      val name = bga-pin-name(r, c)

      match(omit-pads:Tuple<Ref>):
        if not contains?(omit-pads, name) :
          pad (name) : pin-pad at loc(x,y)
      else :
          pad (name) : pin-pad at loc(x,y)

    for c in 0 to n-pads[0] do :
      for r in 0 to n-pads[1] do :
        make-pad(r,c)

    layer(Courtyard(Top)) = Rectangle(courtyard[0], courtyard[1])
    ; layer(Silkscreen("f-silk", Top)) = LineRectangle(courtyard[0], courtyard[1])
    layer(Silkscreen("pol", Top)) = Circle(-0.3 - courtyard[0] / 2.0, courtyard[1] / 2.0, 0.127)
    ref-label()

public pcb-landpattern bga-pkg (pitch:Double, pad-diam:Double, n-pads:[Int Int], courtyard:[Double Double], omit-pads:Tuple<Ref>|False) :
  make-bga-pkg(pitch, pad-diam, n-pads, courtyard, omit-pads)

public pcb-landpattern bga-pkg (pitch:Double, pad-diam:Double, n-pads:[Int Int], courtyard:[Double Double]) :
  make-bga-pkg(pitch, pad-diam, n-pads, courtyard, false)

; Generic package instantiations
; Passives

public pcb-landpattern INDC1005X55 :
  make-ipc-two-pin-landpattern("0402")
  ref-label()

public pcb-landpattern CAPT1005X55 :
  make-ipc-two-pin-landpattern("0402")
  layer(Silkscreen("pol", Top)) = PlusSymbol(-1.7, 0.0)
  ref-label()

public pcb-landpattern CAPT1608X80 :
  make-ipc-two-pin-landpattern("0603")
  layer(Silkscreen("pol", Top)) = PlusSymbol(-2.2, 0.0)
  ref-label()

public pcb-landpattern CAPT2012X125 :
  make-ipc-two-pin-landpattern("0805")
  layer(Silkscreen("pol", Top)) = PlusSymbol(-2.4, 0.0)
  ref-label()

public pcb-landpattern CAPT3216X160 :
  make-ipc-two-pin-landpattern("1206")
  layer(Silkscreen("pol", Top)) = PlusSymbol(-3.0, 0.0)
  ref-label()

public pcb-landpattern FUSC7330X390 :
  name = "FUSC7330X390"
  make-two-pin-landpattern(7.26, 2.48, 3.0, 7.5, 3.0)

public pcb-landpattern DIOM-4539X220 :
  name = "DIOM-4539X220"
  make-two-pin-landpattern(5.58, 2.15, 2.18, 5.5, 4.0)
  layer(Silkscreen("pol",Top)) = Line(0.25, [Point(3.0, -1.0), Point(3.0, 1.0)])

public pcb-landpattern d-sod-123 :
  pad c : smd-pad(0.9, 1.2) at loc(-1.65, 0.0)
  pad a : smd-pad(0.9, 1.2) at loc(1.65, 0.0)
  layer(Courtyard(Top)) = Rectangle(4.5, 2.0)
  layer(Silkscreen("pol", Top)) = Line(0.12, [Point(1.65, -1.0) Point(-2.4, -1.0)])
  layer(Silkscreen("pol", Top)) = Line(0.12, [Point(-2.4, 1.0) Point(1.65, 1.0) ])
  layer(Silkscreen("pol", Top)) = Line(0.30, [Point(-2.4, -1.0) Point(-2.4, 1.0)])
  ref-label()

; QFNs

public pcb-landpattern QFN50P715X715X80-48 :
  name = "QFN50P715X715X80-48"
  make-qfn-landpattern(0.5, 7.15, 48, 0.3, 0.5, false)
  pad p[49] : smd-pad(5.1,5.1) at loc(0.0, 0.0)

public pcb-landpattern QFN50P400X400X85-24 :
  name = "QFN50P400X400X85-24"
  make-qfn-landpattern(0.5, 4.0, 24, 0.25, 0.4, false)
  pad p[25] : smd-pad(2.5,2.5) at loc(0.0, 0.0)  

public pcb-landpattern SOT95P280X100-3N :
  
  val x0 = -0.95
  val y0 = -1.0
  pad p[1] : smd-pad(0.6, 0.7) at loc(x0,y0)
  pad p[2] : smd-pad(0.6, 0.7) at loc((- x0), y0)
  pad p[3] : smd-pad(0.6, 0.7) at loc(0.0, (- y0))

  layer(Courtyard(Top)) = Rectangle(3.3, 2.8)
  layer(Silkscreen("pol", Top)) = Circle(x0, y0 - 1.0, 0.2)
  ref-label()

public pcb-landpattern SC-70-3 :
  
  val x0 = -1.85 / 2.0
  val y0 = -1.3 / 2.0
  pad p[1] : smd-pad(0.6, 0.7) at loc(x0,y0)
  pad p[2] : smd-pad(0.6, 0.7) at loc((- x0), y0)
  pad p[3] : smd-pad(0.6, 0.7) at loc(0.0, (- y0))

  layer(Courtyard(Top)) = Rectangle(2.65, 2.35)
  ref-label()

public defn SOT23 () :
  SOT95P280X100-3N

public pcb-landpattern SOT95P280X145-5N :
  val x0 = -0.95
  val y0 = 2.7 / -2.0
  pad p[1] : smd-pad(0.6, 1.05) at loc(x0,y0)
  pad p[2] : smd-pad(0.6, 1.05) at loc(0.0, y0)
  pad p[3] : smd-pad(0.6, 1.05) at loc((- x0), y0)
  pad p[4] : smd-pad(0.6, 1.05) at loc((- x0), (- y0))
  pad p[5] : smd-pad(0.6, 1.05) at loc(x0, (- y0))

  layer(Courtyard(Top)) = Rectangle(2.7, 3.95)  
  layer(Silkscreen("pol", Top)) = Circle(x0, y0 - 1.0, 0.2)
  
  ref-label()

public pcb-landpattern SOT95P280X145-6N :
  val x0 = -0.95
  val y0 = 2.7 / -2.0
  pad p[1] : smd-pad(0.6, 1.05) at loc(x0,y0)
  pad p[2] : smd-pad(0.6, 1.05) at loc(0.0, y0)
  pad p[3] : smd-pad(0.6, 1.05) at loc((- x0), y0)
  pad p[4] : smd-pad(0.6, 1.05) at loc((- x0), (- y0))
  pad p[5] : smd-pad(0.6, 1.05) at loc(0.0, (- y0))
  pad p[6] : smd-pad(0.6, 1.05) at loc(x0, (- y0))

  layer(Silkscreen("pol", Top)) = Circle(x0, y0 - 1.0, 0.2)
  layer(Courtyard(Top)) = Rectangle(2.7, 3.95)  
  
  ref-label()


public pcb-landpattern pin-header-pkg (n-pin:Int, n-row:Int, pin-pitch:Double, row-pitch:Double) :
  make-pin-grid(n-pin, n-row, pin-pitch, row-pitch)

  val n-col = to-int(ceil(to-double(n-pin) / to-double(n-row)))

  val c-w = to-double(n-row) * row-pitch
  val c-h = to-double(n-col) * pin-pitch

  layer(Courtyard(Top)) = Rectangle(c-w, c-h)
  layer(Courtyard(Bottom)) = Rectangle(c-w, c-h)
  layer(Silkscreen("f-silk", Top)) = LineRectangle(c-w, c-h)
  
  ref-label()

public pcb-landpattern smd-testpoint-pkg (d:Double) :
  pad p : testpoint-pad(d) at loc(0.0, 0.0)
  layer(Courtyard(Top)) = Circle(d / 2.0)
  layer(Silkscreen("f-silk", Top)) = Circle(d / 2.0)
  ref-label()

; Helper struct to contain the results of the IPC formula in section 3 of 
; 7351-B
defstruct IpcResults:
  Zmax:Double,
  Gmin:Double,
  Xmin:Double,

defmethod print (o:OutputStream, i:IpcResults):
  print(o, "IpcResults(Zmax:%_, Gmin:%_, Xmin:%_" % [Zmax(i), Gmin(i), Xmin(i)])

; Helper to compute the pad size from the formula results
defn pad-size (i:IpcResults) -> Dims:
  Dims(0.5 * (Zmax(i) - Gmin(i)), Xmin(i))

; Helper function to apply a thermal pad shape, if it is provided. Assumes that the
; land pattern is centered at (0.0, 0.0).
defn make-thermal-pad (shape?:False|Shape, max-thermal-dims:Dims, num-pins:Int):
  if num-pins < 0:
    fatal("make-thermal-pad(...) failed: num-pins must positive. Called with %_" % [num-pins])
  match(shape?:Shape):
    val thermal-dims = dims(shape?)
    if x(thermal-dims) >= x(max-thermal-dims) or
       y(thermal-dims) >= y(max-thermal-dims):
      fatal("make-thermal-pad(...) failed: shape exceeds maximum thermal pad dimensions. Called with %_, while the maximum dimensions are %_." % [
        shape?, max-thermal-dims
      ])
      inside pcb-landpattern:
        pad p[num-pins + 1]: smd-pad(shape?) at loc(0.0, 0.0)

; the IPC formula
defn ipc-formula (L:Toleranced, ; the distance from edge-of-lead to edge-of-lead on the exterior of the land pattern
                  T:Toleranced, ; the nominal size of the leads, in the same dimension as L
                  W:Toleranced, ; the nominal size of the leads, in the dimension orthogonal to L
                  fillets:LeadFillets): ; looked up using lead-fillets(lead-type, density-level)
  ; compute root-mean-squared of a sequence of numbers
  val [Jt, Jh, Js, _] = to-tuple(fillets)
  val Lmax = max-value(L)
  val Lmin = min-value(L)
  val Wmin = min-value(W)
  val Tmin = min-value(T)
  val Smax = Lmax - 2.0 * Tmin
  val C_L  = tolerance-range(L)
  val C_W  = tolerance-range(W)
  val C_T  = tolerance-range(T)
  val C_S  = sqrt(C_L * C_L + C_T * C_T)
  val Zmax = Lmin + 2.0 * Jt + C_L ; the distance from edge of land to edge of land on the exterior of the land pattern
  val Gmin = Smax - 2.0 * Jh - C_S ; the distance from edge of land to edge of land on the interior of the land pattern
  val Xmin = Wmin + 2.0 * Js + C_W ; the size of the land in the dimension orthogonal to Z and G.
  IpcResults(Zmax, Gmin, Xmin)

; helper struct to contain information about how we plan 
; to layout the pads on a single side of a quad land pattern
public defn make-quad-landpattern (num-pins-west: Int,  ; the number of pins on the west face
                                   num-pins-south: Int, ; the number of pins on the south face
                                   num-pins-east: Int,  ; the number of pins on the east face
                                   num-pins-north: Int, ; the number of pins on the north face
                                   pitch-west:Double,   ; the pithc on the west face
                                   pitch-south:Double,  ; the pitch on the south face
                                   pitch-east:Double,   ; the pitch on the east face
                                   pitch-north:Double,  ; the pitch on the north face
                                   lead-span-x: Toleranced, ; the distance from pad-edge to pad-edge on the exterior of the part in the x direction
                                   lead-span-y: Toleranced, ; the distance from pad-edge to pad-edge on the exterior of the part in the y direction
                                   package-length: Toleranced,  ; the size of the package in the x direction
                                   package-width: Toleranced,  ; the size of hte package in the y direction
                                   terminal-length: Toleranced, ; the dimension of the leads in the x direction on the east/west faces
                                   terminal-width: Toleranced,  ; the dimension of the leads in the y direction on the east/west faces
                                   lead-type:  LandProtrusionType, ; the type of the leads
                                   density-level: DensityLevel,     ; the density level of the design
                                   exposed-metal-heat-feature?: Shape|False):     ; an optional thermal pad
  val lead-fillets = lead-fillets(lead-type, density-level)  
  inside pcb-landpattern: 
    ;----------------------------------------------------------
    ; compute dimensions
    val ipc-ns = ipc-formula(lead-span-x, terminal-length, terminal-width, lead-fillets)
    val ipc-ew = ipc-formula(lead-span-y, terminal-length, terminal-width, lead-fillets)
    val pad-sz-ns = transpose(pad-size(ipc-ns))
    val pad-sz-ew = pad-size(ipc-ew)

    ;----------------------------------------------------------
    ; compute pad locations 
    val x-shift = 0.5 * (Zmax(ipc-ew) - x(pad-sz-ew))
    val y-shift = 0.5 * (Zmax(ipc-ns) - y(pad-sz-ns))

    val pad-1-loc = to-tuple(grid-locs(num-pins-east, 2, 2.0 * x-shift, pitch-east))[0]
    var pin-count = 0 ; accumulator, holds the number of pins we have laid out

    defn layout-pads (dir:Dir, num-pins:Int, pitch:Double):
      val locs = switch(dir):
        Up: 
          shift-locs{0.0, y-shift, _ } $
          reverse(to-list(row-locs(num-pins, pitch)))
        Down: 
          shift-locs{0.0, (- y-shift), _ } $
          row-locs(num-pins, pitch)
        Left:  
          shift-locs{(- x-shift), 0.0, _ } $
          col-locs(num-pins, pitch)
        Right: 
          shift-locs{x-shift, 0.0, _ } $
          reverse(to-list(col-locs(num-pins, pitch)))
      
      val pad-dims = 
        if contains?([Left, Right], dir): pad-sz-ew
        else: pad-sz-ns        
      val idx = pin-count to (pin-count + num-pins)
      for (i in idx, loc in locs) do:
        pad p[i + 1]: smd-pad(pad-dims) at loc
      pin-count = pin-count + num-pins

    layout-pads(Left, num-pins-east,  pitch-east)
    layout-pads(Down, num-pins-south, pitch-south)
    layout-pads(Right,num-pins-west,  pitch-west)
    layout-pads(Up,   num-pins-north, pitch-north)
    
    ;----------------------------------------------------------
    ; Compute the courtyard
    val solder-mask-registration = clearance(current-rules(), SolderMaskRegistration)
    val part-sz = Dims(max-value(package-length), max-value(package-width))
    val lp-sz   = enlarge(Dims(Zmax(ipc-ew), Zmax(ipc-ns)), 2.0 * solder-mask-registration)
    val cy-sz   = enlarge(max(part-sz, lp-sz), courtyard-excess(lead-fillets))
    layer(Courtyard(Top)) = Rectangle(cy-sz)
  
    ;----------------------------------------------------------
    ; Place the polarity marker
    val silk-solder-mask-clearance = clearance(current-rules(), MinSilkSolderMaskSpace)
    val line-width  = clearance(current-rules(), MinSilkscreenWidth)
    val line-length = 3.0 * line-width - line-width
    val dist  = solder-mask-registration + silk-solder-mask-clearance + line-width * 0.5 + 0.01
    
    val pad-loc = center(pad-1-loc)
    val p1 = Point(
      x(pad-loc) - 0.5 * x(pad-sz-ew),
      y(pad-loc) + 0.5 * y(pad-sz-ew) + dist
    )
    val p2 = Point(
      -0.5 * x(part-sz) - line-width * 0.5,
       0.5 * y(part-sz) - line-width * 0.5,
    )
    val pol = max-distance(p1, p2)
    layer(Silkscreen("pol", Top)) = Line(line-width, [
      pol, pol + Point(line-length, 0.0)
    ])

    ;----------------------------------------------------------
    ; Place the reference label
    val min-silkscreen-text-height = clearance(current-rules(), MinSilkscreenTextHeight)
    val text-y = 0.5 * (y(cy-sz) + min-silkscreen-text-height)
    ref-label(0.0, text-y)

    make-thermal-pad(exposed-metal-heat-feature?, 
                     Dims(Gmin(ipc-ew), Gmin(ipc-ns)), 
                     num-pins-west + num-pins-south + num-pins-east + num-pins-north)
  
public defn make-quad-landpattern (num-pins-west: Int,  ; the number of pins on the west face
                                   num-pins-south: Int, ; the number of pins on the south face
                                   num-pins-east: Int,  ; the number of pins on the east face
                                   num-pins-north: Int, ; the number of pins on the north face
                                   pitch-west:Double,   ; the pithc on the west face
                                   pitch-south:Double,  ; the pitch on the south face
                                   pitch-east:Double,   ; the pitch on the east face
                                   pitch-north:Double,  ; the pitch on the north face
                                   component-length: Toleranced, ; the distance from pad-edge to pad-edge on the exterior of the part in the x direction
                                   component-width: Toleranced, ; the distance from pad-edge to pad-edge on the exterior of the part in the y direction
                                   package-length: Toleranced,  ; the size of the package in the x direction
                                   package-width: Toleranced,  ; the size of hte package in the y direction
                                   terminal-length: Toleranced, ; the dimension of the leads in the x direction on the east/west faces
                                   terminal-width: Toleranced, ; the dimension of the leads in the y direction on the east/west faces
                                   lead-type:  LandProtrusionType, ; the type of the leads
                                   density-level: DensityLevel   ; the density level of the design
):
  make-quad-landpattern(num-pins-west, num-pins-south, num-pins-east, num-pins-north,
                        pitch-west,    pitch-south,    pitch-east,    pitch-north,
                        component-length, component-width, 
                        package-length, package-width,
                        terminal-length, terminal-width,
                        lead-type, density-level,
                        false)

; create a quad landpattern with default density level and no thermal pad
public defn make-quad-landpattern (num-pins-west: Int,  ; the number of pins on the west face
                                   num-pins-south: Int, ; the number of pins on the south face
                                   num-pins-east: Int,  ; the number of pins on the east face
                                   num-pins-north: Int, ; the number of pins on the north face
                                   pitch-west:Double,   ; the pithc on the west face
                                   pitch-south:Double,  ; the pitch on the south face
                                   pitch-east:Double,   ; the pitch on the east face
                                   pitch-north:Double,  ; the pitch on the north face
                                   component-length: Toleranced, ; the distance from pad-edge to pad-edge on the exterior of the part in the x direction
                                   component-width: Toleranced, ; the distance from pad-edge to pad-edge on the exterior of the part in the y direction
                                   package-length: Toleranced,  ; the size of the package in the x direction
                                   package-width: Toleranced,  ; the size of hte package in the y direction
                                   terminal-length: Toleranced, ; the dimension of the leads in the x direction on the east/west faces
                                   terminal-width: Toleranced, ; the dimension of the leads in the y direction on the east/west faces
                                   lead-type:  LandProtrusionType, ; the type of the leads
):
  make-quad-landpattern(num-pins-west, num-pins-south, num-pins-east, num-pins-north,
                        pitch-west,    pitch-south,    pitch-east,    pitch-north,
                        component-length, component-width, 
                        package-length, package-width,
                        terminal-length, terminal-width,
                        lead-type, DENSITY-LEVEL,
                        false)

; Create a quad landpattern with optional thermal pad and default density level
public defn make-quad-landpattern (num-pins-west: Int,  ; the number of pins on the west face
                                   num-pins-south: Int, ; the number of pins on the south face
                                   num-pins-east: Int,  ; the number of pins on the east face
                                   num-pins-north: Int, ; the number of pins on the north face
                                   pitch-west:Double,   ; the pithc on the west face
                                   pitch-south:Double,  ; the pitch on the south face
                                   pitch-east:Double,   ; the pitch on the east face
                                   pitch-north:Double,  ; the pitch on the north face
                                   component-length: Toleranced, ; the distance from pad-edge to pad-edge on the exterior of the part in the x direction
                                   component-width: Toleranced, ; the distance from pad-edge to pad-edge on the exterior of the part in the y direction
                                   package-length: Toleranced,  ; the size of the package in the x direction
                                   package-width: Toleranced,  ; the size of hte package in the y direction
                                   terminal-length: Toleranced, ; the dimension of the leads in the x direction on the east/west faces
                                   terminal-width: Toleranced, ; the dimension of the leads in the y direction on the east/west faces
                                   lead-type:  LandProtrusionType, ; the type of the leads
                                   exposed-metal-heat-feature?: Shape|False, ; the thermal pad
):
  make-quad-landpattern(num-pins-west, num-pins-south, num-pins-east, num-pins-north,
                        pitch-west,    pitch-south,    pitch-east,    pitch-north,
                        component-length, component-width, 
                        package-length, package-width,
                        terminal-length, terminal-width,
                        lead-type, DENSITY-LEVEL,
                        exposed-metal-heat-feature?)

; Create a quad landpattern with optional thermal pad
public defn make-quad-landpattern (num-pins:Int, 
                                   pitch:Double, 
                                   lead-span:Toleranced, 
                                   package-size:Toleranced, 
                                   terminal-length:Toleranced, 
                                   terminal-width:Toleranced, 
                                   lead-type:LandProtrusionType
                                   exposed-metal-heat-feature?:Shape|False):
  ensure-divisible!(num-pins, 4, "make-quad-landpattern(num-pins, ...)")
  make-quad-landpattern(num-pins / 4, num-pins / 4, num-pins / 4, num-pins / 4, 
                        pitch, pitch, pitch, pitch, 
                        lead-span, lead-span, 
                        package-size, package-size, 
                        terminal-length, terminal-width, lead-type, 
                        DENSITY-LEVEL, exposed-metal-heat-feature?)
  
; Create a default quad landpattern with no thermal pad
public defn make-quad-landpattern (num-pins:Int, 
                                   pitch:Double, 
                                   lead-span:Toleranced, 
                                   package-size:Toleranced, 
                                   terminal-length:Toleranced, 
                                   terminal-width:Toleranced, 
                                   lead-type:LandProtrusionType):
  make-quad-landpattern(num-pins,
                        pitch,
                        lead-span,
                        package-size,
                        terminal-length,
                        terminal-width,
                        lead-type
                        false)

; Create a qfn landpattern with optional thermal pad
public defn make-qfn-landpattern (num-pins:Int, 
                                  pitch:Double, 
                                  package-size:Toleranced, 
                                  terminal-length:Toleranced, 
                                  terminal-width:Toleranced,
                                  exposed-metal-heat-feature?:Shape|False):
  make-quad-landpattern(num-pins,
                        pitch,
                        package-size,
                        package-size, 
                        terminal-length, terminal-width, 
                        QuadFlatNoLeads, 
                        exposed-metal-heat-feature?)

; Create a QFN with no thermal pad
public defn make-qfn-landpattern (num-pins:Int, 
                                  pitch:Double, 
                                  package-length:Toleranced, 
                                  terminal-length:Toleranced, 
                                  terminal-width:Toleranced):
  make-quad-landpattern(num-pins,
                        pitch,
                        package-length, package-length, 
                        terminal-length, terminal-width, 
                        QuadFlatNoLeads)

; Create a qfn landpattern with no thermal pad
public defn make-qfn-landpattern (num-pins:Int, 
                                  pitch:Double, 
                                  package-size:Toleranced, 
                                  terminal-length:Toleranced, 
                                  terminal-width:Toleranced):
  make-qfn-landpattern(num-pins, pitch, package-size, terminal-length, terminal-width, false)

; Create a qfn landpattern with optional thermal pad and differing number of pins per side
public defn make-qfn-landpattern (num-pins:[Int, Int, Int, Int], 
                                  pitch:Double, 
                                  package-size:Toleranced, 
                                  terminal-length:Toleranced, 
                                  terminal-width:Toleranced,
                                  exposed-metal-heat-feature?:Shape|False):
  make-quad-landpattern(num-pins[0], num-pins[1], num-pins[2], num-pins[3], 
                        pitch, pitch, pitch, pitch,
                        package-size, package-size,
                        package-size, package-size,
                        terminal-length, terminal-width, 
                        QuadFlatNoLeads, DENSITY-LEVEL, 
                        exposed-metal-heat-feature?)

; Create a QFN landpattern with no thermal pad and different number of pins per side
public defn make-qfn-landpattern (num-pins:[Int, Int, Int, Int], 
                                  pitch:Double, 
                                  package-size:Toleranced, 
                                  terminal-length:Toleranced, 
                                  terminal-width:Toleranced):
  make-qfn-landpattern(num-pins, pitch, package-size, terminal-length, terminal-width, false)

; Create a QFP land pattern with optional thermal pad
public defn make-qfp-landpattern (num-pins:Int, 
                                  pitch:Double, 
                                  lead-span:Toleranced, 
                                  package-length:Toleranced, 
                                  lead-length:Toleranced, 
                                  lead-width:Toleranced
                                  exposed-metal-heat-feature?:Shape|False):
  val lead-type = BigGullWingLeads when pitch >= 0.0625 else SmallGullWingLeads
  make-quad-landpattern(num-pins, 
                        pitch,
                        lead-span, 
                        package-length, 
                        lead-length, lead-width,
                        lead-type, 
                        exposed-metal-heat-feature?)

; Create a QFP landpattern with no thermal pad
public defn make-qfp-landpattern (num-pins:Int, 
                                  pitch:Double, 
                                  component-size:Toleranced, 
                                  package-size:Toleranced, 
                                  lead-length:Toleranced, 
                                  lead-width:Toleranced):
  make-qfp-landpattern(num-pins, pitch, component-size, package-size, lead-length, lead-width, false)

; Create an `n` pin SOIC land pattern. 
;
; Restrictions:
; - n must be even
; - the leads are oriented on the left and right sides of the land pattern
; - p[1] is the top left pin
;
public defn make-n-pin-soic-landpattern (num-pins:Int,                 ; number of pins of the component
                                         pitch:Double,                 ; pitch of the pins of the component
                                         lead-span:Toleranced,  ; the overall length of the component, from terminal-edge to terminal-edge
                                         package-length:Toleranced,    ; the length of the package 
                                         package-width:Toleranced,     ; the width of the package
                                         lead-type:LandProtrusionType, ; the lead/land protrusion type of the part
                                         terminal-length:Toleranced,   ; the length of the terminals
                                         terminal-width:Toleranced,    ; the width of the terminals
                                         density-level:DensityLevel,   ; the density level of the design
                                         exposed-metal-heat-feature?:False|Shape):    ; an optional shape of a thermal pad
  fatal("n must be even") when (num-pins % 2) != 0
  val lead-fillets = lead-fillets(lead-type, density-level)

  inside pcb-landpattern:
    ;----------------------------------------------------
    ; Compute adjustments to dimensions using IPC formula
    val ipc = ipc-formula(
      lead-span, terminal-length, terminal-width, 
      lead-fillets
    )

    ;----------------------------------------------------
    ; compute our pad sizes
    val pad-sz  = pad-size(ipc)

    ;----------------------------------------------------
    ; place the pads
    val grid-sz = Dims(Gmin(ipc) + x(pad-sz), pitch)
    val locs    = to-tuple(grid-locs(num-pins / 2, 2, x(grid-sz), y(grid-sz), false))
    for (i in 0 to false, l in locs) do:
      val r = i % (num-pins / 2)
      val c = i / (num-pins / 2)
      val idx = (i + 1) when c == 0 else num-pins - r
      pad p[idx] : smd-pad(Rectangle(pad-sz)) at l
    
    ;----------------------------------------------------
    ; compute the courtyard
    val solder-mask-registration = clearance(current-rules(), SolderMaskRegistration)
    val [max-y, min-y] = fork-on-seq(seq(y{center(_)}, locs), maximum, minimum)
    val lp-y-dim = y(pad-sz) + max-y - min-y
    val lp-sz   = enlarge(Dims(Zmax(ipc), y(pad-sz) + max-y - min-y), 2.0 * solder-mask-registration)
    val part-sz = Dims(max-value(package-length), max-value(package-width))
    val cy-sz   = enlarge(max(lp-sz, part-sz), 2.0 * courtyard-excess(lead-fillets))
    layer(Courtyard(Top)) = Rectangle(cy-sz)
        
    ;----------------------------------------------------
    ; draw the orientation marker
    val silk-solder-mask-clearance = clearance(current-rules(), MinSilkSolderMaskSpace)
    val pad-loc = center(locs[0])
    val pol-x = min(-0.5 * x(part-sz), x(pad-loc) - 0.5 * x(pad-sz))
    val pol-y = max( 0.5 * y(part-sz), y(pad-loc) + 0.5 * y(pad-sz))
    val line-width  = clearance(current-rules(), MinSilkscreenWidth)
    val line-length = 3.0 * line-width - line-width
    val dist  = solder-mask-registration + silk-solder-mask-clearance + line-width * 0.5 + 0.01
    layer(Silkscreen("pol", Top)) = loc(pol-x, pol-y + dist) * Line(line-width, [Point(0.0, 0.0), Point(line-length, 0.0)])
    
    ;----------------------------------------------------
    ; place the reference label    
    val min-silkscreen-text-height = clearance(current-rules(), MinSilkscreenTextHeight)
    val text-y = 0.5 * (y(cy-sz) + min-silkscreen-text-height)
    ref-label(0.0, text-y)

    ;----------------------------------------------------
    ; place the thermal pad
    make-thermal-pad(exposed-metal-heat-feature?, Dims(Gmin(ipc), min-value(package-width)), num-pins)

; Create an SOIC landpattern with default density level and optional thermal pad
public defn make-n-pin-soic-landpattern (num-pins:Int, ; the number of pins of the component
                                         pitch:Double, ; the pitch of the pins
                                         lead-span:Toleranced, ; the overall length of the component, from lead to lead
                                         package-length:Toleranced,   ; the length of the package
                                         package-width:Toleranced,    ; the width of the package
                                         terminal-length:Toleranced,  ; the length of terminals or leads of the package
                                         terminal-width:Toleranced,   ; the width of the terminals or leads of the package
                                         exposed-metal-heat-feature?:False|Shape) :  ; an optional thermal pad shape
  val lead-type = BigGullWingLeads when pitch > 0.0625 else SmallGullWingLeads
  make-n-pin-soic-landpattern(num-pins,
                              pitch
                              lead-span,
                              package-length,
                              package-width,
                              lead-type,
                              terminal-length,
                              terminal-width,
                              DENSITY-LEVEL, 
                              exposed-metal-heat-feature?)

; Create an SOIC landpattern with default denity level and no thermal pad
public defn make-n-pin-soic-landpattern (num-pins:Int, ; the number of pins of the component
                                         pitch:Double, ; the pitch of the pins
                                         component-length:Toleranced, ; the overall length of the component, from lead to lead
                                         package-length:Toleranced,   ; the length of the package
                                         package-width:Toleranced,    ; the width of the package
                                         terminal-length:Toleranced,  ; the length of the terminals
                                         terminal-width:Toleranced) : ; the width of the terminals
  make-n-pin-soic-landpattern(num-pins,
                              pitch
                              component-length,
                              package-length,
                              package-width,
                              terminal-length,
                              terminal-width,
                              false)

public defn make-dfn-landpattern (num-pins:Int,                 ; number of pins of the component
                                  pitch:Double,                 ; pitch of the pins of the component
                                  package-length:Toleranced,    ; the length of the package 
                                  package-width:Toleranced,     ; the width of the package
                                  terminal-length:Toleranced,   ; the length of the terminals
                                  terminal-width:Toleranced,    ; the width of the terminals
                                  exposed-metal-heat-feature?:False|Shape):    ; an optional shape of a thermal pad
  make-n-pin-soic-landpattern(num-pins, 
                              pitch,
                              package-length, 
                              package-length, package-width,
                              SmallOutlineNoLeads,
                              terminal-length, terminal-width,
                              DENSITY-LEVEL,
                              exposed-metal-heat-feature?)

public defn make-two-pin-chip-landpattern (length:Toleranced, ; the length (vertical) dimension of the package
                                           width:Toleranced,  ; the width (horizontal) dimension of the package
                                           lead-length:Toleranced, ; the length (vertical) dimension of the conductors/leads of the package
                                           lead-width?:False|Toleranced, ; the width (horizontal) dimension of the conductors/leads of the package, if different from `length`
                                           density-level:DensityLevel,   ; the density level of the design (DensityLevelA|DensityLevelB|DensityLevelC)
                                           anode-and-cathode?:True|False,; whether the pads should be named `a` and `c` (if false, p[1] and p[2])
                                           polarized?:True|False         ; whether a polarity marker is required or not
                                           ):
  inside pcb-landpattern:
    ; compute the solder fillets based on the protrusion type
    ; if > 16xx (1.6mm), use big rectangular leads
    val land-protrusion-type = BigRectangularLeads when typ(length) > 1.6 else SmallRectangularLeads
    val lead-fillets = lead-fillets(land-protrusion-type, density-level)

    ; compute the base dimensions of the lands
    val ipc = ipc-formula(
      length, lead-length, width when lead-width? is False else lead-width? as Toleranced,
      lead-fillets
    )

    ; ----------------------------------------------------
    ; place the pads
    val pad-sz = transpose(pad-size(ipc))
    val y-max = 0.5 * Gmin(ipc) + 0.5 * y(pad-sz)
    val y-min = (- y-max)

    val pad-def = smd-pad(Rectangle(pad-sz)) ; pass in solder-mask-defined? 
    if anode-and-cathode?:
      pad a: pad-def at loc(0.0, y-max)
      pad c: pad-def at loc(0.0, y-min)
    else:
      pad p[1]: pad-def at loc(0.0, y-max)
      pad p[2]: pad-def at loc(0.0, y-min)
    
    ; ----------------------------------------------------
    ; compute the courtyard
    val solder-mask-registration = clearance(current-rules(), SolderMaskRegistration)
    val lp-sz   = enlarge(Dims(x(pad-sz), Zmax(ipc)), 2.0 * solder-mask-registration)
    val part-sz = Dims(max-value(width), max-value(length))
    val cy-sz   = enlarge(max(lp-sz, part-sz), 2.0 * courtyard-excess(lead-fillets))
    layer(Courtyard(Top)) = Rectangle(cy-sz)
    
    ; ----------------------------------------------------
    ; draw the polarity marker
    if polarized?:
      val min-silk-width = clearance(current-rules(), MinSilkscreenWidth)
      ; the formula for placing the polarity marker is:
      ;   for marker line M:
      ;   
      ;   M is placed a distance M_dist away from the land pattern 
      ;   in the top-level corner, which is the corner of the land pattern 
      ;   closest to p[1]/a. 
      ; 
      ;   - M_length = 3.0 * min-silk-width
      ;   - M_width  = min-silk-width
      ; 
      ;   M_dist = solder-mask-registration + silk-solder-mask-clearance + min-silk-width * 0.5 + 0.01
      ; 
      ; assumptions:
      ;   - the pad dimensions are outside the bounds of the part. This is guaranteed by the computation above.
      ;   - the land pattern is centered about the origin
      ;   - the pad corresponding to p[1] or a is centered about its origin.
      ; 
      val solder-mask-registration = clearance(current-rules(), SolderMaskRegistration)
      val silk-solder-mask-clearance = clearance(current-rules(), MinSilkSolderMaskSpace)
      val line = Line(min-silk-width, [Point(min-silk-width * 0.5, 0.0),
                                       Point(3.5 * min-silk-width, 0.0)])
      val dist = solder-mask-registration + silk-solder-mask-clearance + min-silk-width * 0.5 + 0.01
      val pol-x = -0.5 * max(x(lp-sz), x(part-sz))
      val pol-y =  0.5 * max(y(lp-sz), y(part-sz)) + dist
      layer(Silkscreen("pol", Top)) = loc(pol-x, pol-y) * line
      
    val min-silkscreen-text-height = clearance(current-rules(), MinSilkscreenTextHeight)
    val text-x = 0.5 * (x(cy-sz) + min-silkscreen-text-height)
    ref-label(loc(text-x, 0.0, -90.0), C)

public defn make-two-pin-chip-landpattern (length:Toleranced,
                                           width:Toleranced,
                                           lead-length:Toleranced,
                                           lead-width?:False|Toleranced,
                                           density-level:DensityLevel,
                                           polarized?:True|False):
  make-two-pin-chip-landpattern(
    length, width, lead-length, lead-width?, 
    density-level, polarized?, polarized?
  )

public defn make-two-pin-chip-landpattern (length:Toleranced,
                                           width:Toleranced,
                                           lead-length:Toleranced,
                                           density-level:DensityLevel,
                                           polarized?:True|False):
  make-two-pin-chip-landpattern(
    length, width, lead-length, false, 
    density-level, polarized?
  )

; Create a two pin chip landpattern factoring in factory tolerances and controlling 
; whether the pads should be considered "solder mask defined" 
public pcb-landpattern two-pin-chip-landpattern (length:Toleranced,
                                                 width:Toleranced,
                                                 lead-length:Toleranced,
                                                 lead-width?:False|Toleranced,
                                                 density-level:DensityLevel,
                                                 polarized?:True|False):
  make-two-pin-chip-landpattern(
    length, width, lead-length, lead-width?,
    density-level, polarized?, polarized?
  )


; Create a two-pin chip landpattern with a custom density level
public defn two-pin-chip-landpattern (length:Toleranced,
                                      width:Toleranced,
                                      lead-length:Toleranced,
                                      density-level:DensityLevel,
                                      polarized?:True|False):
  two-pin-chip-landpattern(
    length, width, lead-length, false, 
    density-level, polarized?
  )

; Create a two-pin chip landpattern given legnth, width, and lead-lengths
public defn two-pin-chip-landpattern (length:Toleranced,
                                      width:Toleranced,
                                      lead-length:Toleranced,
                                      polarized?:True|False):
  two-pin-chip-landpattern(
    length, width, lead-length, false, 
    DENSITY-LEVEL, polarized?
  )

; Helper function to lookup the hole-to-lead diameter based on the density level of the design.
defn hole-to-lead-diameter (d:DensityLevel) -> [Double, Double]:
  switch(d):
    DensityLevelA: [0.70, 0.25],
    DensityLevelB: [0.70, 0.20],
    DensityLevelC: [0.60, 0.15],

; Helper function to compute the pad and hole size of through hoel components
defn pth-pad-sizes (lead-diameter:Toleranced, density-level:DensityLevel):
  val min-outer-layer-pad-size = MIN-OUTER-LAYER-PAD-SIZE
  val max-hole-size-tolerance  = MAX-HOLE-SIZE-TOLERANCE
  val min-hole-size-tolerance  = MIN-HOLE-SIZE-TOLERANCE
  val hole-position-tolerance  = HOLE-POSITION-TOLERANCE

  ; Lookup the max/min hole to lead diameter
  val [max-h2l, min-h2l] = hole-to-lead-diameter(density-level)

  ; Compute the hole size. This will be the average of the maximum
  ; and minimum possible hole sizes given the design rules.
  val max-hole-diam = min-value(lead-diameter) - max-hole-size-tolerance + max-h2l
  val min-hole-diam = max-value(lead-diameter) + min-hole-size-tolerance + min-h2l
  val hole-diameter = 0.5 * (max-hole-diam + min-hole-diam) 

  ; Compute the pad diameter
  val pad-diameter = hole-diameter + maximum([
      max-hole-size-tolerance + 0.5,
      max-hole-size-tolerance + hole-position-tolerance + 50.0e-6
      min-outer-layer-pad-size,
  ])
  [pad-diameter, hole-diameter]

; Helper function for two-pin through-hole components, to place the polarity marker
defn two-pin-th-polarity-marker (cmp-sz:Dims, pad-diameter:Double, lead-spacing:Double):
  inside pcb-landpattern:
    val min-silk-width = clearance(current-rules(), MinSilkscreenWidth)
    val min-silk-solder-mask-space = clearance(current-rules(), MinSilkSolderMaskSpace)
    val solder-mask-registration = clearance(current-rules(), SolderMaskRegistration)

    val line-length = 3.0 * min-silk-width
    val line = Line(min-silk-width, [Point(0.0, 0.0),
                                     Point(line-length, 0.0)])
    val dist = solder-mask-registration + min-silk-solder-mask-space + min-silk-width * 0.5 + 0.01
    val pad-x = -0.5 * pad-diameter
    val pad-y =  0.5 * pad-diameter + 0.5 * lead-spacing
    val cmp-x = -0.5 * x(cmp-sz)
    val cmp-y =  0.5 * y(cmp-sz)
    
    val pol-x = min(pad-x, cmp-x)
    val pol-y = max(pad-y, cmp-y) + dist
    layer(Silkscreen("pol", Top)) = loc(pol-x, pol-y) * line
    val pol-x-2 = pol-x - line-length * 0.5 + 1.5 * min-silk-width
    layer(Silkscreen("pol", Top)) = loc(pol-x-2, pol-y, -90.0) * line

; Helper function for two-pin through hole components, controlling where they get placed
defn place-pth-pads (polarized?:True|False, lead-spacing:Double, pad-def:Pad):
  inside pcb-landpattern:
    val y1 = 0.5 * lead-spacing
    val y2 = (- y1)
    if polarized?:
      pad a: pad-def at loc(0.0, y1)
      pad c: pad-def at loc(0.0, y2)
    else:
      pad p[1]: pad-def at loc(0.0, y1)
      pad p[2]: pad-def at loc(0.0, y2)
  
; Generate a land pattern for a two-pin radial through hole component
public defn make-two-pin-radial-landpattern (component-length:Toleranced, ; the length of the component (x direction)
                                            component-width:Toleranced,  ; the width of the component (y direction)
                                            lead-spacing:Double,     ; the distance between the two leads
                                            lead-diameter:Toleranced,    ; the diameter of the leads
                                            polarized?:True|False,       ; whether the component is polarized or not
                                            density-level:DensityLevel) : ; the density level of the design
  inside pcb-landpattern:
    ;------------------------------------------------------------
    ; Compute the pad definition
    val [pad-diameter, hole-diameter] = pth-pad-sizes(lead-diameter, density-level)
    val pad-def = pth-pad(hole-diameter * 0.5, pad-diameter * 0.5)

    ;------------------------------------------------------------
    ; Place the pads
    place-pth-pads(polarized?, lead-spacing, pad-def)
    
    ;------------------------------------------------------------
    ; Compute the courtyard
    val courtyard-excess = 0.75
    val cy-sz = enlarge{_, courtyard-excess} $
      Dims(max-value(component-length), max-value(component-width))

    layer(Courtyard(Top))    = Rectangle(cy-sz)
    layer(Courtyard(Bottom)) = Rectangle(cy-sz)
    val min-silkscreen-text-height = clearance(current-rules(), MinSilkscreenTextHeight)
    ref-label(loc(0.5 * x(cy-sz) + min-silkscreen-text-height, 0.0, 270.0))

    ; place the polarity marker, if necessary
    if polarized?:
      two-pin-th-polarity-marker(Dims(max-value(component-length), max-value(component-width)), 
                                 pad-diameter, lead-spacing)

; Generate a land pattern for a two-pin axial through hole component
public defn make-two-pin-axial-landpattern (component-length:Toleranced,   ; The length of the component
                                            component-diameter:Toleranced, ; The diameter of the component 
                                            weld:Double,     ; the distance away from the body the leads are bent
                                            lead-diameter:Toleranced, ; the diameter of the leads of the component
                                            bend-length:Double, ; the length of the bend in the leads
                                            bend-radius:Double, ; the radius of the bend in the leads (mm, not %)
                                            polarized?:True|False, ; whether the component is polarized or not
                                            density-level:DensityLevel) : ; the density level of the design
  inside pcb-landpattern:  
    ;------------------------------------------------------------
    ; Compute the pad definition
    val [pad-diameter, hole-diameter] = pth-pad-sizes(lead-diameter, density-level)
    val pad-def = pth-pad(Circle(0.5 * pad-diameter), Circle(0.5 * hole-diameter))
    val lead-spacing = typ(component-length) + 2.0 * (weld + bend-length + bend-radius)

    ;------------------------------------------------------------
    ; Place the pads
    place-pth-pads(polarized?, lead-spacing, pad-def)

    ;------------------------------------------------------------
    ; Compute the courtyard
    val courtyard-excess = 0.75
    val solder-mask-registration = clearance(current-rules(), SolderMaskRegistration)
    val min-silkscreen-text-height = clearance(current-rules(), MinSilkscreenTextHeight)

    val max-x-dim = max(
      max-value(component-diameter),
      pad-diameter + 2.0 * solder-mask-registration
    )
    val max-y-dim = max(
      max-value(component-length)
      pad-diameter + 2.0 * solder-mask-registration + lead-spacing
    )
    val max-dims = Dims(max-x-dim, max-y-dim)
    val cy-sz = enlarge(max-dims, courtyard-excess)
    layer(Courtyard(Top))    = Rectangle(cy-sz)
    layer(Courtyard(Bottom)) = Rectangle(cy-sz)
    ref-label(loc(0.5 * x(cy-sz) + min-silkscreen-text-height, 0.0, 270.0))

    ; place the polarity label, if necessary
    if polarized?:
      println("polarity marker")
      two-pin-th-polarity-marker(Dims(max-value(component-diameter), max-value(component-length)), 
                                 pad-diameter, lead-spacing)

; Create a two-pin radial through hole component with default density level
public defn make-two-pin-radial-landpattern (component-length:Toleranced,
                                             component-width:Toleranced, 
                                             lead-spacing:Double,
                                             lead-diameter:Toleranced,
                                             polarized?:True|False):
  make-two-pin-radial-landpattern(component-length, component-width,
                                  lead-spacing, lead-diameter,
                                  polarized?,
                                  DENSITY-LEVEL)

; Create a two-pin radial through hole component with default density level and polarization (false)
public defn make-two-pin-radial-landpattern (component-length:Toleranced,
                                             component-width:Toleranced, 
                                             lead-spacing:Double,
                                             lead-diameter:Toleranced) :
  make-two-pin-radial-landpattern(component-length, component-width,
                                  lead-spacing, lead-diameter,
                                  false,
                                  DENSITY-LEVEL)

public defn make-two-pin-radial-landpattern (component-diameter:Toleranced,
                                             lead-spacing:Double,
                                             lead-diameter:Toleranced
                                             polarized?:True|False) :
  make-two-pin-radial-landpattern(component-diameter, component-diameter,
                                  lead-spacing, lead-diameter,
                                  polarized?,
                                  DENSITY-LEVEL)

; Create a two-pin radial through hole component with default density level for a circular component
public defn make-two-pin-radial-landpattern (component-diameter:Toleranced,
                                             lead-spacing:Double,
                                             lead-diameter:Toleranced) :
  make-two-pin-radial-landpattern(component-diameter, component-diameter,
                                  lead-spacing, lead-diameter,
                                  false)



; Create a two-pin axial through hole component with default density level, bend-length, bend-radius, and weld
public defn make-two-pin-axial-landpattern (length:Toleranced,
                                            diameter:Toleranced,
                                            weld:Double,
                                            lead-diameter:Toleranced, 
                                            polarized?:True|False) :
  val bend-length = 1.0
  val bend-radius = 
    if typ(lead-diameter) < 0.8: typ(lead-diameter)
    else if typ(lead-diameter) < 1.2: 1.5 * typ(lead-diameter)
    else: 2.0 * typ(lead-diameter)
  make-two-pin-axial-landpattern(length,
                                 diameter,
                                 weld,
                                 lead-diameter,
                                 bend-length,
                                 bend-radius
                                 polarized?,
                                 DENSITY-LEVEL)

public defn make-two-pin-axial-landpattern (length:Toleranced,
                                            diameter:Toleranced,
                                            lead-diameter:Toleranced, 
                                            polarized?:True|False) :
  make-two-pin-axial-landpattern(length, diameter, 1.0, lead-diameter, polarized?)

; Create a two-pin axial through hole component with default density level, bend-length, and bend-radius, and polarization
public defn make-two-pin-axial-landpattern (length:Toleranced,
                                            diameter:Toleranced,
                                            lead-diameter:Toleranced) :
  make-two-pin-axial-landpattern(length,
                                 diameter,
                                 lead-diameter,
                                 false)


;==================================================================================================
;====================================== BGA Land Patterns =========================================
;==================================================================================================
public pcb-enum ocdb/land-patterns/BGAPadType:
  SolderMaskDefined,
  NonSolderMaskDefined,
  Collapsible,
  
pcb-pad bga-pad (typical-ball-diameter:Double,      ; the typical/nominal size of the bga balls
                 pad-type:BGAPadType,               ; the bga pad type, (collapsible, solder mask defined, or non-soldermask defined)
                 solder-mask-registration:Double,   ; the solder-mask registration of the design
                 density-level:DensityLevel,        ; the density level of the design
                 ):
  name = "BGA Pad"
  type = SMD
  val solder-mask-defined? = pad-type is SolderMaskDefined
  val collapsible? = pad-type is Collapsible

  val adjustment = switch(density-level):
    DensityLevelA: 0.75 when collapsible? else 1.15
    DensityLevelB: 0.80 when collapsible? else 1.10
    DensityLevelC: 0.85 when collapsible? else 1.05

  val definition-diameter = typical-ball-diameter * adjustment
  val referenced-diameter = definition-diameter + solder-mask-registration * 2.0

  if solder-mask-defined?:
    shape = Circle(0.5 * definition-diameter)
    layer(SolderMask(Top)) = Circle(0.5 * referenced-diameter)
  else:
    shape = Circle(0.5 * referenced-diameter)
    layer(SolderMask(Top)) = Circle(0.5 * definition-diameter)

defn bga-pad (typical-ball-diameter:Double, ; the typical/nominal size of the bga balls
              pad-type:BGAPadType):
  bga-pad(typical-ball-diameter, 
          pad-type,
          clearance(current-rules(), SolderMaskRegistration),
          DENSITY-LEVEL)

; BGAPadNames is a helper type to create a lookup table of precomputed
; pad names given BGA parameters
public deftype BGAPadNames

; Lookup the pad name given row and column indices
public defmulti get (b:BGAPadNames, r:Int, c:Int) -> Ref

; Compute the pad names
public defn bga-pad-names (num-rows:Int, num-cols:Int, row-chars-omitted?:False|String):
  ; pick the omitted characters if not supplied fallback to a default
  val row-chars-omitted = match(row-chars-omitted?):
    (s:String): s
    (_:False): "IOQSXZ"
    
  ; A small table of characters, each corresponds to the base character for a row
  ; at a given index
  val row-chars = to-tuple $
    for ch in "ABCDEFGHIJKLMNOPQRSTUVWXYZ" filter:
      not contains?(upper-case(row-chars-omitted), ch)
  
  ; helper function to create pad names given indices, follows the convention
  ; "A" "B" "C" ... "AA" "AB" "AC" ... "BA" "BB" "BC" ... etc
  val buf = StringBuffer()
  defn row-name (idx:Int):
    clear(buf)
    var count = to-seq(0 to false)
    let loop (row: Int = idx):
      fatal("exceeded recursion depth when precomputing bga pad names") when next(count) >= 100
      if row >= length(row-chars):
        print(buf, row-chars[row / length(row-chars) - 1])
        loop(row / length(row-chars))
    print(buf, row-chars[idx % length(row-chars)])
    Ref(to-string(buf))
  
  ; Construct a lookup table of pad names
  val pad-names = to-tuple $ 
    for row in 0 to num-rows seq-cat: 
      for col in 0 to num-cols seq:
        row-name(row)[col + 1]

  ; finally wrap the table in a helper to perform the lookup.
  new BGAPadNames:
    defmethod get (this, r:Int, c:Int):
      pad-names[r * num-cols + c]

; A BGAModifier is an abstract type representing a class of BGA Components. It is used to 
; control the way pads are depopulated and spaced on the land pattern. You can declare
; a custom BGA modifier using the new type syntax:
; 
; defn MyBgaModifier ():
;   new BGAModifier:
;     defmethod locs (this, num-rows:Int, num-cols:Int) -> Seqable<Pose>:
;       ...
;     defmethod depopulated? (this, row-index:Int, column-index:Int) -> True|False:
;       ...
;
public deftype BGAModifier
public defmulti depopulated? (m:BGAModifier, r:Int, c:Int) -> True|False
public defmulti locs (m:BGAModifier, nr:Int, nc:Int, pitch:Double) -> Seqable<Pose>
defmethod depopulated? (m:BGAModifier, r:Int, c:Int) -> True|False:
  false
defmethod locs (m:BGAModifier, nr:Int, nc:Int, pitch:Double):
  grid-locs(nr, nc, pitch, pitch)

; A "FullMatrix" BGA is one where no pads are depopulated and the pad
; columns and rows are all equidistant.
public defstruct FullMatrix <: BGAModifier

; A "StageredMatrix" BGA is one where every other pad is depopulated,
; alternating across rows. The distance between adjacent pads on subsequent
; rows will be pitch / sqrt(2).
public defstruct StaggeredMatrix <: BGAModifier

; An "EquilaterTriangleMatrix" is like a staggered matrix, but where the 
; pads are all equistance from eachother. This means for any three adjacent pads
; with two in the same row or column, the centers of the pads form an equilateral 
; triangle.
public defstruct EquilateralTriangleMatrix <: BGAModifier

; A "PerimeterMatrix" is like a full matrix, but with a region of pads in the
; center depopulated.
public defstruct PerimeterMatrix <: BGAModifier:
  rows:Range, ; the range of rows to depopulate
  cols:Range, ; the range of columns to depopulate

; A "ThermallyEnhancedMatrix" is like a PerimeterMatrix, except with some
; region in the center remaining populated.
public defstruct ThermallyEnhancedMatrix <: BGAModifier:
  perimeter-rows:Range, ; the range of rows to depopulate
  perimeter-cols:Range, ; the range of columns to depopulate
  interior-rows:Range, ; the range of rows in the center to remain populated
  interior-cols:Range, ; the range of columns in the center to remain populated

public defn CustomDepop (f:(Int, Int) -> True|False): 
  new BGAModifier:
    defmethod depopulated? (this, r:Int, c:Int):
      f(r, c)

defmethod depopulated? (m:StaggeredMatrix, r:Int, c:Int): 
  ((r + 1) % 2) == (c % 2)

defmethod depopulated? (m:EquilateralTriangleMatrix, r:Int, c:Int): 
  ((r + 1) % 2) == (c % 2)

defmethod depopulated? (m:PerimeterMatrix, r:Int, c:Int):
  contains?(rows(m), r) and contains?(cols(m), c)

defmethod depopulated? (m:ThermallyEnhancedMatrix, r:Int, c:Int):
  (contains?(perimeter-rows(m), r) and contains?(perimeter-cols(m), c)) and not
  (contains?(interior-rows(m), r) and contains?(interior-cols(m), c))

defmethod locs (m:EquilateralTriangleMatrix, nr:Int, nc:Int, pitch:Double):
  val vertical   = sqrt(3.0) * 0.5 * pitch
  val horizontal = pitch * 0.5
  grid-locs(nr, nc, horizontal, vertical)

public defn make-bga-landpattern (num-rows:Int, ; the number of rows of package
                                  num-cols:Int, ; the number of columns of the package
                                  pitch:Double, ; the pitch of the solder bumps
                                  ball-diameter:Double, ; the nominal/typical diameter of the solder balls
                                  pad-type:BGAPadType,  ; whether the pads will be "solder mask defined" or not
                                  package-length:Toleranced, ; the length of the package
                                  package-width:Toleranced,  ; the width of the package
                                  modifier:BGAModifier,      ; the modifier that controls which pads are depopulated
                                  row-characters-omitted?:String|False, ; which characters are omitted from the row names
                                  mirrored?:True|False, ; controls whether the pads are mirrored or not
                                  density-level:DensityLevel): ; the density level of the design
  fatal("make-bga-landpattern-failed(...), num-rows must be positive. Called with: %_." % [num-rows]) when num-rows <= 0
  fatal("make-bga-landpattern-failed(...), num-cols must be positive. Called with: %_." % [num-cols]) when num-cols <= 0
  fatal("make-bga-landpattern-failed(...), pitch must be positive. Called with: %_." % [pitch]) when pitch <= 0.0
  fatal("make-bga-landpattern-failed(...), ball-diameter be positive. Called with: %_." % [ball-diameter]) when ball-diameter <= 0.0
  inside pcb-landpattern:
    ;-------------------------------------------------------------
    ; Compute the pad definition
    val pad-def = bga-pad(ball-diameter, pad-type)
    
    ;-------------------------------------------------------------
    ; Layout the pads
    ; Calculate pad indices
    val pin-indices = to-tuple $
      for r in 0 to num-rows seq-cat:
        for c in 0 to num-cols seq:
          val c* = c when not mirrored? else (num-cols - c - 1)
          [r, c]
    
    ; Calculate pad locations
    val pad-locs  = locs(modifier, num-rows, num-cols, pitch)

    ; Calculate pad names
    val pad-names = bga-pad-names(num-rows, num-cols, row-characters-omitted?)
    
    ; Layout the pad given indices and locations
    for ([row, col] in pin-indices, loc in pad-locs) do:
      if not depopulated?(modifier, row, col):
        pad (pad-names[row, col]): pad-def at loc

    ;-------------------------------------------------------------
    ; Compute the courtyard
    val courtyard-excess = bga-courtyard-excess(density-level)
    val pkg-sz = Dims(max-value(package-length), max-value(package-width))
    val cy-sz = enlarge(pkg-sz, 2.0 * courtyard-excess)
    layer(Courtyard(Top)) = Rectangle(cy-sz)

public defn make-bga-landpattern (num-rows:Int,
                                  num-cols:Int,
                                  pitch:Double,
                                  ball-diameter:Double,
                                  package-length:Toleranced,
                                  package-width:Toleranced,
                                  modifier:BGAModifier,
                                  row-characters-omitted?:False|String,
                                  mirrored?:True|False,):
  make-bga-landpattern(num-rows, num-cols,
                       pitch, ball-diameter, Collapsible,
                       package-length, package-width,
                       modifier, 
                       row-characters-omitted?, 
                       mirrored?,
                       DENSITY-LEVEL)

; Create a BGA land pattern default mirroring (false), default row naming (omitting the characters "IOQSXZ"), 
; default pad type (Collapsible) and default density level. A depopulation modifier may be supplied to control
; which pads are depopulated.
public defn make-bga-landpattern (num-rows:Int,
                                  num-cols:Int,
                                  pitch:Double,
                                  ball-diameter:Double,
                                  package-length:Toleranced,
                                  package-width:Toleranced,
                                  modifier:BGAModifier):
  make-bga-landpattern(num-rows, num-cols,
                       pitch, ball-diameter, Collapsible,
                       package-length, package-width,
                       modifier, 
                       false, ; row-characters-omitted >
                       false, ; mirrored?
                       DENSITY-LEVEL)

; Create a BGA land pattern with default modifier (no pads depopulated), default mirroring (false), 
; default row naming (omitting the characters "IOQSXZ"), and density level pulled from the design variables.
; The pad type may be supplied (SolderMaskDefined, NonSolderMaskDefined, and Collapsible)
public defn make-bga-landpattern (num-rows:Int,
                                  num-cols:Int,
                                  pitch:Double,
                                  ball-diameter:Double,
                                  pad-type:BGAPadType,
                                  package-length:Toleranced,
                                  package-width:Toleranced,
                                  modifier:BGAModifier):
  make-bga-landpattern(num-rows, num-cols,
                       pitch, ball-diameter, pad-type,
                       package-length, package-width,
                       modifier, 
                       false, ; row-characters-omitted
                       false, ; mirrored?
                       DENSITY-LEVEL)

; Create a BGA land pattern with default modifier (no pads depopulated), default mirroring (false), 
; default row naming (omitting the characters "IOQSXZ"), default pad type (Collapsible), and 
; density level pulled from the design variables.
public defn make-bga-landpattern (num-rows:Int,
                                  num-cols:Int,
                                  pitch:Double,
                                  ball-diameter:Double,
                                  package-length:Toleranced,
                                  package-width:Toleranced):
  make-bga-landpattern(num-rows, num-cols,
                       pitch, ball-diameter, Collapsible,
                       package-length, package-width,
                       FullMatrix()) ; modifier
