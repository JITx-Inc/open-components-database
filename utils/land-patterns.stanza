#use-added-syntax(jitx)
defpackage ocdb/land-patterns :
  import core
  import collections
  import math
  import jitx
  import jitx/fonts
  import jitx/commands with:
    prefix(pad) => def-
  import ocdb/design-vars
  import ocdb/land-protrusions
  import ocdb/tolerance

;==============================================================================
;============================== Helpers =======================================
;==============================================================================
; ====== Argument constraint Helpers ===========================================
; Ensure that a value is even and positive.
defn ensure-even-positive! (value: Int, name: String):
  if value < 2 or value % 2 == 1:
    fatal("%_ only supports a positive even number of pins." % [name])

; find the angle of a pad away from the origin
defn pad-angle (pad-ref:Ref) -> Double:
  inside pcb-landpattern:
    val pad-inst = find!({ref(_) == pad-ref}, pads(self))
    val point = center(pose(pad-inst))
    atan2(y(point), x(point))

; ====== Silk screen helpers ===================================================
public defn draw-polarity-marker (pad-ref:Ref, part-dims?:Dims|False) :
  val min-silk-width = clearance(current-rules(), MinSilkscreenWidth)
  inside pcb-landpattern:
    ; draw a line of `min-silk-width` width and length 3.0 * min-silk-width 
    ; centered at origin
    defn draw-line (origin:Pose):
      val line-width  = min-silk-width
      val line-length = line-width * 3.0
      val line = Line(line-width, [
        Point(min-silk-width * 0.5, 0.0)
        Point(line-width + min-silk-width * 0.5, 0.0)  
      ])
      layer(Silkscreen("pol", Top)) = origin * line

    defn part-pose () :
      match(part-dims?) :
        (_:False): 
          loc(0.0, 0.0)
        (d:Dims): 
          loc(x(d) * -0.5,
              y(d) *  0.5 + min-silk-width * 0.5 + PLACEMENT-TOLERANCE)

    defn distance (p:Pose):
      val [x, y] = [x(center(p)), y(center(p))]
      sqrt(x * x + y * y)
    
    defn pad-pose ():
      val lp-dims    = extent-dims()
      val pad-1      = find!({ref(_) == pad-ref}, pads(self))
      val pad-loc    = pose(pad-1)
      val pad-dims   = dims(pad-shape(def-pad(pad-1)))
      val R = SOLDER-MASK-REGISTRATION + min-silk-width * 0.5 + SILK-SOLDER-MASK-CLEARANCE + 0.01
      loc(
        x(pad-dims) * -0.5 + x(center(pad-loc)) - SOLDER-MASK-REGISTRATION
        y(pad-dims) *  0.5 + y(center(pad-loc)) + R
      )
    
    val [p1, p2] = [pad-pose(), part-pose()] 
    draw-line $
      if distance(p1) > distance(p2):
        p1
      else: 
        p2

public defn draw-polarity-marker (p:Ref):
  draw-polarity-marker(p, false)

; Create a reference label at (0, 0)
; ====== Reference Label Helpers ===============================================
; Creates a reference label from pose and anchor
public defn ref-label (pose:Pose, anchor:Anchor):
  inside pcb-landpattern:
    layer(Silkscreen("values", Top)) = Text(">REF", MIN-SILKSCREEN-TEXT-HEIGHT, anchor, pose)

; Creates a reference label at a fixed pose
public defn ref-label (pose:Pose):
  ref-label(pose, C)

; DEPRECATED: prefer ref-label(loc(x, y))
; Creates a reference label at an x,y position and anchor
public defn ref-label (x:Double, y:Double, anchor:Anchor):
  ref-label(loc(x, y), anchor)

; DEPRECATED: prefer ref-label(loc(x, y))
; Creates a reference label at an x,y position with default anchor
public defn ref-label (x:Double, y:Double) :
  ref-label(x,y,C)

; Create a default reference label
public defn ref-label () :
  ref-label(loc(0.0, 0.0))

; Helper function to convert an anchor into a point.
defn normalize-to-point (anchor:Anchor) -> Point:
  val [v, h] = components(anchor)
  val dx = match(h):
    (hr:W) :  1.0
    (hr:C) :  0.0
    (hr:E) : -1.0
  val dy = match(v) :
    (vt:S) : 1.0
    (vt:C) : 0.0
    (vt:N) : 1.0
  Point(dx, dy)

; TODO move to internals
defn times (p:Point, d:Dims) -> Point:
  Point(x(p) * x(d), y(p) * y(d))

; Helper function to convert an x/y width to length and width (by convention: longer side 
; is on x axis and shorter side is on y)
defn normalize-rotation (width:Double, height:Double) -> [Double, Double, Double]:
  val rot = 90.0 when height > width else 0.0
  [max(width, height), min(width, height), rot]

; Normalize the position of a shape given an anchor and rotation.
defn normalize-loc (s:Shape, anchor:Anchor, rot:Double):
  val pose = Pose((0.5 * normalize-to-point(anchor)) * dims(s), rot, false)
  pose * s 

; Create a rectangle with normalized rotation and position.
defn rectangle (anchor:Anchor, width:Double, height:Double):
  val [length, width_, rot] = normalize-rotation(width, height)
  normalize-loc(Rectangle(width, height), anchor,rot)

; Create a capsule with normalized rotation and position.
defn capsule (anchor:Anchor, width:Double, height:Double):
  val [length, width_, rot] = normalize-rotation(width, height)
  normalize-loc(Capsule(length, width_), anchor, rot)

; Create a rounded rectangle with normalized rotation and position.
defn round-rect (anchor:Anchor, width:Double, height:Double, r:Double):
  val [length, width_, rot] = normalize-rotation(width, height)
  normalize-loc(RoundedRectangle(length, width_ r), anchor, rot)
  
; Create a chamfered rectangle with normalized rotation and position.
defn chamfered (anchor:Anchor, width:Double, height:Double, r:Double):
  val [length, width_, rot] = normalize-rotation(width, height)
  normalize-loc(ChamferedRectangle(length, width_, r), anchor, rot)

;==============================================================================
;=========================== Geometric Helpers ================================
;==============================================================================
; ====== Land pattern utilities ===============================================
; Find the extent dimensions of a landpattern given all its layers and pads.
public defn extent-dims () -> Dims:
  inside pcb-landpattern:
    val all-shapes = cat-all $ [
      for pad_ in pads(self) seq:
        pose(pad_) * pad-shape(def-pad(pad_))
      for pad_ in pads(self) seq-cat:
        for layer in filter({specifier(_) is-not Silkscreen}, layers(def-pad(pad_))) seq:
          pose(pad_) * shape(layer)
      for layer-shape in filter({specifier(_) is-not Silkscreen}, layers(self)) seq:
        shape(layer-shape)
    ]
    Dims(0.0, 0.0) when empty?(all-shapes) else dims(Union(all-shapes))

; Create a rectangle out of lines
public defn LineRectangle (w:Double, h:Double, xc:Double, yc:Double, line-w:Double) :
  val w2 = w * 0.5
  val h2 = h * 0.5
  Line(line-w, [
    Point(xc - w2, yc - h2)
    Point(xc + w2, yc - h2)
    Point(xc + w2, yc + h2)
    Point(xc - w2, yc + h2)
    Point(xc - w2, yc - h2)])

; Create a rectangle with width, height, center x/y and default line width
public defn LineRectangle (w:Double, h:Double, xc:Double, yc:Double) :
  LineRectangle(w, h, xc, yc, clearance(current-rules(), MinSilkscreenWidth))

; Create a rectangle with width and height and default x/y position
public defn LineRectangle (w:Double, h:Double) :
  LineRectangle(w, h, 0.0, 0.0)

; Create a rectangle from dims structure
public defn LineRectangle (d:Dims): 
  LineRectangle(x(d), y(d))

; Create a rectangle around another shape
public defn outline-bounding-box (s:Shape):
  LineRectangle(dims(s))

; Create a "+" symbol with a fixed length at a center point
public defn PlusSymbol (center:Point, l:Double) -> Shape:
  val min-width = clearance(current-rules(), MinSilkscreenWidth)
  loc(x(center), y(center)) * 
    Union([Line(min-width, [Point(-0.5 * l, 0.0), Point(0.5 * l, 0.0)])
           Line(min-width, [Point(0.0, -0.5 * l), Point(0.0, 0.5 * l)])])

; Create a 1mm x 1mm plus symbol at Point(x, y)
public defn PlusSymbol (x:Double, y:Double) -> Shape:
  PlusSymbol(Point(x, y), 1.0)

;==============================================================================
;================================= Pads =======================================
;==============================================================================
; Apply a shape to the soldermask layer of a pcb-pad. 
public defn apply-soldermask (mask-shape:Shape):
  inside pcb-pad:
    layer(SolderMask(Top)) = mask-shape
    if pad-type(self) == TH:
      layer(SolderMask(Bottom)) = mask-shape

; Create the soldermask layers based on the pad shape, using a fixed factor.
; when expand? is true the soldermask shape is computed with expand(), else it is
; computed with offset()
public defn apply-soldermask (amount:Double, expand?:True|False):
  val mask-shape = 
    match(pad-shape(self)):
      (s:Rectangle|Circle|RoundedRectangle|Segment):
        val func = expand when expand? else offset
        func(s, amount)
      (s:ChamferedRectangle|DShape|Capsule):
        expand(s, amount)
      (s:Shape):
        ; FIXME: allow offset/expand to be used for other shapes!!
        s  
  inside pcb-landpattern:
    apply-soldermask(mask-shape)

; Apply a default soldermask layer to a pcb-pad, using the SOLDER-MASK-REGISTRATION
; design variable and offset() method.
public defn apply-soldermask ():
  apply-soldermask(SOLDER-MASK-REGISTRATION, false)

; A "solder mask defined pad" is one where the soldermask opening is smaller than 
; the pad shape. This method takes a pad as an argument and converts it into a 
; soldermask-defined version based on its soldermask layer, if it exists, or the
; pad shape if it does not.
public defn soldermask-defined (p:Pad):
  ; extract the pad data before conversion
  val mask?   = find({specifier(_) is SolderMask}, layers(p))  
  ; special case: the mask is smaller than the shape already
  if (mask? is-not False) and 
     (min-width([pad-shape(p)]) > min-width([shape $ (mask? as LayerShape)])) :
    p
  else :
    pcb-pad SMD-p:
      name  = to-string("%_, SMD" % [name(p)])
      type  = pad-type(p)
      shape = pad-shape(p)
      apply-soldermask(0.85, true)
      for layer_ in filter({specifier(_) is-not SolderMask}, layers(p)) do:
        layer(specifier(layer_)) = shape(layer_)
    SMD-p

; Convert a landpattern to solder mask defined. Geoms will be ignored. 
public defn soldermask-defined (lp:LandPattern):
  pcb-landpattern SMD-l:
    name = to-string("%_, soldermask defined" % [name(lp)])
    for pad_ in pads(lp) do:
      pad (ref(pad_)): soldermask-defined(def-pad(pad_)) at pose(pad_)
    for layer_ in layers(lp) do:
      layer(specifier(layer_)) = shape(layer_)

  SMD-l

public pcb-pad smd-pad (s:Shape):
  name  = "SMD Pad"
  type  = SMD
  shape = s
  apply-soldermask()

; Create an rectangular SMD pad 
public defn smd-pad (anchor:Anchor, width:Double, height:Double):
  smd-pad(Rectangle(anchor, width, height))

; Create an SMD pad with a given width and height
public defn smd-pad (width:Double, height:Double) :
  smd-pad(C, width, height)

; Create a BGA pad, with circular SMD
public defn bga-pad (diameter:Double) :
  smd-pad(Circle(diameter * 0.5))

; Create a soldermask-defined BGA pad
public pcb-pad soldermask-defined-bga-pad (
  soldermask-opening-diameter:Double ; the diameter of the soldermask opening
  overlap:Double                     ; the amount the soldermask overlaps the pad beneath
):
  val mask-shape = Circle(soldermask-opening-diameter * 0.5)
  name  = "SMD BGA Pad"
  shape = offset(mask-shape, -1. * overlap) as Circle
  type = SMD
  layer(SolderMask(Top)) = mask-shape

; Create an arbitrary testpoint pad
public pcb-pad testpoint-pad (testpoint-shape:Shape):
  name = "Test Point Pad"
  shape = testpoint-shape
  type = SMD
  layer(SolderMask(Top)) = testpoint-shape

; Create a circular test point pad
public defn testpoint-pad (diameter:Double) :
  testpoint-pad(Circle(0.5 * diameter))

public pcb-pad pth-pad (pad-shape:Shape, hole-shape:Shape):
  name = "PTH Pad"
  shape = pad-shape
  type = TH
  apply-soldermask()
  layer(Cutout()) = hole-shape

public defn pth-pad (drill-r:Double, pad-r:Double):
  pth-pad(Circle(pad-r), Circle(drill-r))

; Create a through hole circular pad
public defn pth-pad (anchor:Anchor, drill-radius:Double, pad-radius:Double) :
  pth-pad(Circle(anchor, pad-radius),  Circle(anchor, drill-radius))

; Create a through hole circular pad with drill radius and anchor
public defn pth-pad (anchor:Anchor, drill-radius:Double) :
  pth-pad(anchor, drill-radius, drill-radius + SOLDER-MASK-REGISTRATION)

public defn pth-pad (drill-radius:Double):
  pth-pad(C, drill-radius)

; Create an ovalcut pad, the shape is a Circle with a Capsule shaped hole.
public defn pth-ovalcut-pad (anchor:Anchor, drill-size:Dims, pad-radius:Double, mask-radius:Double):
  pth-pad(Circle(anchor, pad-radius), capsule(anchor, x(drill-size), y(drill-size)))
  
; Create an ocvalcut pad, the shape is a Circle with a Capsule shaped hole.
public defn pth-ovalcut-pad (anchor:Anchor, drill-width:Double, drill-height:Double, pad-radius:Double, mask-radius:Double) :
  pth-ovalcut-pad(anchor, Dims(drill-width, drill-height), pad-radius, mask-radius)

; Create an ovalcut pad with a given drill width, drill height, and mask radius.
public defn pth-ovalcut-pad (drill-w:Double, drill-h:Double, mask-r:Double) :
  pth-ovalcut-pad(C, drill-w, drill-h, mask-r, mask-r)

; Create a capsule shaped SMD pad with an anchor
public defn oval-smd-pad (anchor:Anchor, width:Double, height:Double) :
  smd-pad(capsule(anchor, width, height))  

; Create a capsule shaped SMD pad
public defn oval-smd-pad (w:Double, h:Double) :
  oval-smd-pad(C, w, h)

; Create a capsule shaped TH pad with anchor
public defn oval-pth-pad (anchor:Anchor, drill-w:Double, drill-h:Double, pad-w:Double, pad-h:Double) :
  val shape = capsule(anchor, pad-w, pad-h)
  val hole = capsule(anchor, drill-w, drill-h)
  pth-pad(shape, hole)

; Create a capsule shaped TH pad with a circular hole
public defn oval-pth-pad (drill-r:Double, pad-w:Double, pad-h:Double) :
  oval-pth-pad(C, drill-r, drill-r, pad-w, pad-h)

; Create a capsule shaped pth pad
public defn oval-pth-pad (drill-w:Double, drill-h:Double, pad-w:Double, pad-h:Double) :
  oval-pth-pad(C, drill-w, drill-h, pad-w, pad-h)

; Create a rectangle pth pad with anchor, width, height, pad width, and pad height
public defn rect-pth-pad (anchor:Anchor, drill-w:Double, drill-h:Double, pad-w:Double, pad-h:Double):
  val shape = rectangle(anchor, pad-w, pad-h)
  val hole  = capsule(anchor, drill-w, drill-h)
  pth-pad(shape, hole)

; Create a rectangle pth pad with drill 
public defn rect-pth-pad (drill-r:Double, pad-w:Double, pad-h:Double) :
  rect-pth-pad(C, drill-r, drill-r, pad-w, pad-h)

public defn rect-pth-pad (drill-w:Double, drill-h:Double, pad-w:Double, pad-h:Double) :
  rect-pth-pad(C, drill-w, drill-h, pad-w, pad-h)

public defn round-rect-pth-pad (anchor:Anchor, drill-w:Double, drill-h:Double, pad-w:Double, pad-h:Double, pad-r:Double) :
  val shape = round-rect(anchor, pad-w, pad-h, pad-r)
  val hole  = capsule(anchor, drill-w, drill-h)
  pth-pad(shape, hole)

public defn round-rect-pth-pad (drill-r:Double, pad-w:Double, pad-h:Double, pad-r:Double) :
  round-rect-pth-pad(C, drill-r, drill-r, pad-w, pad-h, pad-r)

public defn round-rect-smd-pad (anchor:Anchor, w:Double, h:Double, r:Double) :
  smd-pad(round-rect(anchor, w, h, r))

public defn round-rect-smd-pad (w:Double, h:Double, r:Double) :
  round-rect-smd-pad(C, w, h, r)

public defn chamfered-rect-pth-pad (anchor:Anchor, drill-w:Double, drill-h:Double, pad-w:Double, pad-h:Double, pad-r:Double) :
  val shape = chamfered(anchor, pad-w, pad-h, pad-r)
  val hole  = capsule(anchor, drill-w, drill-h)
  pth-pad(shape, hole)

public defn chamfered-rect-pth-pad (drill-r:Double, pad-w:Double, pad-h:Double, pad-r:Double) :
  chamfered-rect-pth-pad(C, drill-r, drill-r, pad-w, pad-h, pad-r)

public defn chamfered-rect-pth-pad (drill-w:Double, drill-h:Double, pad-w:Double, pad-h:Double, pad-r:Double) :
  chamfered-rect-pth-pad(C, drill-w, drill-h, pad-w, pad-h, pad-r)

public defn chamfered-rect-smd-pad (anchor:Anchor, w:Double, h:Double, r:Double) :
  smd-pad(chamfered(anchor, w, h, r))

public defn chamfered-rect-smd-pad (w:Double, h:Double, r:Double):
  chamfered-rect-smd-pad(C, w, h, r)

public defn dshape-smd-pad (anchor:Anchor, w:Double, h:Double, r:Double) : 
  smd-pad(DShape(anchor, w, h, r))

public defn dshape-smd-pad (w:Double, h:Double, r:Double) : 
  dshape-smd-pad(C, w, h, r)

public defn dshape-pth-pad (anchor:Anchor, drill-w:Double, drill-h:Double, w:Double, h:Double, r:Double) : 
  pth-pad(DShape(anchor, w, h, r), DShape(anchor, drill-w, drill-h, r))

public defn dshape-pth-pad (drill-w:Double, drill-h:Double, w:Double, h:Double, r:Double) : 
  dshape-pth-pad(C, drill-w, drill-h, w, h, r)

;==============================================================================
;========================= Land Patterns ======================================
;==============================================================================
; Create a non-plated hole of arbitrary shape for hole and mask
public pcb-landpattern non-plated-hole-landpattern (hole:Shape, mask:Shape):
  layer(Cutout())           = hole
  layer(SolderMask(Top))    = mask
  layer(SolderMask(Bottom)) = mask
  val d = dims(hole)
  layer(Courtyard(Top))    = Rectangle(x(d), y(d))
  layer(Courtyard(Bottom)) = Rectangle(x(d), y(d))

; Create a non-plated hole landpattern with a hole shape
public defn non-plated-hole-landpattern (hole:Shape):
  non-plated-hole-landpattern(hole, offset(hole,  SOLDER-MASK-REGISTRATION))

; Create a circular non-plated hole landpattern with given drill radius and mask radius
public defn non-plated-hole-landpattern (drill-r:Double, mask-r:Double) :
  non-plated-hole-landpattern(Circle(drill-r), Circle(mask-r))

; Create a non-plated hole landpattern with a given drill radius.
public defn non-plated-hole-landpattern (drill-r:Double) :
  non-plated-hole-landpattern(drill-r, drill-r)

;==============================================================================
;========================== Land Pattern Generators ===========================
;==============================================================================

;==============================================================================
;========================== Pose Arrangement Helpers ==========================
;==============================================================================
; PinPadMapping is a not-yet-placed pad, with assigned name, pad, and pose
public pcb-struct ocdb/land-patterns/PinPadMapping:
  pad-name:  Ref,  ; the name of the pad
  pad-shape: JITXDef, ; the corresponding pcb-pad
  pose:      Pose,    ; the pose of the pad

; A generic landpattern created from a sequence of PinPadMappings
public defn make-generic-landpattern (pads:Seqable<PinPadMapping>):
  inside pcb-landpattern:
    for p in pads do:
      pad (pad-name(p)): (pad-shape(p) as Pad) at pose(p)

; Create a generic landpattern with a uniform pad
public defn make-generic-landpattern (pad-names:Seqable<Ref>,
                                      poses:Seqable<Pose>,
                                      pad-shape:JITXDef):
  val pads = 
    for (pn in pad-names, pp in poses) seq:
      PinPadMapping(pn, pad-shape, pp) 
  make-generic-landpattern(to-tuple(pads))

; Naming for a 2-column arrangment of pins 
public defn soic-naming-convention (row:Int, column:Int, num-pins:Int) -> Ref:
  if (column < 0) or (column > 1): 
    fatal("soic naming convention supports a maximum of 2 columns")
  switch(column):
    0: IndexRef(Ref("p"), row + 1)
    1: IndexRef(Ref("p"), num-pins - row)
  
; Create a two-column landpattern
public defn make-two-column-landpattern (count: Int,    ; number of pads in the column
                                         pitch: Double, ; pitch of the column
                                         naming-convention: (Int, Int) -> Ref, ; naming convention
                                         pad-convention: (Int, Int) -> JITXDef,
                                         spacing:Double) :
  val locs = grid-locs(count, 2, spacing, pitch)
  val rcs  = 
    for row in 0 to count seq-cat:
      for col in 0 to 2 seq:
        [row, col]

  val mapping = to-tuple $ 
    for (pose in locs, rc in rcs) seq:
      val [row, col] = rc
      PinPadMapping(naming-convention(row, col), pad-convention(row, col), pose)

  make-generic-landpattern(mapping)

public defn make-grid-landpattern (num-rows:Int,
                                   num-cols:Int,
                                   row-pitch:Double,
                                   col-pitch:Double,
                                   naming-convention: (Int, Int) -> Ref,
                                   pad-convention: (Int, Int) -> JITXDef):
  make-grid-landpattern(num-rows, num-cols, row-pitch, col-pitch, naming-convention, pad-convention, fn (r, c): true)

; Create a grid landpattern
public defn make-grid-landpattern (num-rows:Int,
                                   num-cols:Int,
                                   row-pitch:Double,
                                   col-pitch:Double,
                                   naming-convention: (Int, Int) -> Ref,
                                   pad-convention: (Int, Int) -> JITXDef,
                                   ignore?: (Int, Int) -> True|False):
  val rcs = 
    for r in 0 to num-rows seq-cat:
      for c in 0 to num-cols seq:
        [r, c]
  val mapping = to-tuple $ 
    for (coord in rcs, pose in grid-locs(num-rows, num-cols, row-pitch, col-pitch)) seq?:
      val [c, r] = coord
      if not ignore?(r, c):
        One(PinPadMapping(naming-convention(r, c), pad-convention(r, c), pose))
      else:
        None()
  make-generic-landpattern(mapping)

; 2D array of pins
public defn make-pin-grid (n-pin:Int, n-row:Int, pin-pitch:Double, row-pitch:Double, pad-ref, offset-x:Double, offset-y:Double) :
  defn normalize (i:Int):
    0.5 * to-double(i - 1)
  
  inside pcb-landpattern:
    val n-col  = to-int(ceil(to-double(n-pin) / to-double(n-row)))
    val origin = loc(offset-x, offset-y) * loc(
      (normalize(n-row) * row-pitch), ; x
      (normalize(n-col) * pin-pitch)  ; y
    )

    for i in 0 to n-col do :
      for j in 0 to n-row do :
        val idx = n-row * i + j + 1
        val x = to-double(j) * row-pitch
        val y = -1.0 * to-double(i) * pin-pitch
        pad p[idx] : pad-ref at origin * loc(x, y)
    
public defn make-pin-grid (n-pin:Int, n-row:Int, pin-pitch:Double, row-pitch:Double, pad-ref:JITXDef) :
  make-pin-grid(n-pin, n-row, pin-pitch, row-pitch, pad-ref, 0.0, 0.0)

public defn make-pin-grid (n-pin:Int, n-row:Int, pin-pitch:Double, row-pitch:Double) :
  make-pin-grid(n-pin, n-row, pin-pitch, row-pitch, pth-pad(0.5), 0.0, 0.0)

public defn make-pin-grid (n-pin:Int) :
  make-pin-grid(n-pin, 1, 2.54, 2.54, pth-pad(0.5), 0.0, 0.0)

;==================================================================================
; Create a testpad
public pcb-landpattern testpad (d:Double) :
  pad tp : testpoint-pad(d) at loc(0.0,0.0)

; ====== Package Family Generators ================================================
; TODO: Unify These.
public pcb-landpattern dummy-landpattern (n:Int, courtyard:[Double,Double]):
  val r = (max(courtyard[0], courtyard[1]) - 0.2) / 2.0
  for i in 0 to n do :
    var theta = (2.0 * PI / to-double(n)) * to-double(i) + PI
    pad p[i + 1] : bga-pad(0.05) at loc(r * cos(theta), r * sin(theta))

  layer(Courtyard(Top)) = Rectangle(courtyard[0], courtyard[1])
  layer(Silkscreen("f-silk", Top)) = LineRectangle(courtyard[0], courtyard[1])
  ref-label()

; from IPC-SM-782 spec
; Z - width between outer pad edges
; G - width between inner pad edges
; X - pad height
; w, h - width and height of courtyard in mm
public defn make-two-pin-landpattern (Z:Double, G:Double, X:Double, w:Double, h:Double, courtyard?:True|False, polarized?:True|False) :
  inside pcb-landpattern :
    val Y = (Z - G) / 2.0 ; width of pad
    val C2 = (G + Y) / 2.0 ; distance between pad center and package centerline
    if polarized? :
      pad c : smd-pad(Y,X) at loc((- C2), 0.0)
      pad a : smd-pad(Y,X) at loc(C2, 0.0)
      val he = h / 2.0 + 0.25
      val we = w / 2.0 + 0.3
      layer(Silkscreen("pol", Top)) = Line(0.12, [Point(w / 2.0, (- he)) Point((- we), (- he))])
      layer(Silkscreen("pol", Top)) = Line(0.12, [Point((- we), he) Point(w / 2.0, he) ])
      layer(Silkscreen("pol", Top)) = Line(0.30, [Point((- we), (- he)) Point((- we), he)])
    else:
      pad p[1] : smd-pad(Y,X) at loc((- C2), 0.0)
      pad p[2] : smd-pad(Y,X) at loc(C2, 0.0)
    if courtyard? : 
      layer(Courtyard(Top)) = Rectangle(w, h)

public defn make-two-pin-landpattern (Z:Double, G:Double, X:Double, w:Double, h:Double):
  make-two-pin-landpattern(Z,G,X,w,h,true,false)

public pcb-landpattern two-pin-landpattern (Z:Double, G:Double, X:Double, w:Double, h:Double):
  make-two-pin-landpattern(Z,G,X,w,h,true,false)

public pcb-landpattern two-pin-polarized-landpattern (Z:Double, G:Double, X:Double, w:Double, h:Double):
  make-two-pin-landpattern(Z,G,X,w,h,true,true)

public defn make-ipc-two-pin-landpattern (part-name:String, courtyard?:True|False, polarized?:True|False, v1?:True|False):
  inside pcb-landpattern :
    val [Z, G, X, nr, nc] = switch(part-name) :
      "008004":[0.35, 0.10, 0.14, 0.35, 0.14]
      "01005": [0.56, 0.20, 0.23, 0.56, 0.23]
      "0201" : [1.12, 0.20, 0.42, 1.12, 0.42]
      "0402" : [1.53, 0.39, 0.62, 1.53, 0.62]
      "0603" : [2.55, 0.65, 1.00, 2.55, 1.00]
      "0805" : [2.90, 0.90, 2.00, 2.90, 2.00]
      "1206" : [4.05, 1.65, 1.80, 4.60, 2.30]
      "1210" : [4.40, 1.20, 2.70, 5.00, 3.00]
      "2010" : [6.20, 2.60, 2.70, 7.00, 3.00]
      "2512" : [7.35, 4.85, 3.40, 3.90, 7.90]
      "2920" : [9.70, 5.10, 5.60, 10.0, 6.00]
      else : 
        val [l w] = switch(length(part-name)):
          4 : [2 2]
          5 : [2 3]
          6 : [3 3]
        val len = (to-double(part-name[0 to l]) as Double )* 25.4 / (pow(10.0, to-double(l)))
        val width = (to-double(part-name[l to (l + w)]) as Double )* 25.4 / (pow(10.0, to-double(w)))
        val Z = len + 2.0 * (0.084 * len - 0.00543)
        val G = len * 0.465 - 0.222
        val X = width
        val nr = Z
        val nc = X
        [Z, G, X, nr, nc]
    if v1?:
      make-two-pin-landpattern(Z, G, X, nr, nc, courtyard?, polarized?)
    else:
      make-two-pin-landpattern(Z, G, X, nr, nc, courtyard?, polarized?)
    external-names = ([part-name])
    ref-label()

public defn make-ipc-two-pin-landpattern (part-name:String, courtyard?:True|False, polarized?:True|False):
  make-ipc-two-pin-landpattern(part-name, courtyard?, polarized?, true)

;<test>
part-name: "008004" "006003" "01007" "5040" ; last 3 are made up
<test>
public defn make-ipc-two-pin-landpattern (part-name:String) :
  make-ipc-two-pin-landpattern(part-name, true, false)

;<test>
part-name: "01005"
<test>
public pcb-landpattern ipc-two-pin-landpattern (part-name:String) :
  make-ipc-two-pin-landpattern(part-name, true, false)
  ref-label()

public pcb-landpattern ipc-two-pin-landpattern (part-name:String, pol?:True|False) :
  make-ipc-two-pin-landpattern(part-name, true, pol?)
  ref-label()

;<test>
part-name: "1210"
<test>
public pcb-landpattern ipc-two-pin-pol-landpattern (part-name:String) :
  make-ipc-two-pin-landpattern(part-name, true, true)
  ref-label()

public defn make-soic127p-landpattern (n:Int, lead-span:Double) :
  ensure-even-positive!(n, "make-soic127p-landpattern")

  inside pcb-landpattern :  

    val pin-pitch = 1.27

    val x0 = (- ((lead-span / 2.0) - 0.5))
    val y0 = (to-double((n / 2) - 1) * pin-pitch) / 2.0
    val l0 = loc(x0, y0, -90.0)
    val l1 = loc((- x0), (- y0), 90.0)
    
    val pin-row = to-list(row-locs(W, n / 2, pin-pitch))

    for (i in 0 to (n / 2), l in pin-row) do :
      pad p[i + 1] : smd-pad(0.6, 1.5) at l0 * l
    
    for (i in (n / 2) to n, l in pin-row) do :
      pad p[i + 1] : smd-pad(0.6, 1.5) at l1 * l
    
    val pkg-height = to-double((n / 2) - 1) * pin-pitch + 1.1
    val c-w = lead-span + 1.5
    val c-h = pkg-height
    
    layer(Courtyard(Top)) = Rectangle(c-w, c-h)

    ; layer(Silkscreen("f-silk", Top)) = LineRectangle(c-w, c-h)
    layer(Silkscreen("pol", Top)) = Circle(x0 - 2.0, y0, 0.2)
    ref-label()

public defn make-soic127p-landpattern (n:Int) :
  make-soic127p-landpattern(n, 6.0)

;<test>
n: even positive
<test>
public pcb-landpattern soic127p-landpattern (n:Int) :
  make-soic127p-landpattern(n, 6.0)

public pcb-landpattern soic127p-landpattern (n:Int, hs:[Double, Double]) :
  make-soic127p-landpattern(n, 6.0)
  pad p[n + 1] : smd-pad(hs[0], hs[1]) at loc(0.0, 0.0)

; See SOP_JEDEC_MO-153F.pdf for reference
public defn make-sop65-landpattern (n:Int, lead-span:Double) :
  ensure-even-positive!(n, "make-sop65-landpattern")

  inside pcb-landpattern :

    val pin-pitch = 0.65

    val x0 = (- ((lead-span / 2.0) - 0.5))
    val y0 = (to-double((n / 2) - 1) * pin-pitch) / 2.0
    val l0 = loc(x0, y0, -90.0)
    val l1 = loc((- x0), (- y0), 90.0)
    
    val pin-row = to-list(row-locs(W, n / 2, pin-pitch))

    for (i in 1 through (n / 2), l in pin-row) do :
      pad p[i] : smd-pad(0.39, 1.4) at l0 * l
    
    for (i in (n / 2 + 1) through n, l in pin-row) do :
      pad p[i] : smd-pad(0.39, 1.4) at l1 * l
    
    val pkg-height = to-double((n / 2) - 1) * pin-pitch + 0.4
    
    val c-w = lead-span + 0.45
    val c-h = pkg-height
    layer(Courtyard(Top)) = Rectangle(c-w, c-h)

    name = to-string("SOP65 with %_ pins." % [n])
    layer(Silkscreen("pol", Top)) = Circle(x0 - 1.0, y0, 0.2)
    ref-label()

public pcb-landpattern sop65-landpattern (n:Int, lead-span:Double) :
  make-sop65-landpattern(n, lead-span)

;<test>
n: even positive
<test>
public pcb-landpattern sop65-landpattern (n:Int) :
  make-sop65-landpattern(n, 6.4)

public defn make-qfn-landpattern (pin-pitch:Double, lead-span:Double, n-pins:Int, pad-width:Double, pad-length:Double, corner-pads:[Pad,Pad]|False) :
  inside pcb-landpattern :
    var n = -1
    if n-pins % 4 == 0 :
      n = n-pins / 4
    else :
      fatal("make-qfn-landpattern is only for symmetric 4-sided qfns.")

    val x0 = (- (lead-span / 2.0 + 0.3))
    val y0 = (to-double(n - 1) * pin-pitch) / 2.0
    val l0 = loc(x0, y0, -90.0)
    val row-pos = to-list(row-locs(W, n, pin-pitch))

    val pin-pad = smd-pad(S, pad-width, pad-length + 0.3)

    defn place-pads (pose:Pose, i:Int, ub:Int, lb:Int) :
      match(corner-pads:[Pad,Pad]):
        if i == lb:
          pad p[i + 1] : corner-pads[0] at pose
        else if i == ub:
          pad p[i + 1] : corner-pads[1] at pose
        else:
          pad p[i + 1] : pin-pad at pose
      else:
        pad p[i + 1] : pin-pad at pose

    for (i in 0 to n, l in row-pos) do :
      place-pads(loc(x0, y0, -90.0) * l, i, 0, n - 1)
    for (i in n to (n * 2), l in row-pos) do :
      place-pads(loc((- y0), x0, 0.0) * l, i, n, n * 2 - 1)
    for (i in (n * 2) to (n * 3), l in row-pos) do :
      place-pads(loc((- x0), (- y0), 90.0) * l, i, n * 2, n * 3 - 1)
    for (i in (n * 3) to (n * 4), l in row-pos) do :
      place-pads(loc((y0), (- x0), 180.0) * l, i, n * 3, n * 4 - 1)

    layer(Courtyard(Top)) = Rectangle(lead-span, lead-span)
    layer(Silkscreen("pol",Top)) = Circle((lead-span / -2.0) - 1.0, y0, 0.2)
    ref-label()

public pcb-landpattern qfn-landpattern (pin-pitch:Double, lead-span:Double, n-pins:Int, pad-width:Double, pad-length:Double) :
  make-qfn-landpattern(pin-pitch, lead-span, n-pins, pad-width, pad-length, false)

public pcb-landpattern qfn-landpattern (pin-pitch:Double, lead-span:Double, n-pins:Int, pad-width:Double, pad-length:Double, corner-pads:[Pad,Pad]|False) :
  make-qfn-landpattern(pin-pitch, lead-span, n-pins, pad-width, pad-length, corner-pads)

public pcb-landpattern qfn-landpattern (pin-pitch:Double, lead-span:Double, n-pins:Int, pad-width:Double, pad-length:Double, hs:[Double,Double]) :
  make-qfn-landpattern(pin-pitch, lead-span, n-pins, pad-width, pad-length, false)
  pad p[n-pins + 1] : smd-pad(hs[0],hs[1]) at loc(0.0, 0.0)  

public defn make-qfp-landpattern (pin-pitch:Double, lead-span:Double, n-pins:Int, pad-width:Double, pad-length:Double) :
  inside pcb-landpattern :
    var n = -1
    
    if n-pins % 4 == 0 :
      n = n-pins / 4
    else :
      fatal("make-qfp-package is only for symmetric 4-sided qfps.")
    
    val pin-pad = smd-pad(S, pad-width, (pad-length + 0.3))
    
    val x0 = (- ((lead-span / 2.0) + 0.3))
    val y0 = (to-double(n - 1) * pin-pitch) / 2.0
    val l0 = loc(x0, y0, -90.0)
    val row-pos = to-list(row-locs(W, n, pin-pitch))

    for (i in 0 to n, l in row-pos) do :
      pad p[i + 1] : pin-pad at loc(x0, y0, -90.0) * l

    for (i in n to (n * 2), l in row-pos) do :
      pad p[i + 1] : pin-pad at loc((- y0), x0, 0.0) * l

    for (i in (n * 2) to (n * 3), l in row-pos) do :
      pad p[i + 1] : pin-pad at loc((- x0), (- y0), 90.0) * l

    for (i in (n * 3) to (n * 4), l in row-pos) do :
      pad p[i + 1] : pin-pad at loc((y0), (- x0), 180.0) * l

    
    layer(Courtyard(Top)) = Rectangle(lead-span, lead-span)
    layer(Silkscreen("pol",Top)) = Circle((lead-span / -2.0) - 1.0, y0, 0.2)

public pcb-landpattern qfp-landpattern (pin-pitch:Double, lead-span:Double, n-pins:Int, pad-width:Double, pad-length:Double) :
  make-qfp-landpattern(pin-pitch, lead-span, n-pins, pad-width, pad-length)

public defn make-dfn-landpattern (
  n-pad:Int
  pad-pitch:Double
  pad-dims:[Double,Double]
  pad-x0:Double
  body-dims:[Double,Double]
) :
  val [pad-w, pad-h] = pad-dims
  val [body-w, body-h] = body-dims

  inside pcb-landpattern :
    val pin-pad = smd-pad(pad-w, pad-h)

    val n-side = n-pad / 2
    val pad-y0 = to-double(n-side - 1) * pad-pitch / 2.0
    val l0 = loc(pad-x0, pad-y0, -90.0)
    val ln2 = loc((- pad-x0), (- pad-y0), 90.0)
    val pin-row = to-list(row-locs(W, n-side, pad-pitch))

    for (i in 0 to n-side, l in pin-row) do :
      pad p[i + 1] : pin-pad at l0 * l

    for (i in n-side to n-pad, l in pin-row) do :
      pad p[i + 1] : pin-pad at ln2 * l

    val pad-x0-abs = abs(pad-x0)
    val pad-x0-dir = pad-x0 / pad-x0-abs
    val pol-x = pad-x0-dir * (pad-x0-abs + (pad-h / 2.0) + 0.5)

    val courtyard-w = max(body-w, 2.0 * pad-x0-abs + pad-h)
    val courtyard-h = max(body-h, 2.0 * abs(pad-y0) + pad-w)

    layer(Courtyard(Top)) = Rectangle(courtyard-w, courtyard-h)
    layer(Silkscreen("f-silk",Top)) = LineRectangle(body-w, body-h)
    layer(Silkscreen("pol",Top)) = Circle(pol-x, pad-y0, 0.254)
    ref-label()

public pcb-landpattern dfn-landpattern ( n-pad:Int, pad-pitch:Double, pad-dims:[Double,Double], pad-x0:Double, body-dims:[Double,Double]) :
  make-dfn-landpattern(n-pad,pad-pitch,pad-dims,pad-x0,body-dims)

public pcb-landpattern dfn-landpattern ( n-pad:Int, pad-pitch:Double, pad-dims:[Double,Double], pad-x0:Double, body-dims:[Double,Double], hs:[Double,Double]) :
  make-dfn-landpattern(n-pad,pad-pitch,pad-dims,pad-x0,body-dims)
  pad p[n-pad + 1] : smd-pad(hs[0],hs[1]) at loc(0.0, 0.0)  

; returns the letter corresponding to a row in a bga package, for example:
; A, B, C, D, E, E, F, G, H, J, K, L, M, N, P, R, T, U, V, W, Y
; AA, AB, ... etc
public defn red-alph-letter (idx:Int):
  val table = "ABCDEFGHJKLMNPRTUVWY"
  val buf = StringBuffer()
  let loop (row: Int = idx):
    if row >= length(table):
      print(buf, table[row / length(table) - 1])
      loop(row / length(table))
  print(buf, table[idx % length(table)])
  to-string(buf)

public defn bga-pin-name (r:Int, c:Int) :
  val letter = red-alph-letter(r)
  Ref(string-join([letter, c + 1]))

public defn make-bga-pkg (pitch:Double, pad-diam:Double, n-pads:[Int Int], courtyard:[Double Double], omit-pads:Tuple<Ref>|False) :
  inside pcb-landpattern :
    val pin-pad = bga-pad(pad-diam)
    defn make-pad (r:Int, c:Int) :
      val x = ((to-double(n-pads[0]) - 1.0) / -2.0 + to-double(c)) * pitch
      val y = ((to-double(n-pads[1]) - 1.0) / 2.0 - to-double(r)) * pitch
      val letter = red-alph-letter(r)
      val name = Ref(letter)[c + 1]

      match(omit-pads:Tuple<Ref>):
        if not contains?(omit-pads, name) :
          pad (name) : pin-pad at loc(x,y)
      else :
          pad (name) : pin-pad at loc(x,y)

    for c in 0 to n-pads[0] do :
      for r in 0 to n-pads[1] do :
        make-pad(r,c)

    layer(Courtyard(Top)) = Rectangle(courtyard[0], courtyard[1])
    ; layer(Silkscreen("f-silk", Top)) = LineRectangle(courtyard[0], courtyard[1])
    layer(Silkscreen("pol", Top)) = Circle(-0.3 - courtyard[0] / 2.0, courtyard[1] / 2.0, 0.127)
    ref-label()

public pcb-landpattern bga-pkg (pitch:Double, pad-diam:Double, n-pads:[Int Int], courtyard:[Double Double], omit-pads:Tuple<Ref>|False) :
  make-bga-pkg(pitch, pad-diam, n-pads, courtyard, omit-pads)

public pcb-landpattern bga-pkg (pitch:Double, pad-diam:Double, n-pads:[Int Int], courtyard:[Double Double]) :
  make-bga-pkg(pitch, pad-diam, n-pads, courtyard, false)

; Generic package instantiations
; Passives

public pcb-landpattern INDC1005X55 :
  make-ipc-two-pin-landpattern("0402")
  ref-label()

public pcb-landpattern CAPT1005X55 :
  make-ipc-two-pin-landpattern("0402")
  draw-polarity-marker(IndexRef(Ref("p"), 1))
  ref-label()

public pcb-landpattern CAPT1608X80 :
  make-ipc-two-pin-landpattern("0603")
  draw-polarity-marker(IndexRef(Ref("p"), 1))
  ref-label()

public pcb-landpattern CAPT2012X125 :
  make-ipc-two-pin-landpattern("0805")
  draw-polarity-marker(IndexRef(Ref("p"), 1))
  ref-label()

public pcb-landpattern CAPT3216X160 :
  make-ipc-two-pin-landpattern("1206")
  draw-polarity-marker(IndexRef(Ref("p"), 1))
  ref-label()

public pcb-landpattern FUSC7330X390 :
  name = "FUSC7330X390"
  make-two-pin-landpattern(7.26, 2.48, 3.0, 7.5, 3.0)

public pcb-landpattern DIOM-4539X220 :
  name = "DIOM-4539X220"
  make-two-pin-landpattern(5.58, 2.15, 2.18, 5.5, 4.0)
  layer(Silkscreen("pol",Top)) = Line(0.25, [Point(3.0, -1.0), Point(3.0, 1.0)])

public pcb-landpattern d-sod-123 :
  pad c : smd-pad(0.9, 1.2) at loc(-1.65, 0.0)
  pad a : smd-pad(0.9, 1.2) at loc(1.65, 0.0)
  layer(Courtyard(Top)) = Rectangle(4.5, 2.0)
  layer(Silkscreen("pol", Top)) = Line(0.12, [Point(1.65, -1.0) Point(-2.4, -1.0)])
  layer(Silkscreen("pol", Top)) = Line(0.12, [Point(-2.4, 1.0) Point(1.65, 1.0) ])
  layer(Silkscreen("pol", Top)) = Line(0.30, [Point(-2.4, -1.0) Point(-2.4, 1.0)])
  ref-label()

; QFNs

public pcb-landpattern QFN50P715X715X80-48 :
  name = "QFN50P715X715X80-48"
  make-qfn-landpattern(0.5, 7.15, 48, 0.3, 0.5, false)
  pad p[49] : smd-pad(5.1,5.1) at loc(0.0, 0.0)

public pcb-landpattern QFN50P400X400X85-24 :
  name = "QFN50P400X400X85-24"
  make-qfn-landpattern(0.5, 4.0, 24, 0.25, 0.4, false)
  pad p[25] : smd-pad(2.5,2.5) at loc(0.0, 0.0)  

public pcb-landpattern SOT95P280X100-3N :
  
  val x0 = -0.95
  val y0 = -1.0
  pad p[1] : smd-pad(0.6, 0.7) at loc(x0,y0)
  pad p[2] : smd-pad(0.6, 0.7) at loc((- x0), y0)
  pad p[3] : smd-pad(0.6, 0.7) at loc(0.0, (- y0))

  layer(Courtyard(Top)) = Rectangle(3.3, 2.8)
  layer(Silkscreen("pol", Top)) = Circle(x0, y0 - 1.0, 0.2)
  ref-label()

public pcb-landpattern SC-70-3 :
  
  val x0 = -1.85 / 2.0
  val y0 = -1.3 / 2.0
  pad p[1] : smd-pad(0.6, 0.7) at loc(x0,y0)
  pad p[2] : smd-pad(0.6, 0.7) at loc((- x0), y0)
  pad p[3] : smd-pad(0.6, 0.7) at loc(0.0, (- y0))

  layer(Courtyard(Top)) = Rectangle(2.65, 2.35)
  ref-label()

public defn SOT23 () :
  SOT95P280X100-3N

public pcb-landpattern SOT95P280X145-5N :
  val x0 = -0.95
  val y0 = 2.7 / -2.0
  pad p[1] : smd-pad(0.6, 1.05) at loc(x0,y0)
  pad p[2] : smd-pad(0.6, 1.05) at loc(0.0, y0)
  pad p[3] : smd-pad(0.6, 1.05) at loc((- x0), y0)
  pad p[4] : smd-pad(0.6, 1.05) at loc((- x0), (- y0))
  pad p[5] : smd-pad(0.6, 1.05) at loc(x0, (- y0))

  layer(Courtyard(Top)) = Rectangle(2.7, 3.95)  
  layer(Silkscreen("pol", Top)) = Circle(x0, y0 - 1.0, 0.2)
  
  ref-label()

public pcb-landpattern SOT95P280X145-6N :
  val x0 = -0.95
  val y0 = 2.7 / -2.0
  pad p[1] : smd-pad(0.6, 1.05) at loc(x0,y0)
  pad p[2] : smd-pad(0.6, 1.05) at loc(0.0, y0)
  pad p[3] : smd-pad(0.6, 1.05) at loc((- x0), y0)
  pad p[4] : smd-pad(0.6, 1.05) at loc((- x0), (- y0))
  pad p[5] : smd-pad(0.6, 1.05) at loc(0.0, (- y0))
  pad p[6] : smd-pad(0.6, 1.05) at loc(x0, (- y0))

  layer(Silkscreen("pol", Top)) = Circle(x0, y0 - 1.0, 0.2)
  layer(Courtyard(Top)) = Rectangle(2.7, 3.95)  
  
  ref-label()

public pcb-landpattern pin-header-pkg (n-pin:Int, n-row:Int, pin-pitch:Double, row-pitch:Double) :
  val n-col  = to-int(ceil(to-double(n-pin) / to-double(n-row)))
  val naming = fn (r, c): IndexRef(Ref("p"), n-row * r + c)
  val pads   = fn (r, c): pth-pad(Circle(0.25), Circle(0.245))
  make-grid-landpattern(n-row, n-col, row-pitch, pin-pitch, naming, pads)

  val c-w = to-double(n-row) * row-pitch
  val c-h = to-double(n-col) * pin-pitch

  layer(Courtyard(Top)) = Rectangle(c-w, c-h)
  layer(Courtyard(Bottom)) = Rectangle(c-w, c-h)
  layer(Silkscreen("f-silk", Top)) = LineRectangle(c-w, c-h)
  
  ref-label()

public pcb-landpattern smd-testpoint-pkg (d:Double) :
  pad p : testpoint-pad(d) at loc(0.0, 0.0)
  layer(Courtyard(Top)) = Circle(d / 2.0)
  layer(Silkscreen("f-silk", Top)) = Circle(d / 2.0)
  ref-label()

public defn make-two-pin-chip-landpattern (length:Toleranced,
                                           width:Toleranced,
                                           lead-length:Toleranced,
                                           lead-width?:False|Toleranced
                                           fabrication-tolerance:Double,
                                           placement-tolerance:Double
                                           density-level:DensityLevel,
                                           polarized?:True|False,
                                           solder-mask-defined?:True|False):
  inside pcb-landpattern:
    ; helper to compute the pad refs
    defn pad-refs () -> Tuple<Ref>:
      if polarized?:
        [Ref("a"), Ref("c")]
      else:
        [IndexRef(Ref("p"), 1), IndexRef(Ref("p"), 2)]
    
    ; helper to compute the excess required by density level and tolerances
    defn wiggle-room (C:Double):
      val F = fabrication-tolerance
      val P = placement-tolerance
      sqrt(C * C + F * F + P * P)

    ; compute the solder fillets based on the protrusion type
    val land-protrusion-type = BigRectangularLeads when nominal(length) > 0.6 else SmallRectangularLeads
    val fillets = lead-fillets(land-protrusion-type, density-level)

    val Cw = max(plus(width),  minus(width))
    val Cl = max(plus(length), minus(length))
    val Cs = 
      let:
        val a = max(plus(lead-length), minus(lead-length))
        val b = max(plus(length), minus(length))
        sqrt(a * a + b * b)
    
    ; compute the base dimensions of the lands
    val Lmax = max(length)
    val Lmin = min(length)
    val Tmin = min(lead-length)
    val Wmin = match(lead-width?):
      (lead-width:Toleranced): 
        min(lead-width)
      (_:False):
        min(width)
    
    val Smax = Lmax - 2.0 * Tmin
    val [Jt, Jh, Js] = [toe(fillets), heel(fillets), side(fillets)]
    val Zmax = Lmin + 2.0 * Jt + wiggle-room(Cl)
    val Gmin = Smax - 2.0 * Jh - wiggle-room(Cs)
    val Xmin = Wmin + 2.0 * Js + wiggle-room(Cw)

    ; finalize the geometry
    val land-length = 0.5 * (Zmax - Gmin)
    val land-width  = Xmin

    val y-max = 0.5 * Gmin + 0.5 * land-length
    val y-min = -1.0 * y-max

    val refs = pad-refs()
    val pad_ = smd-pad(Rectangle(land-width, land-length))
    pad (refs[0]): pad_ at loc(0.0, y-max)
    pad (refs[1]): pad_ at loc(0.0, y-min)

    val dims = extent-dims()
    layer(Courtyard(Top)) = offset(Rectangle(x(dims), y(dims)), courtyard-excess(fillets))

    if polarized?:
      draw-polarity-marker(Ref("a"))
    ref-label()

public defn make-two-pin-chip-landpattern (length:Toleranced,
                                           width:Toleranced,
                                           lead-length:Toleranced,
                                           lead-width?:False|Toleranced,  ; ...
                                           density-level:DensityLevel,
                                           polarized?:True|False):
  make-two-pin-chip-landpattern(
    length, width, lead-length, lead-width?, 
    FABRICATION-TOLERANCE, PLACEMENT-TOLERANCE, 
    density-level, polarized?,
    false
  )

public defn make-two-pin-chip-landpattern (length:Toleranced,
                                           width:Toleranced,
                                           lead-length:Toleranced,
                                           density-level:DensityLevel,
                                           polarized?:True|False):
  make-two-pin-chip-landpattern(
    length, width, lead-length, false, 
    density-level, polarized?
  )

; Create a two pin chip landpattern factoring in factory tolerances and controlling 
; whether the pads should be considered "solder mask defined" 
public pcb-landpattern two-pin-chip-landpattern (length:Toleranced,
                                                 width:Toleranced,
                                                 lead-length:Toleranced,
                                                 lead-width?:False|Toleranced,
                                                 fabrication-tolerance:Double,
                                                 placement-tolerance:Double
                                                 density-level:DensityLevel,
                                                 polarized?:True|False,
                                                 solder-mask-defined?:True|False):
  make-two-pin-chip-landpattern(
    length, width, lead-length, lead-width?,
    fabrication-tolerance, placement-tolerance, 
    density-level, polarized?
    solder-mask-defined?
  )

; Create a a two pin chip landpattern with a custom lead width, if it exists.
public defn two-pin-chip-landpattern (length:Toleranced,
                                      width:Toleranced,
                                      lead-length:Toleranced,
                                      lead-width?:False|Toleranced,
                                      density-level:DensityLevel,
                                      polarized?:True|False):
  two-pin-chip-landpattern(
    length, width, lead-length, lead-width?, 
    FABRICATION-TOLERANCE, PLACEMENT-TOLERANCE, 
    density-level, polarized?,
    false
  )

; Create a two-pin chip landpattern with a custom density level
public defn two-pin-chip-landpattern (length:Toleranced,
                                      width:Toleranced,
                                      lead-length:Toleranced,
                                      density-level:DensityLevel,
                                      polarized?:True|False):
  two-pin-chip-landpattern(
    length, width, lead-length, false, 
    density-level, polarized?
  )

; Create a two-pin chip landpattern given legnth, width, and lead-lengths
public defn two-pin-chip-landpattern (length:Toleranced,
                                      width:Toleranced,
                                      lead-length:Toleranced,
                                      polarized?:True|False):
  two-pin-chip-landpattern(
    length, width, lead-length, false, 
    DensityLevelC, polarized?
  )
