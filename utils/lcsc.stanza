#use-added-syntax(jitx)
defpackage ocdb/utils/lcsc :
  import core
  import collections
  import json
  import lang-utils

  import jitx
  import jitx/commands

;======================================
;============ Public API ==============
;======================================

public defn make-component (json: JObject) -> False : ;FIXME!: Instantiable
  val pads = make-pads(json["pads"] as Tuple<JObject>)
  val landpattern = make-landpattern(json["landpattern"] as JObject,
                                     pads)
  false

public defn make-pads (json: Tuple<JObject>) -> Tuple<Pad> :
  val pads = map(PadCode, json)
  map(to-jitx, pads)

public defn make-landpattern (json: JObject, pads: Tuple<Pad>) -> LandPattern :
  val landpattern = LandPatternCode(json, pads)
  to-jitx(landpattern)

;======================================
;============= Internals ==============
;======================================

;--------------------------------------
;---------------- Pad -----------------
;--------------------------------------

public defstruct PadCode :
  def-name: String    ; referenced by the landpattern to use the pad
  description: String|False
  type: PadType
  shape: Shape
  ;layers: Tuple<PCBLayerCode>

defn PadCode (json: JObject) -> PadCode :
  ;val name = json["name"] as String|False    ; Useful?

  PadCode(json["def-name"] as String,
          json["description"] as String|False,
          PadType(json["type"] as String),
          Shape(json["shape"] as JObject),
          )
          ;map(PCBLayerCode, json["layers"] as Tuple<JObject>))

defn PadType (s: String) -> PadType :
  switch(s) :
    "SMD": SMD
    "TH": TH

defn Shape (json: JObject) -> Shape :
  ; FIXME!
  EmptyShape()

;defn PCBLayerCode (json: JObject) -> PCBLayerCode :
;  FIXME!
;  PCBLayerCode(Cutout(), EmptyShape())

defn to-jitx (p: PadCode) -> Pad :
  pcb-pad my-pad :
    ; name is actually def-name because needed to be connected to landpattern referencing def-name
    name = def-name(p)
    val description = description(p)
    match(description: String) :
      description = description
    type = type(p)
    shape = shape(p)

    ;do(to-jitx, layers(p))

  my-pad

;--------------------------------------
;------------ Landpattern -------------
;--------------------------------------

public defstruct LandPatternCode :
  name: String    ; originally def-name
  pads: Tuple<LandPatternPadCode>
  ;layers: Tuple<PCBLayerCode>
  ;geometries: Tuple<GeomCode>
  ;model3ds: Tuple<Model3D>

public defstruct LandPatternPadCode :
  name: Ref
  pad: Pad ; FIXME!: Linked to table of pad variables
  pose: Pose
  side: Side

defn LandPatternCode (json: JObject,
                      pads: Tuple<Pad>) -> LandPatternCode :
  val pad-table = to-hashtable(name, pads)
  LandPatternCode(json["def-name"] as String,
                  map(LandPatternPadCode{_, pad-table}, json["pads"] as Tuple<JObject>),
                  )
                  ;FIXME!
                  ;map(PCBLayerCode, json["layers"] as Tuple<JObject>),
                  ;map(GeomCode, json["geometries"] as Tuple<JObject>),
                  ;map(GeomCode, json["model3ds"] as Tuple<JObject>))

defn LandPatternPadCode (json: JObject,
                         pad-table: HashTable<String, Pad>) -> LandPatternPadCode :
  val pad-def-name = (json["pad"] as JObject)["name"] as String
  LandPatternPadCode(to-ref!(json["def-name"] as String),
                     pad-table[pad-def-name],
                     Pose(json["pose"] as JObject),
                     Side(json["side"] as String))

defn Pose (json: JObject) -> Pose :
  Pose(Point(json["center"] as JObject),
       json["angle"] as Double,
       json["flip-x?"] as True|False)

defn Point (json: JObject) -> Point :
  Point(json["x"] as Double, json["y"] as Double)

defn Side (s: String) -> Side :
  switch(s) :
    "Top": Top
    "Bottom": Bottom

defn to-jitx (lp: LandPatternCode) -> LandPattern :
  pcb-landpattern my-landpattern :
    name = name(lp)
    do(to-jitx, pads(lp))
    ;do(to-jitx, layers(lp))
    ;do(to-jitx, geometries(lp))
    ;do(to-jitx, model3ds(lp))

  my-landpattern

defn to-jitx (p: LandPatternPadCode) :
  inside pcb-landpattern :
    pad (name(p)) : /pad(p) at pose(p) on side(p)

;======================================
;============== Utils =================
;======================================

;FIXME! : Replace Ref String by JObject in json because the code below does not handle `\|` escaping

;Ref constructor for a String: inverse of print
;e.g.: "a[2].rty" -> FieldRef(IndexRef(VarRef(`a), 2), VarRef(`rty))
public defn to-ref! (x: String) -> Ref :
  try :
    string-to-ref!(x)
  catch (e: Exception) :
    throw(Exception("Invalid string input for to-ref!. %_" % [to-string(e)]))

;Inverse of print(r: Ref)
;Take the print out of a Ref as a String and return the Ref.
;e.g.: a[2].rty -> FieldRef(IndexRef(VarRef(`a), 2), VarRef(`rty))
defn string-to-ref! (text: String) -> Ref :
  if text[length(text) - 1] == ']' :
    match(last-index-of-char(text, '[')) :
      (separator-idx:Int) :
        val index-str = text[(separator-idx + 1) to (length(text) - 1)]
        match(to-int(index-str)) :
          (index: Int) :
            IndexRef(ref, index) where :
              val ref = string-to-ref!(text[0 to separator-idx])
          (_: False) :
            throw(Exception("IndexRef index is not an integer, got '%_'." % [index-str]))
      (_: False) :
        throw(Exception("No matching '[' for ']', input: `%_`." % [text]))
  else :
    match(last-index-of-char(text, '.')) :
      (separator-idx: Int) :
        FieldRef(ref, field) where :
          val ref = string-to-ref!(text[0 to separator-idx])
          val field = Ref(text[(separator-idx + 1) to false])
      (_: False) :
        Ref(text)
