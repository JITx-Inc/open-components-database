#use-added-syntax(jitx)
defpackage ocdb/utils/lcsc :
  import core
  import collections
  import json
  import lang-utils

  import jitx
  import jitx/commands

;======================================
;============ Public API ==============
;======================================

public defn make-component (json: JObject) -> False : ;FIXME!: Instantiable
  val pads = make-pads(json["pads"] as Tuple<JObject>)
  val landpattern = make-landpattern(json["landpattern"] as JObject,
                                     pads)
  false

public defn make-pads (json: Tuple<JObject>) -> Tuple<Pad> :
  val pads = map(PadCode, json)
  map(to-jitx, pads)

public defn make-landpattern (json: JObject, pads: Tuple<Pad>) -> LandPattern :
  val landpattern = LandPatternCode(json, pads)
  to-jitx(landpattern)

;======================================
;============= Internals ==============
;======================================

;--------------------------------------
;---------------- Pad -----------------
;--------------------------------------

public defstruct PadCode :
  def-name: String    ; referenced by the landpattern to use the pad
  description: String|False
  type: PadType
  shape: Shape
  layers: Tuple<PCBLayerCode>

public defstruct PCBLayerCode :
  layer: LayerSpecifier
  shape: Shape

defn PadCode (json: JObject) -> PadCode :
  ;val name = json["name"] as String|False    ; Useful?

  PadCode(json["def-name"] as String,
          json["description"] as String|False,
          PadType(json["type"] as String),
          Shape(json["shape"] as JObject),
          map(PCBLayerCode, json["layers"] as Tuple<JObject>))

defn PadType (s: String) -> PadType :
  switch(s) :
    "SMD": SMD
    "TH": TH

defn Shape (json: JObject) -> Shape :
  switch(json["__object_type__"] as String) :
    "EmptyShape": EmptyShape()
    "Point": Point(json)
    "Polygon": Polygon(json)
    "Circle": Circle(json)
    "Segment": Segment(json)
    "Arc": Arc(json)
    "Rectangle": Rectangle(json)
    "Capsule": Capsule(json)
    "RoundedRectangle": RoundedRectangle(json)
    "ChamferedRectangle": ChamferedRectangle(json)
    "DShape": DShape(json)
    "Line": Line(json)
    "Polyline": Polyline(json)
    "PolygonWithArcs": PolygonWithArcs(json)
    "Union": Union(json)
    "Text": Text(json)
    "GeneralRoundedRectangle": GeneralRoundedRectangle(json)
    "GeneralChamferedRectangle": GeneralChamferedRectangle(json)
    "Difference": Difference(json)

defn Point (json: JObject) -> Point :
  Point(json["x"] as Double,
        json["y"] as Double)

defn Polygon (json: JObject) -> Polygon :
  Polygon $ map(Point, json["points"] as Tuple<JObject>)

defn Circle (json: JObject) -> Circle :
  Circle(Point(json["center"] as JObject),
         json["radius"] as Double)

defn Segment (json: JObject) -> Segment :
  Segment(Point(json["source"] as JObject),
          Point(json["target"] as JObject))

defn Arc (json: JObject) -> Arc :
  Arc(Point(json["center"] as JObject),
      json["radius"] as Double,
      json["start-angle"] as Double,
      json["angle"] as Double)

defn Rectangle (json: JObject) -> Rectangle :
  Rectangle(json["width"] as Double,
            json["height"] as Double,
            Pose(json["pose"] as JObject))

defn Capsule (json: JObject) -> Capsule :
  Capsule(json["width"] as Double,
            json["height"] as Double,
            Pose(json["pose"] as JObject))

defn RoundedRectangle (json: JObject) -> RoundedRectangle :
  RoundedRectangle(json["width"] as Double,
                   json["height"] as Double,
                   json["radius"] as Double,
                   Pose(json["pose"] as JObject))

defn ChamferedRectangle (json: JObject) -> ChamferedRectangle :
  ChamferedRectangle(json["width"] as Double,
                     json["height"] as Double,
                     json["radius"] as Double,
                     Pose(json["pose"] as JObject))

defn DShape (json: JObject) -> DShape :
  DShape(json["width"] as Double,
         json["height"] as Double,
         json["radius"] as Double,
         Pose(json["pose"] as JObject))

defn Line (json: JObject) -> Line :
  Line(json["width"] as Double,
       map(Point, json["points"] as Tuple<JObject>))

defn Polyline (json: JObject) -> Polyline :
  Polyline(json["width"] as Double,
           map(Shape, json["elements"] as Tuple<JObject>))

defn PolygonWithArcs (json: JObject) -> PolygonWithArcs :
  PolygonWithArcs $ map(Shape, json["elements"] as Tuple<JObject>)

defn Union (json: JObject) -> Union :
  Union(map(Shape, json["shapes"] as Tuple<JObject>)) as Union

defn Text (json: JObject) -> Text :
  Text(json["string"] as String,
       json["size"] as Double,
       Anchor(json["anchor"] as String),
       Pose(json["pose"] as JObject),
       json["font"] as String)

defn Anchor (s: String) -> Anchor :
  switch(s) :
    "N": N
    "S": S
    "E": E
    "W": W
    "NE": NE
    "SE": SE
    "SW": SW
    "NW": NW
    "C": C

defn TextKind (s: String) -> TextKind :
  switch(s) :
    "StrokeFont": StrokeFont
    "TrueTypeFont": TrueTypeFont
    "BarCode": BarCode

defn GeneralRoundedRectangle (json: JObject) -> GeneralRoundedRectangle :
  GeneralRoundedRectangle(json["width"] as Double,
            json["height"] as Double,
            json["radii"] as Tuple<Double>,
            Pose(json["pose"] as JObject))

defn GeneralChamferedRectangle (json: JObject) -> GeneralChamferedRectangle :
  GeneralChamferedRectangle(json["width"] as Double,
            json["height"] as Double,
            json["radii"] as Tuple<Double>,
            Pose(json["pose"] as JObject))

defn Difference (json: JObject) -> Difference :
  Difference(Shape(json["shape1"] as JObject),
             Shape(json["shape2"] as JObject))

defn PCBLayerCode (json: JObject) -> PCBLayerCode :
  PCBLayerCode(LayerSpecifier(json["layer"] as JObject),
               Shape(json["shape"] as JObject))

defn LayerSpecifier (json: JObject) -> LayerSpecifier :
  switch(json["__object_type__"] as String) :
    "Cutout": Cutout()
    "Courtyard": Courtyard(json)
    "SolderMask": SolderMask(json)
    "Paste": Paste(json)
    "Glue": Glue(json)
    "Finish": Finish(json)
    "Silkscreen": Silkscreen(json)
    "ForbidCopper": ForbidCopper(json)
    "ForbidVia": ForbidVia()
    "BoardEdge": BoardEdge()
    "CustomLayer": CustomLayer(json)

defn Courtyard (json: JObject) -> Courtyard :
  Courtyard(Side(json["side"] as String))

defn SolderMask (json: JObject) -> SolderMask :
  SolderMask(Side(json["side"] as String))

defn Paste (json: JObject) -> Paste :
  Paste(Side(json["side"] as String))

defn Glue (json: JObject) -> Glue :
  Glue(Side(json["side"] as String))

defn Finish (json: JObject) -> Finish :
  Finish(Side(json["side"] as String))

defn Silkscreen (json: JObject) -> Silkscreen :
  Silkscreen(json["name"] as String,
             Side(json["side"] as String))

defn ForbidCopper (json: JObject) -> ForbidCopper :
  ForbidCopper(LayerIndex(json["start"] as JObject),
               LayerIndex(json["end"] as JObject))

defn LayerIndex (json: JObject) -> LayerIndex :
  LayerIndex(json["index"] as Int,
             Side(json["side"] as String))

defn CustomLayer (json: JObject) -> CustomLayer :
  CustomLayer(json["name"] as String)

defn to-jitx (p: PadCode) -> Pad :
  pcb-pad my-pad :
    ; name is actually def-name because needed to be connected to landpattern referencing def-name
    name = def-name(p)
    val description = description(p)
    match(description: String) :
      description = description
    type = type(p)
    shape = shape(p)

    do(to-jitx, layers(p))

  my-pad

defn to-jitx (l: PCBLayerCode) :
  inside pcb-pad :
    layer(/layer(l)) = shape(l)

;--------------------------------------
;------------ Landpattern -------------
;--------------------------------------

public defstruct LandPatternCode :
  name: String    ; originally def-name
  pads: Tuple<LandPatternPadCode>
  layers: Tuple<PCBLayerCode>
  ;geometries: Tuple<GeomCode>
  ;model3ds: Tuple<Model3D>

public defstruct LandPatternPadCode :
  name: Ref
  pad: Pad ; FIXME!: Linked to table of pad variables
  pose: Pose
  side: Side

defn LandPatternCode (json: JObject,
                      pads: Tuple<Pad>) -> LandPatternCode :
  val pad-table = to-hashtable(name, pads)
  LandPatternCode(json["def-name"] as String,
                  map(LandPatternPadCode{_, pad-table}, json["pads"] as Tuple<JObject>),
                  map(PCBLayerCode, json["layers"] as Tuple<JObject>),
                  )
                  ;FIXME!
                  ;map(GeomCode, json["geometries"] as Tuple<JObject>),
                  ;map(GeomCode, json["model3ds"] as Tuple<JObject>))

defn LandPatternPadCode (json: JObject,
                         pad-table: HashTable<String, Pad>) -> LandPatternPadCode :
  val pad-def-name = (json["pad"] as JObject)["name"] as String
  LandPatternPadCode(to-ref!(json["def-name"] as String),
                     pad-table[pad-def-name],
                     Pose(json["pose"] as JObject),
                     Side(json["side"] as String))

defn Pose (json: JObject) -> Pose :
  Pose(Point(json["center"] as JObject),
       json["angle"] as Double,
       json["flip-x?"] as True|False)

defn Side (s: String) -> Side :
  switch(s) :
    "Top": Top
    "Bottom": Bottom

defn to-jitx (lp: LandPatternCode) -> LandPattern :
  pcb-landpattern my-landpattern :
    name = name(lp)
    do(to-jitx, pads(lp))
    do(to-jitx, layers(lp))
    ;do(to-jitx, geometries(lp))
    ;do(to-jitx, model3ds(lp))

  my-landpattern

defn to-jitx (p: LandPatternPadCode) :
  inside pcb-landpattern :
    pad (name(p)) : /pad(p) at pose(p) on side(p)

;======================================
;============== Utils =================
;======================================

;FIXME! : Replace Ref String by JObject in json because the code below does not handle `\|` escaping

;Ref constructor for a String: inverse of print
;e.g.: "a[2].rty" -> FieldRef(IndexRef(VarRef(`a), 2), VarRef(`rty))
public defn to-ref! (x: String) -> Ref :
  try :
    string-to-ref!(x)
  catch (e: Exception) :
    throw(Exception("Invalid string input for to-ref!. %_" % [to-string(e)]))

;Inverse of print(r: Ref)
;Take the print out of a Ref as a String and return the Ref.
;e.g.: a[2].rty -> FieldRef(IndexRef(VarRef(`a), 2), VarRef(`rty))
defn string-to-ref! (text: String) -> Ref :
  if text[length(text) - 1] == ']' :
    match(last-index-of-char(text, '[')) :
      (separator-idx:Int) :
        val index-str = text[(separator-idx + 1) to (length(text) - 1)]
        match(to-int(index-str)) :
          (index: Int) :
            IndexRef(ref, index) where :
              val ref = string-to-ref!(text[0 to separator-idx])
          (_: False) :
            throw(Exception("IndexRef index is not an integer, got '%_'." % [index-str]))
      (_: False) :
        throw(Exception("No matching '[' for ']', input: `%_`." % [text]))
  else :
    match(last-index-of-char(text, '.')) :
      (separator-idx: Int) :
        FieldRef(ref, field) where :
          val ref = string-to-ref!(text[0 to separator-idx])
          val field = Ref(text[(separator-idx + 1) to false])
      (_: False) :
        Ref(text)
