#use-added-syntax(jitx)
defpackage intel-demo-part-1 : 
  import core
  import collections
  import jitx
  import jitx/commands

  import ocdb/box-symbol
  import ocdb/bundles
  import ocdb/checks
  import ocdb/generic-components
  import ocdb/land-patterns
  import ocdb/property-structs
  import ocdb/tolerance
  import ocdb/generator-utils

  import ocdb/defaults
  import ocdb/symbols

  import ocdb/connects
  import ocdb/design-vars
  import ocdb/rules

; enable-spy()

OPERATING-TEMPERATURE = [-20.0 70.0]

; IO variant check
; Get a relevant design working that has a collection of IO, and at least 1 i2c bus
; A module that connects to i2c also includes pullup resistors
; 2. Show checks passing on this design
; 3. Use a variant definition to DNP the module that had the pullup resistors - show checks failing
; 4. Add add-open-collector-pullups , show checks passing
; 5. un DNP the module, and show checks passing , but higher iol value.


; Back powering check
; Get a relevant design (Intel processor + SPI flash) running. Has legible code for configuring power states that match Intel conventions "S0" "S5", etc...
; Run the checks without SPI connected - passes
; Connect SPI and re-run - check fails with "Intel processor is back-powered in S0 by spi-flash" because the flash is powered by a regulator that has a power state that is on, when the IO domain of the spi connection on the Intel CPU is off.
; Add a load switch to the SPI flash (that overrides the power state of the spi flash), the check passes.


pcb-landpattern soic127-p8:
  make-n-pin-soic-landpattern(8, 
                              1.27, 
                              tol(6.0, 0.2), 
                              tol(3.9, 0.1), 
                              tol(4.9, 0.1), 
                              min-typ-max(0.4, 1.04, 1.27), 
                              min-typ-max(0.28, 0.38, 0.48),
                              false)

pcb-component Microcontroller : 
  pin-properties : 
    [pin: Ref | pads: Ref ... ]
    [vcc      | p[1]          ]
    [gnd      | p[8]          ]
    [sda      | p[2]          ]
    [scl      | p[3]          ]
    [sleep    | p[4]          ]

  make-box-symbol()
  assign-landpattern(soic127-p8)
  supports i2c :
    i2c.sda => self.sda
    i2c.scl => self.scl
  
  val io = DigitalIO(logic-family,
                     vil,
                     vih,
                     vdd-pin, 
                     gnd-pin,
                     leakage-current) where : 
    val logic-family = OpenCollector(tol(3.3, 0.33), 10.0e-3)
    val vil = 0.25 * 3.3
    val vih = 0.75 * 3.3
    val vdd-pin = self.vcc
    val gnd-pin = self.gnd
    val leakage-current = 0.100

  set-property(self.vcc, `power-pin, PowerPin(tol(3.3, 0.33)))
  set-property(self.vcc, `rail-voltage, 3.3)
  set-property(self.sda, `digital-io, io)
  set-property(self.scl, `digital-io, io)

  set-property(self, `rated-temperature, RatedTemperature(min-max(-40.0, 85.0)))

pcb-module mcu-module :
  pin vcc
  pin gnd
  pin sda
  pin scl
  pin sleep

  inst U1 : Microcontroller
  net (gnd U1.gnd)
  net (vcc U1.vcc)
  net (sda U1.sda)
  net (scl U1.scl)
  net (sleep U1.sleep)
  val cap = bypass-cap-strap(vcc, gnd, 100.0e-9)
  set-property(cap, `operating-point, OperatingPoint(min-max(0.0, 5.0), min-max(0.0, 1.0e-3))) ; peak-voltage, peak-current as Toleranced

  public inst r-scl-pu : chip-resistor(100.0)
  public inst r-sda-pu : chip-resistor(100.0)
  set-property(r-scl-pu, `operating-point, OperatingPoint(min-max(0.0, 5.0), min-max(0.0, 1.0e-3))) ; peak-voltage, peak-current as Toleranced
  set-property(r-sda-pu, `operating-point, OperatingPoint(min-max(0.0, 5.0), min-max(0.0, 1.0e-3))) ; peak-voltage, peak-current as Toleranced  
  net (scl r-scl-pu.p[1])
  net (sda r-sda-pu.p[1])
  net (r-sda-pu.p[2] r-scl-pu.p[2] vcc)

  schematic-group(self) = mcu-module

;   eval-when has-property?(vcc.rail-voltage):
;     val myvcc = property(vcc.rail-voltage)
;     val drive-props = DigitalOutput(CMOSOutput(min-max(0.0, 0.1 * myvcc), min-max(0.8 * myvcc, myvcc)), false, vcc, gnd)
;     val input-props = DigitalInput(0.25 * myvcc, 0.75 * myvcc, vcc, gnd, 50.0e-9)
    ; property(U0TXD.digital-output) = drive-props
    ; property(U0RXD.digital-input) = input-props
    ; property(EN.reset-pin) = ResetPin(input-props)


pcb-component Memory :   
  pin-properties : 
    [pin: Ref | pads: Ref ... ]
    [vcc      | p[1]          ]
    [gnd      | p[8]          ]
    [sda      | p[6]          ]
    [scl      | p[7]          ]

  make-box-symbol()
  assign-landpattern(soic127-p8)
  supports i2c : 
    i2c.sda => self.sda
    i2c.scl => self.scl

  val io = DigitalIO(logic-family,
                     vil,
                     vih,
                     vdd-pin, 
                     gnd-pin,
                     leakage-current) where : 
    val logic-family = OpenCollector(tol(3.3, 0.33), 10.0e-3)
    val vil = 0.25 * 3.3
    val vih = 0.75 * 3.3
    val vdd-pin = self.vcc
    val gnd-pin = self.gnd
    val leakage-current = 0.100
    
  set-property(self.vcc, `power-pin, PowerPin(tol(3.3, 0.33)))
  set-property(self.sda, `digital-io, io)
  set-property(self.scl, `digital-io, io)
  ; property(io[0].p.digital-io) = DigitalIO(OpenCollector(min-max(0.0, 0.1 * 3.3), 28.0e-3), 0.25 * 3.3, 0.75 * 3.3, mcu.VDD3P3-CPU, mcu.GND, 50.0e-9)

  set-property(self, `rated-temperature, RatedTemperature(min-max(-40.0, 85.0)))

pcb-module flash-module :
  pin vcc
  pin gnd
  pin sda
  pin scl

  inst U1 : Memory
  net (gnd U1.gnd)
  net (vcc U1.vcc)
  net (sda U1.sda)
  net (scl U1.scl)
  val cap = bypass-cap-strap(vcc, gnd, 100.0e-9)
  set-property(cap, `operating-point, OperatingPoint(min-max(0.0, 5.0), min-max(0.0, 1.0e-3))) ; peak-voltage, peak-current as Toleranced

  public inst r-scl-pu : chip-resistor(100.0)
  public inst r-sda-pu : chip-resistor(100.0)
  set-property(r-scl-pu, `operating-point, OperatingPoint(min-max(0.0, 5.0), min-max(0.0, 1.0e-3))) ; peak-voltage, peak-current as Toleranced
  set-property(r-sda-pu, `operating-point, OperatingPoint(min-max(0.0, 5.0), min-max(0.0, 1.0e-3))) ; peak-voltage, peak-current as Toleranced  
  net (scl r-scl-pu.p[1])
  net (sda r-sda-pu.p[1])
  net (r-sda-pu.p[2] r-scl-pu.p[2] vcc)
  supports i2c : 
    i2c.sda => U1.sda
    i2c.scl => U1.scl

  schematic-group(self) = flash-module

pcb-component Regulator : 
  pin-properties : 
    [ pin:Ref | pads:Ref ... ]
    [ vin     | p[1]         ]
    [ vout    | p[2]         ]
    [ active  | p[3]         ]
  assign-landpattern(SOT23-3)
  make-box-symbol()
  set-property(self.vout, `power-supply-pin, PowerSupplyPin(3.3, 0.5))
  set-property(self.vin, `power-pin, PowerPin(tol(3.3, 0.33)))
  set-property(self, `rated-temperature, RatedTemperature(min-max(-40.0, 85.0)))

pcb-module sub-module : 
  pin scl
  pin sda
  pin vcc
  pin gnd
  public inst mem : flash-module
  net (mem.vcc, vcc)
  net (mem.gnd, gnd)

  require i2c* : i2c from mem
  net (i2c*.scl, scl)
  net (i2c*.sda, sda)
  schematic-group(self) = sub-module

pcb-module pull-up-option :
  pin scl
  pin sda
  pin vdd

  public inst r-scl-pu : chip-resistor(1000.0)
  public inst r-sda-pu : chip-resistor(1000.0)

  set-property(r-scl-pu, `operating-point, OperatingPoint(min-max(0.0, 5.0), min-max(0.0, 1.0e-3))) ; peak-voltage, peak-current as Toleranced
  set-property(r-sda-pu, `operating-point, OperatingPoint(min-max(0.0, 5.0), min-max(0.0, 1.0e-3))) ; peak-voltage, peak-current as Toleranced


  net (scl r-scl-pu.p[1])
  net (sda r-sda-pu.p[1])
  net (r-sda-pu.p[2] r-scl-pu.p[2] vdd)
;   res-strap(scl, vdd, 1.0e3)
;   res-strap(sda, vdd, 1.0e3)
;   self
  schematic-group(self) = pull-up-option


pcb-module main-module : 
  ; Some power supply
  inst vcc-src : gen-testpad(1.0)
  inst gnd-src : gen-testpad(1.0)

  property(vcc-src.p.power-supply-pin) = PowerSupplyPin(3.3, 0.5)
  set-property(vcc-src, `rated-temperature, RatedTemperature(min-max(-40.0, 85.0)))
  set-property(gnd-src, `rated-temperature, RatedTemperature(min-max(-40.0, 85.0)))

  ; we have a few components, an MCU, 
  ; some peripheral, and some regulator
  inst mcu        : mcu-module
  inst peripheral : sub-module ; note: this is a hierarchical design!
  ; inst peripheral : Peripheral
  inst regulator  : Regulator

  ; require mcu-i2c : i2c from mcu
  ; require peripheral-i2c : i2c from peripheral.mem

  ; net (mcu-i2c peripheral-i2c)
  inst pu : pull-up-option

  ;set-property(pu.r-sda-pu, `DNP, true)

  net (mcu.sda pu.sda)
  net (mcu.scl pu.scl)
  net (mcu.vcc pu.vdd)

  ; inst scl-pu : chip-resistor(470.0)
  ; inst sda-pu : chip-resistor(470.0)
  ; set-property(scl-pu, `operating-point, OperatingPoint(min-max(0.0, 5.0), min-max(0.0, 1.0e-3))) ; peak-voltage, peak-current as Toleranced
  ; set-property(sda-pu, `operating-point, OperatingPoint(min-max(0.0, 5.0), min-max(0.0, 1.0e-3))) ; peak-voltage, peak-current as Toleranced

  ; net (mcu.scl scl-pu.p[1])
  ; net (mcu.sda sda-pu.p[1])
  ; net (sda-pu.p[2] scl-pu.p[2] mcu.vcc)

  ; connect the mcu to the peripheral with 
  ; some digital i/o and power
  net (mcu.sda, peripheral.sda)
  net (mcu.scl, peripheral.scl)
  net vdd (vcc-src.p, regulator.vin, mcu.vcc)
  net vout (regulator.vout, peripheral.vcc)
  net gnd (gnd-src.p, mcu.gnd, peripheral.gnd)
  net (mcu.sleep, regulator.active)

  symbol(gnd) = ocdb/symbols/ground-sym
  symbol(vdd) = ocdb/symbols/altium-power-bar-sym
  symbol(vout) = ocdb/symbols/altium-power-bar-sym

  ; Annotate the power states for the MCU, it is powered off (false)
  ; in the "hibernate" state
  for p in [mcu.sda, mcu.scl] do : 
    set-power-states(p, ["wake"      => true,
                         "hibernate" => false])

  ; We notate that this component propagates  
  set-property(regulator, `power-supply-component, true)
  
  ; We set the power states of the output regulator.
  set-power-states(regulator.vout, [
    "wake"      => true,
    "hibernate" => false])
  
  place(mcu)        on Top
  place(peripheral) on Top
  place(regulator)  on Top
;   place(pu)  on Top

  propagate-rail-voltage()

  propagate-power-states(self)
  check-design(self)
  check power-states(self)


pcb-module main-module-wo-pu : 
  ; Some power supply
  inst vcc-src : gen-testpad(1.0)
  inst gnd-src : gen-testpad(1.0)

  property(vcc-src.p.power-supply-pin) = PowerSupplyPin(3.3, 0.5)
  set-property(vcc-src, `rated-temperature, RatedTemperature(min-max(-40.0, 85.0)))
  set-property(gnd-src, `rated-temperature, RatedTemperature(min-max(-40.0, 85.0)))

  ; we have a few components, an MCU, 
  ; some peripheral, and some regulator
  inst mcu        : mcu-module
  inst peripheral : sub-module ; note: this is a hierarchical design!
  ; inst peripheral : Peripheral
  inst regulator  : Regulator


  inst pu : pull-up-option

  set-property(pu.r-sda-pu, `DNP, true)
  set-property(pu.r-scl-pu, `DNP, true)
  set-property(mcu.r-sda-pu, `DNP, true)
  set-property(mcu.r-scl-pu, `DNP, true)
  set-property(peripheral.mem.r-sda-pu, `DNP, true)
  set-property(peripheral.mem.r-scl-pu, `DNP, true)

  net (mcu.sda pu.sda)
  net (mcu.scl pu.scl)
  net (mcu.vcc pu.vdd)

  ; connect the mcu to the peripheral with 
  ; some digital i/o and power
  net (mcu.sda, peripheral.sda)
  net (mcu.scl, peripheral.scl)
  net vdd (vcc-src.p, regulator.vin, mcu.vcc)
  net vout (regulator.vout, peripheral.vcc)
  net gnd (gnd-src.p, mcu.gnd, peripheral.gnd)
  net (mcu.sleep, regulator.active)

  symbol(gnd) = ocdb/symbols/ground-sym
  symbol(vdd) = ocdb/symbols/altium-power-bar-sym
  symbol(vout) = ocdb/symbols/altium-power-bar-sym
  ; Annotate the power states for the MCU, it is powered off (false)
  ; in the "hibernate" state
  for p in [mcu.sda, mcu.scl] do : 
    set-power-states(p, ["S0" => true,
                         "S5" => false])

  ; We notate that this component propagates  
  set-property(regulator, `power-supply-component, true)
  
  ; We set the power states of the output regulator.
  set-power-states(regulator.vout, [
    "S0" => true,
    "S5" => true])
  
  place(mcu)        on Top
  place(peripheral) on Top
  place(regulator)  on Top
;   place(pu)  on Top

  propagate-rail-voltage()

  propagate-power-states(self)
  check-design(self)
  check power-states(self)



val final-design = run-final-passes(main-module-wo-pu)

set-design("intel-design")
set-main-module(final-design)

run-checks("checks.txt")
view-schematic()
; view-board()
