#use-added-syntax(jitx)
defpackage intel-demo-part-1 : 
  import core
  import collections
  import jitx
  import jitx/commands

  import ocdb/box-symbol
  import ocdb/bundles
  import ocdb/checks
  import ocdb/connects
  import ocdb/design-vars
  import ocdb/defaults
  import ocdb/generator-utils
  import ocdb/generic-components
  import ocdb/land-patterns
  import ocdb/property-structs
  import ocdb/symbols
  import ocdb/rules
  import ocdb/tolerance



; IO variant check
; Get a relevant design working that has a collection of IO, and at least 1 i2c bus
; A module that connects to i2c also includes pullup resistors
; 2. Show checks passing on this design
; 3. Use a variant definition to DNP the module that had the pullup resistors - show checks failing
; 4. Add add-open-collector-pullups , show checks passing
; 5. un DNP the module, and show checks passing , but higher iol value.


; Back powering check
; Get a relevant design (Intel processor + SPI flash) running. Has legible code for configuring power states that match Intel conventions "S0" "S5", etc...
; Run the checks without SPI connected - passes
; Connect SPI and re-run - check fails with "Intel processor is back-powered in S0 by spi-flash" because the flash is powered by a regulator that has a power state that is on, when the IO domain of the spi connection on the Intel CPU is off.
; Add a load switch to the SPI flash (that overrides the power state of the spi flash), the check passes.


;==================================================================================================
;============================ Components, Landpatterns, and Modules ===============================
;==================================================================================================
pcb-landpattern soic127-p8:
  make-n-pin-soic-landpattern(8, 
                              1.27, 
                              tol(6.0, 0.2), 
                              tol(3.9, 0.1), 
                              tol(4.9, 0.1), 
                              min-typ-max(0.4, 1.04, 1.27), 
                              min-typ-max(0.28, 0.38, 0.48),
                              false)

pcb-component Microcontroller : 
  pin-properties : 
    [pin: Ref | pads: Ref ... ]
    [vcc      | p[1]          ]
    [gnd      | p[8]          ]
    [sda      | p[2]          ]
    [scl      | p[3]          ]
    [sleep    | p[4]          ]

  supports i2c :
    i2c.sda => self.sda
    i2c.scl => self.scl
  
  ; Declare our IO pins' properties
  val io = DigitalIO(logic-family,
                     vil,
                     vih,
                     vdd-pin, 
                     gnd-pin,
                     leakage-current) where : 
    val logic-family = 
      OpenCollector(vol, iol) where : 
        val vol = tol(3.3, 0.33)
        val iol = 10.0e-3

    val vil = 0.25 * 3.3
    val vih = 0.75 * 3.3
    val vdd-pin = self.vcc
    val gnd-pin = self.gnd
    val leakage-current = 0.100

  property(self.vcc.power-pin) =  PowerPin(tol(3.3, 0.33))
  property(self.vcc.rail-voltage) =  3.3
  property(self.sda.digital-io) =  io
  property(self.scl.digital-io) =  io
  property(self.rated-temperature) = RatedTemperature(min-max(-40.0, 85.0))

  make-box-symbol()
  assign-landpattern(soic127-p8)

pcb-module mcu-module :
  pin vcc
  pin gnd
  pin sda
  pin scl
  pin sleep

  inst U1 : Microcontroller
  public inst r-scl-pu : chip-resistor(100.0)
  public inst r-sda-pu : chip-resistor(100.0)
  val cap = bypass-cap-strap(vcc, gnd, 100.0e-9)

  net (gnd U1.gnd)
  net (vcc U1.vcc)
  net (sda U1.sda)
  net (scl U1.scl)
  net (sleep U1.sleep)
  net (scl r-scl-pu.p[1])
  net (sda r-sda-pu.p[1])
  net (r-sda-pu.p[2] r-scl-pu.p[2] vcc)
  
  val op = OperatingPoint(v-peak, i-peak) where : 
    val v-peak = min-max(0.0, 5.0)
    val i-peak = min-max(0.0, 1.0e-3)

  property(cap.operating-point)      = op
  property(r-scl-pu.operating-point) = op
  property(r-sda-pu.operating-point) = op  

  schematic-group(self) = mcu-module

pcb-component Memory :   
  pin-properties : 
    [pin: Ref | pads: Ref ... | power-pin:PowerPin       ]
    [vcc      | p[1]          | PowerPin(tol(3.3, 0.33)) ]
    [gnd      | p[8]          | -                        ]
    [sda      | p[6]          | -                        ]
    [scl      | p[7]          | -                        ]

  make-box-symbol()
  assign-landpattern(soic127-p8)
  supports i2c : 
    i2c.sda => self.sda
    i2c.scl => self.scl

  val io = DigitalIO(logic-family,
                     vil,
                     vih,
                     vdd-pin, 
                     gnd-pin,
                     leakage-current) where : 
    val logic-family = OpenCollector(tol(3.3, 0.33), 10.0e-3)
    val vil = 0.25 * 3.3
    val vih = 0.75 * 3.3
    val vdd-pin = self.vcc
    val gnd-pin = self.gnd
    val leakage-current = 0.100
    
  property(self.sda.digital-io) = io
  property(self.scl.digital-io) = io
  property(self.rated-temperature) = RatedTemperature(min-max(-40.0, 85.0))

pcb-module flash-module :
  pin vcc
  pin gnd
  pin sda
  pin scl

  inst U1 : Memory
  public inst r-scl-pu : chip-resistor(100.0)
  public inst r-sda-pu : chip-resistor(100.0)
  val cap = bypass-cap-strap(vcc, gnd, 100.0e-9)
  
  net (gnd U1.gnd)
  net (vcc U1.vcc)
  net (sda U1.sda)
  net (scl U1.scl)
  net (scl r-scl-pu.p[1])
  net (sda r-sda-pu.p[1])
  net (r-sda-pu.p[2] r-scl-pu.p[2] vcc)

  supports i2c : 
    i2c.sda => U1.sda
    i2c.scl => U1.scl

  val op = OperatingPoint(v-peak, i-peak) where : 
    val v-peak = min-max(0.0, 5.0)
    val i-peak = min-max(0.0, 1.0e-3)

  property(cap.operating-point)      = op
  property(r-scl-pu.operating-point) = op
  property(r-sda-pu.operating-point) = op
  schematic-group(self) = flash-module

pcb-component Regulator : 
  pin-properties : 
    [ pin:Ref | pads:Ref ... | power-supply-pin: PowerSupplyPin | power-pin: PowerPin      ]
    [ vin     | p[1]         | -                                | PowerPin(tol(3.3, 0.33)) ]
    [ vout    | p[2]         | PowerSupplyPin(3.3, 0.5)         | -                        ]
    [ active  | p[3]         | -                                | -                        ]
  
  property(self.rated-temperature)     = RatedTemperature(min-max(-40.0, 85.0))
  property(self.power-supply-component) = true

  make-box-symbol()
  assign-landpattern(SOT23-3)

pcb-module sub-module : 
  pin scl
  pin sda
  pin vcc
  pin gnd
  public inst mem : flash-module
  net (mem.vcc, vcc)
  net (mem.gnd, gnd)

  require i2c* : i2c from mem
  net (i2c*.scl, scl)
  net (i2c*.sda, sda)
  schematic-group(self) = sub-module

pcb-module pull-up-option :
  pin scl
  pin sda
  pin vdd

  public inst r-scl-pu : chip-resistor(1000.0)
  public inst r-sda-pu : chip-resistor(1000.0)

  for r in [r-scl-pu, r-sda-pu] do : 
    property(r.operating-point) = OperatingPoint(min-max(0.0, 5.0), min-max(0.0, 1.0e-3))

  net (scl r-scl-pu.p[1])
  net (sda r-sda-pu.p[1])
  net (r-sda-pu.p[2] r-scl-pu.p[2] vdd)

  schematic-group(self) = pull-up-option

; Helper, sets a sequence of objects as "DNP"
defn do-not-populate (objs:Seqable<JITXObject>) : 
  inside pcb-module :
    for obj in objs do : 
      property(obj.DNP) = true

;==================================================================================================
;================================== Main design ===================================================
;==================================================================================================

pcb-enum intel-demo-part-1/DesignVariant : 
  Variant0
  Variant1

pcb-module main-module (variant:DesignVariant) : 
  ; Define some power pins to connect our module
  inst vcc-src : gen-testpad(1.0)
  inst gnd-src : gen-testpad(1.0)

  property(vcc-src.p.power-supply-pin) = PowerSupplyPin(3.3, 0.5)
  property(vcc-src.rated-temperature)  = RatedTemperature(min-max(-40.0, 85.0))
  property(gnd-src.rated-temperature)  = RatedTemperature(min-max(-40.0, 85.0))

  ; We have a few components: an MCU, a peripheral, and a regulator
  inst mcu        : mcu-module
  inst peripheral : sub-module
  inst regulator  : Regulator
  inst pu         : pull-up-option

  ; Declare the net list for our design, connecting pullups, power, and data
  net (mcu.sda, pu.sda)
  net (mcu.scl, pu.scl)
  net (mcu.vcc, pu.vdd)
  net (mcu.sda, peripheral.sda)
  net (mcu.scl, peripheral.scl)
  net (mcu.sleep, regulator.active)
  net vdd  (vcc-src.p, regulator.vin, mcu.vcc)
  net vout (regulator.vout, peripheral.vcc)
  net gnd  (gnd-src.p, mcu.gnd, peripheral.gnd)

  symbol(gnd)  = ocdb/symbols/ground-sym
  symbol(vdd)  = ocdb/symbols/altium-power-bar-sym
  symbol(vout) = ocdb/symbols/altium-power-bar-sym

  ; Place the components in the design    
  place(mcu)        on Top
  place(peripheral) on Top
  place(regulator)  on Top

  ; Now that our design is defined, we declare some additional properties 
  ; about the design to support schematic-level checking and design verification.

  ; For example, we can define the list of DNP components based on the `variant`
  ; parameter in the module generator.
  val dnp-list = 
    switch(variant) : 
      Variant0 : []
      Variant1 : [  pu.r-sda-pu, 
                    pu.r-scl-pu,
                    mcu.r-sda-pu,
                    mcu.r-scl-pu,
                    peripheral.mem.r-sda-pu,
                    peripheral.mem.r-scl-pu  ]
  do-not-populate(dnp-list)


  ; Annotate the power states for the MCU, it is powered off (false) in the "hibernate" state
  for p in [mcu.sda, mcu.scl] do : 
    set-power-states(p, ["wake"      => true,
                         "hibernate" => false])
  
  ; We set the power states of the regulator.
  set-power-states(regulator.vout, [ "wake"      => true,
                                     "hibernate" => false ])

  ; Make sure we propagate the power properties along the rest of the design hierarchy
  propagate-rail-voltage()
  propagate-power-states(self)

  ; Declare what checks we want to run.
  check-design(self)
  check power-states(self)

;==================================================================================================
;==================================== Driver ======================================================
;==================================================================================================
defn main () : 
  ; Initialize the design
  set-design("intel-design")
  
  ; Setup some design variables
  OPERATING-TEMPERATURE = [-20.0, 70.0]
  val BOARD-VARIANT     = Variant0

  ; Run the design and checks
  val final-design = run-final-passes(main-module(BOARD-VARIANT))
  set-main-module(final-design)
  run-checks("checks.txt")

; Launch!
main()

; Debug view of the schematic
view-schematic()
