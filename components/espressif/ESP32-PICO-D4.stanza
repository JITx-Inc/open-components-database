#use-added-syntax(jitx)
defpackage ocdb/espressif/ESP32-PICO-D4 :
  import core
  import collections
  import math
  import jitx
  import jitx/commands

  import ocdb/defaults
  import ocdb/land-patterns
  import ocdb/symbols
  import ocdb/symbol-utils
  import ocdb/generic-components
  import ocdb/bundles
  import ocdb/box-symbol
  import ocdb/property-structs


public pcb-component component :
  name = "ESP32 Pico D4 BLE/WiFi SoC"
  mpn = "ESP32-PICO-D4"
  pin EN 
  pin CLK 
  pin CMD 
  port SD : pin[4]
  port IO : pin[[0 2 4 5 12 13 14 15 16 17 18 19 21 22 23 25 26 27 32 33 34 35]]
  pin U0RXD 
  pin U0TXD 
  pin LNA-IN 
  pin GND 
  pin VDDA 
  pin VDDA3P3 
  pin VDD-SDIO 
  pin VDD3P3-CPU 
  pin VDD3P3-RTC 
  pin SENSOR-VN 
  pin SENSOR-VP 
  pin SENSOR-CAPN 
  pin SENSOR-CAPP 
  port nc : pin[4]

  val generic-props = GenericPin(Interval(-0.3, 3.6, false), 1500.0)

  pin-properties :
    [pin:Ref     | pads:Int ... | side:Dir| generic-pin:GenericPin]
    [EN          | 9            | Left    | generic-props ]
    [CLK         | 31           | Right   | generic-props ]
    [CMD         | 30           | Right   | generic-props ]
    [SD[0]       | 32           | Right   | generic-props ]
    [SD[1]       | 33           | Right   | generic-props ]
    [SD[2]       | 28           | Right   | generic-props ]
    [SD[3]       | 29           | Right   | generic-props ]
    [IO[0]       | 23           | Left    | generic-props ]
    [IO[2]       | 22           | Right   | generic-props ]
    [IO[4]       | 24           | Right   | generic-props ]
    [IO[5]       | 34           | Right   | generic-props ]
    [IO[12]      | 18           | Right   | generic-props ]
    [IO[13]      | 20           | Right   | generic-props ]
    [IO[14]      | 17           | Right   | generic-props ]
    [IO[15]      | 21           | Right   | generic-props ]
    [IO[16]      | 25           | Right   | generic-props ]
    [IO[17]      | 27           | Left    | generic-props ]
    [IO[18]      | 35           | Left    | generic-props ]
    [IO[19]      | 38           | Left    | generic-props ]
    [IO[21]      | 42           | Left    | generic-props ]
    [IO[22]      | 39           | Left    | generic-props ]
    [IO[23]      | 36           | Left    | generic-props ]
    [IO[25]      | 14           | Left    | generic-props ]
    [IO[26]      | 15           | Left    | generic-props ]
    [IO[27]      | 16           | Left    | generic-props ]
    [IO[32]      | 12           | Left    | generic-props ]
    [IO[33]      | 13           | Left    | generic-props ]
    [IO[34]      | 10           | Left    | generic-props ]
    [IO[35]      | 11           | Left    | generic-props ]
    [U0RXD       | 40           | Left    | generic-props ]
    [U0TXD       | 41           | Left    | generic-props ]
    [LNA-IN      | 2            | Right   | generic-props ]
    [GND         | 49           | Down    | - ]
    [VDDA        | 1, 43, 46    | Up      | generic-props ]
    [VDDA3P3     | 3, 4         | Up      | generic-props ]
    [VDD-SDIO    | 26           | Up      | generic-props ]
    [VDD3P3-CPU  | 37           | Up      | generic-props ]
    [VDD3P3-RTC  | 19           | Up      | generic-props ]
    [SENSOR-VN   | 8            | Left    | generic-props ]
    [SENSOR-VP   | 5            | Left    | generic-props ]
    [SENSOR-CAPN | 7            | Left    | generic-props ]
    [SENSOR-CAPP | 6            | Left    | generic-props ]
    [nc[0]       | 44           | Down    | - ]
    [nc[1]       | 45           | Down    | - ]
    [nc[2]       | 47           | Down    | - ]
    [nc[3]       | 48           | Down    | - ]

  make-box-symbol()
  assign-landpattern(qfn-landpattern(0.5, 7.0, 48, 0.25, 0.4, [5.4 5.4]))

  property(VDDA.power-pin)       = PowerPin(Interval(2.3, 3.6, false))
  property(VDDA3P3.power-pin)    = PowerPin(Interval(2.3, 3.6, false))
  property(VDD3P3-CPU.power-pin) = PowerPin(Interval(2.3, 3.6, 3.3))
  property(VDD3P3-RTC.power-pin) = PowerPin(Interval(2.3, 3.6, 3.3))
  eval-when has-property?(VDD3P3-CPU.rail-voltage):
    val vdd = property(VDD3P3-CPU.rail-voltage)
    val drive-props = DigitalOutput(CMOSOutput(Interval(0.0, 0.1 * vdd, false), Interval(0.8 * vdd, vdd, false)))
    val input-props = DigitalInput(0.25 * vdd, 0.75 * vdd)
    property(U0TXD.digital-output) = drive-props
    property(U0RXD.digital-input) = input-props
    property(EN.reset-pin) = ResetPin(input-props)

  ; ESP supports crossbarred IO, so use generic supports
  val reserved-io = [IO[0] IO[16] IO[17] IO[32] IO[33]]
  for IO-pin in ports(IO) do :
    if not contains?(reserved-io, IO-pin) :
      supports io-pin:
        io-pin.p => IO-pin

; Generic digital pin
pcb-bundle io-pin:
  pin p


public pcb-module module :
  port uart : uart-with([`dtr `rts])
  port power : power
  pin ant
  pin gnd
  pin en
  pin boot
  public inst mcu : ocdb/espressif/ESP32-PICO-D4/component

  net (gnd, mcu.GND, power.gnd)
  net (power.vdd, mcu.VDDA, mcu.VDDA3P3, mcu.VDD3P3-CPU, mcu.VDD3P3-RTC)
  bypass-cap-strap(mcu.VDDA3P3, gnd, 10.0e-6)
  bypass-cap-strap(mcu.VDDA3P3, gnd, 0.1e-6)
  net (mcu.LNA-IN, ant)

  ; UART programming interface using control pins
  net ESP-RX (mcu.U0RXD, uart.rx)
  net ESP-TX (mcu.U0TXD, uart.tx)
  public inst q : ocdb/nexperia/PMBT3904/component[2]
  res-strap(uart.dtr, q[0].b, 10.0e3)
  res-strap(uart.rts, q[1].b, 10.0e3)
  net BOOT (mcu.IO[0], q[1].c boot)
  net (mcu.EN, q[0].c en)
  net (uart.rts, q[0].e)
  net (uart.dtr, q[1].e)

  ; Supports statements for digital peripherals
  ; eval-when has-property?(mcu.VDD3P3-CPU.rail-voltage):
  ;   val vdd = property(mcu.VDD3P3-CPU.rail-voltage)
  val vdd = 3.3
  for i in 0 to 22 do:
    supports gpio:
      require io:io-pin from mcu
      gpio.gpio => io.p
      property(io.p.digital-io) = DigitalIO(CMOSOutput(Interval(0.0, 0.1 * vdd, false), Interval(0.8 * vdd, 3.3, false)), 0.25 * vdd, 0.75 * vdd)
  for i in 0 to 16 do:
    supports pwm:
      require io:io-pin from mcu
      pwm.pwm => io.p
      property(io.p.digital-io) = DigitalIO(CMOSOutput(Interval(0.0, 0.1 * vdd, false), Interval(0.8 * vdd, 3.3, false)), 0.25 * vdd, 0.75 * vdd)
  for i in 0 to 2 do:
    supports i2c:
      require io:io-pin[2] from mcu
      i2c.sda => io[0].p
      i2c.scl => io[1].p
      property(io[0].p.digital-io) = DigitalIO(OpenCollector(Interval(0.0, 0.1 * vdd, false), 28.0e-3), 0.25 * vdd, 0.75 * vdd)
      property(io[1].p.digital-io) = DigitalIO(OpenCollector(Interval(0.0, 0.1 * vdd, false), 28.0e-3), 0.25 * vdd, 0.75 * vdd)
  for i in 0 to 2 do:
    val ocdb-uart = ocdb/bundles/uart
    supports ocdb-uart:
      require io:io-pin[2] from mcu
      ocdb-uart.tx => io[0].p
      property(io[0].p.digital-output) = DigitalOutput(CMOSOutput(Interval(0.0, 0.1 * vdd, false), Interval(0.8 * vdd, 3.3, false)))
      ocdb-uart.rx => io[1].p
      property(io[1].p.digital-input) = DigitalInput(0.25 * vdd, 0.75 * vdd)
