#use-added-syntax(jitx)
defpackage ocdb/components/nxp/PCF85363ATL_AX :
  import core
  import collections
  import jitx
  import jitx/commands
  import ocdb/utils/box-symbol
  import ocdb/utils/landpatterns
  import ocdb/utils/bundles
  import ocdb/utils/property-structs

public pcb-landpattern DFN2626-10 :
  make-dfn-land-pattern(num-pins, pitch, package-length, 
    package-width, terminal-length, terminal-width, ep) where :
                 val num-pins = 10, ; number of pins of the component
                 val pitch = 0.5, ; pitch of the pins of the component
                 val package-length = typ(2.675), ; the length of the package 
                 val package-width = typ(2.675), ; the width of the package
                 val terminal-length = typ(0.4), ; the length of the terminals
                 val terminal-width = typ(0.3), ; the width of the terminals
                 val ep = Rectangle(1.36, 2.25); an optional shape of a thermal pad

public pcb-component component :
  datasheet = "http://www.nxp.com/docs/en/data-sheet/PCF85363A.pdf"
  mpn = "PCF85363ATL/AX"
  manufacturer = "NXP"
  reference-prefix = "U"
  description = "Tiny Real-Time Clock/calendar with 64 byte RAM, alarm function, battery switch-over time stamp input, and I2C-bus"
  property(self.rated-temperature) = 85.0

  pin-properties :
    [pin:Ref | pads:Ref ... | side:Dir | electrical-type:String]
    [OSCI | p[1] | Left | "Passive"]
    [VDD | p[10] | Right | "Passive"]
    [EP | p[11] | Down | "Passive"]
    [OSCO | p[2] | Left | "Passive"]
    [VBAT | p[3] | Left | "Passive"]
    [nTS_CLKINTB | p[4] | Left | "Passive"]
    [VSS | p[5] | Left | "Passive"]
    [SDA | p[6] | Right | "Passive"]
    [SCL | p[7] | Right | "Passive"]
    [CLK | p[8] | Right | "Passive"]
    [nINTA_CLK | p[9] | Right | "Passive"]

  assign-landpattern(DFN2626-10)
  make-box-symbol()

  property(self.VDD.power-pin) = PowerPin(min-max(0.9, 5.5))
  property(self.VBAT.power-pin) = PowerPin(min-max(0.9, 5.5))

  supports power:
    power.vdd => self.VDD
    power.gnd => self.VSS

  supports i2c :
    i2c.scl => self.SCL
    i2c.sda => self.SDA

  supports crystal :
    crystal.in => self.OSCI
    crystal.out => self.OSCO

  eval-when has-property?(self.VDD.voltage):
    val vdd = property(self.VDD.voltage)
    val vol = min-max(0.0, 0.2 * vdd)
    val voh = min-max(0.8 * vdd, vdd)
    val vih = typ(0.7 * vdd)
    val vil = typ(0.3 * vdd)
    val cmos = CMOSOutput(vol, voh)

    val oc-SDA = OpenCollector(vol, 8.50e-3)
    val dio-SDA = DigitalIO(oc-SDA, vil, vih, self.VDD, self.VSS, 0.0)
    property(self.SCL.digital-io) = dio-SDA

    val di-SCL = DigitalInput(vil, vih, self.VDD, self.VSS, 0.0)
    property(self.SCL.digital-input) = di-SCL

    val oc-nINTA = OpenCollector(vol, 6.00e-3)
    val dio-nINTA = DigitalIO(oc-nINTA, vil, vih, self.VDD, self.VSS, 0.0)
    property(self.nINTA_CLK.digital-io) = dio-nINTA

    val oc-TS = OpenCollector(vol, 3.00e-3)
    val dio-TS = DigitalIO(oc-TS, vil, vih, self.VDD, self.VSS, 0.0)
    property(self.nTS_CLKINTB.digital-io) = dio-TS

    val cmos-CLK = CMOSOutput(vol, voh)
    val do-CLK = DigitalOutput(cmos-CLK, false, self.VDD, self.VSS)
    property(self.CLK.digital-output) = do-CLK